/*
    
    syntax.js
    Cool Public Domain and Open Source written by Edward Gerhold
    www.linux-swt.de

    at opensource.org/osd/ per intellij idea i found a good explanation
    of what this means
    
    built with ./build_syntax and node inlinefiles.js

    tools/inlinefiles.js
    reads these include directives in
    and processes each recursivly for more inclusions,

    - anything included inside these files is not runnable alone and
      only and of course modularised for better maintainability

    - lib/api.js: includes lib/api/*.js and lib/intrinsics/*.js
      which are sub-packages separated by ECMA-262 definitions
      in a just-cut-out format (i have to clean the code up)

*/

Error.stackTraceLimit = 3;

var syntaxjs;

/* moved outside (temp for experiments with self running) */
    /**
     * a poorly failing A+ or better A- Promise which fails in 1/3 of the tests.
     * The exports have the test adapter forgotten to be removed you can test it.
     * While writing this, i have tested it and see the issue at the throw err handler
     * a console.log(err) prints the error, but a throw err is caught away. Hmm. Should
     * compare what´s really going on some day. And maybe rename makePromise to Promise.
     *
     * var realm = syntaxjs.createRealm();
     * realm.evalAsync("let x = 10; x;").then(function (value) { console.log(v); return v; }, function (err) { throw err; });
     * // now let´s invoke the exception handler by repeating it, let x is already declared will be asyntax error
     * realm.evalAsync("let x = 10; x;").then(function (value) { console.log(v); return v; }, function (err) { console.log(err); });
     * // console.log(err) prints the syntax error
     *
     * @param resolver
     * @returns {*}
     */
    function makePromise(resolver) {

        "use strict";
        var state = "pending";
        var value;

        var reason;
        var handlers = [];
        var promise;

        function isPromise(o) {
            return o && typeof o === "object" && (typeof o.then === "function");
        }

        function isFunction(o) {
            return typeof o === "function";
        }

        function makeFn(type, set, data) {
            return function __resolve__() {

                var newValue, newReason;
                var deferred = set.deferred;
                var callback = set.onFulfilled;
                var errback = set.onRejected;
                try {
                    if (isPromise(data)) {
                        data
                            .then(callback, errback)
                            .then(deferred.resolve, deferred.reject);
                    } else if (type === "resolve") {
                        if (isFunction(callback)) newValue = callback(data);
                        deferred.resolve(newValue);
                    } else if (type === "reject") {
                        try {
                            if (isFunction(errback)) errback(data);
                            deferred.reject(data);
                        } catch(ex) {
                            deferred.reject(ex);
                        }
                    }
                } catch (ex) {
                    try {
                        if (isFunction(errback)) errback(ex);
                        deferred.reject(ex);
                    } catch (ex) {
                        deferred.reject(ex);
                    }
                }
            };
        }

        function resolve(_value_) {
            if (state !== "pending") return;
            state = "resolved";
            value = _value_;
            for (var i = 0, j = handlers.length; i < j; i++) {
                setTimeout(makeFn("resolve", handlers[i], value), 0);
            }
        }

        function reject(_reason_) {
            if (state !== "pending") return;
            state = "rejected";
            reason = _reason_;
            for (var i = 0, j = handlers.length; i < j; i++) {
                setTimeout(makeFn("reject", handlers[i], reason), 0);
            }
        }

        function then(onFulfilled, onRejected) {

            if (isPromise(onFulfilled)) {
                return onFulfilled.then(resolve, reject);
            }

            var deferred = makePromise();
            var set = {
                onFulfilled: onFulfilled,
                onRejected: onRejected,
                deferred: deferred
            };

            if (state === "resolved") {
                setTimeout(function () {
                    try {
                        if (isFunction(onFulfilled)) deferred.resolve(onFulfilled(value));
                        else deferred.resolve(value);
                    } catch (ex) {
                        deferred.reject(ex);
                    }
                }, 0);
            } else if (state == "rejected") {
                setTimeout(function () {
                    if (isFunction(onRejected)) onRejected(reason);
                    deferred.reject(reason);
                }, 0);
            } else if (state === "pending") {
                handlers.push(set);
            }
            return deferred.promise;
        }

        if (resolver !== undefined) {

            if (isFunction(resolver)) {
                // scheduled async "promise = makePromise(function (res, rej) {});""
                setTimeout(function () {
                    resolver(resolve, reject);
                }, 0);
            } else if (isPromise(resolver)) {
                // makePromise(promise) returnt ein neues Promise,
                try {
                    return resolver.then(resolve, reject);
                    //return makePromise(function (resolve, reject) { _then(resolve, reject); });
                } catch (ex) {
                    return makePromise(function (resolve, reject) {
                        reject(ex)
                    });
                }
            }
        }

        promise = Object.freeze({
            then: then,
            get value() {
                return value;
            },
            get reason() {
                return reason;
            },
            get state() {
                return state;
            },
            get isPromise() {
                return true;
            },
            constructor: makePromise
        });

        // makePromise(function (resolve, reject)) returnt das promise und hat die function async scheduled.
        if (isFunction(resolver)) return promise;

        // makePromise() mit no args returnt das deferred object
        var deferred = Object.freeze({
            promise: promise,
            resolve: resolve,
            reject: reject
        });
        return deferred;
    }
    /**
     * What´s the aplus test adapter doing here?
     * This is a joke or? Good that it´s not happening in production.
     * Anyways, so the world can see, it fails 1/3 (i guess in error handling)
     */

    if (typeof exports !== "undefined") {
        exports.makePromise = makePromise;
        // promises-aplus-tests-adapter
        exports.deferred = makePromise;
        exports.resolve = function (value) {
            return makePromise(function (resolve) {
                resolve(value);
            });
        };
        exports.reject = function (reason) {
            return makePromise(function (resolve, reject) {
                reject(reason);
            });
        };
    }
    /**
     * require.cache[id] = Module
     *
     * @param id
     * @param exports
     * @param children
     * @param code
     * @returns {Module}
     * @constructor
     */
    function Module(id, exports, children, code) {
        "use strict";
        var m = Object.create(null);
        m.id = id;
        m.children = children;
        if (exports) m.loaded = true;
        m.exports = exports || {};
        m.require = function (ids, factory) {
            return require.apply(this, arguments);
        };
        if (code) {
            if (typeof code === "function")
                m.factory = code;
            else
                m.factory = new Function("require", "exports", "module", code);
            m.exports = m.factory(m.require, m.exports, m);
            m.loaded = true;
        }
        return m;
    }
    /**
     * syntaxjs.define is a function on the syntaxjs object
     * this one is putting all exported values under it´s
     * required name, the module id, in require.cache[name]
     *
     * define("intrinsic", function (require, exports, module) {
     *      var tables = require("tables");
     *      exports.dummy = IsBindingPattern["ArrayPattern"];
     *      return exports;
     * });
     *
     * syntaxjs.define(name, ["dep1","dep2"], function (dep1, dep2) {
     *      return dep1+dep2;
     * });
     *
     * It looks like the define(function() {}) is missing, i see
     *
     * @param id
     * @param deps
     * @param factory
     * @returns {*|{}|Module.exports}
     *
     */
    function define(id, deps, factory) {
        "use strict";
        var exports = {};
        var children = [];
        var imports = [];
        var returned;
        var m = new Module(id, exports, children);
        var d;
        /*
        // should i do that? i spend 5 minutes on it
        if (arguments.length === 1 && typeof arguments[0] === "object" && arguments[0]) {
            if (typeof __dirname !== "undefined" && typeof __filename == "string") {
               var _id = __dirname + __filename;
               require.cache[_id] = new Module(_id, arguments[0]);
            } else if (typeof location !== undefined) {
                _id = location.href;
                _id = ("" + location.href).slice(("" + location.href).lastIndexOf("/"));
                return require[_id] = arguments[0];
            }
        }
        */
        if (!require.cache) require.cache = Object.create(null);
        if (arguments.length === 2) {
            if (typeof deps === "object" && !Array.isArray(deps)) {
                require.cache[id] = new Module(id, deps);
            }
            if (typeof deps === "function") {
                factory = deps;
                deps = null;
                try {
                    returned = factory(m.require, m.exports, m);
                } catch (ex) {
                    throw ex;
                }
            } else {
                returned = require.cache[id] = deps;
            }
        } else if (deps && deps.length && typeof factory === "function") {
            for (var i = 0, j = deps.length; i < j; i++) {
                imports.push((d = require.cache[deps[i]]) ? d.exports : null);
                children.push(d ? d : null);
            }
            try {
                returned = factory.apply(factory, imports);
            } catch (ex) {
                throw ex;
            }
        }
        m.exports = returned !== undefined ? returned : exports;
        require.cache[id] = m;
        return m.exports;
    }
    /**
     * require does the sync return of module.exports from require.cache[id]
     *
     * it´s defined on syntaxjs, too. You can acces the intrinsic modules by
     * calling syntaxjs.require("name");
     *
     * var tables = require("tables");
     * var format = require("i18n").format;
     *
     * Some might return export objects, some might return functions.
     * I want to change my kind of writing this to return export objects only
     * Everyhting else is a mess like this here still is
     *
     * @param deps
     * @param factory
     * @returns {*}
     */

    function require(deps, factory) {
        "use strict";
        var m;
        var mods = [];
        var exports;

        if (!require.cache) require.cache = Object.create(null);
        if (arguments.length === 1) {
            if (typeof deps === "function") return deps();
            if (m = require.cache[deps]) {
                return m.exports;
            }
            if (!exports) throw "require(id): could not find " + deps;
        } else {

            for (var i = 0, j = deps.length; i < j; i++) {
                m = require.cache[deps[i]];
                mods.push(m ? m.exports : {});
            }
            if (factory)
                return factory.apply(null, mods);
        }
    }



(function () {

    "use strict";

    syntaxjs = Object.create(null);
    
    // first i create syntaxjs and
    // add define, require, modules (require.cache link) and makePromise

/**
 * Created by root on 12.05.14.
 */
define("detector", function () {
    var hasConsole = typeof console == "object" && console && typeof console.log === "function";
    var hasPrint = typeof print === "function";
    var isWindow = typeof window === "object";
    var isJava = typeof Java !== "undefined";
    var isWorker = typeof importScripts === "function" && typeof window === "undefined";
    var isNode = typeof process !== "undefined" && typeof global !== "undefined";
    var isBrowser = isWindow && !isWorker && !isNode && !isJava;
    return {
        hasConsole: hasConsole,
        hasPrint: hasPrint,
        isJava: isJava,
        isNode:   isNode,
        isWorker: isWorker,
        isWindow: isWindow,
        isBrowser: isBrowser
    };
});    

    // then i have some fs operations


    

// *******************************************************************************************************************************
// file imports
// *******************************************************************************************************************************

define("filesystem", function (require, exports) {

    /*
     var concreteAdapter = makeAdapter({
     test: {
     node: function
     browser: function
     worker: function
     sm: function
     any: function
     }
     work: {
     node: function
     browser: function
     worker: function
     sm: function
     any: function
     },
     default: function () {
     }
     });

     returns a function calling to call work[k] if test[k]
     starts only a work[k] if a test[k] is existing and returning true




     */


    function makeAdapter(methods) {
        if (arguments.length == 0 || typeof methods !== "object" || methods === null) {
            throw new TypeError("makeAdapter(methods) expects { test: {}, work: {} } where work[ĸ]() will be called iff test[k]() succeeds. Both need to be functions. Optional is a methods.default function if no test succeeds.");
        }
        var keys = Object.keys(methods.test);
        return function adapterFunction () {
            for (var i = 0, j = keys.length; i < j; i++) {
                var k = keys[i];

                var test = methods.test[k];

                if ((typeof test == "function" && test()) || test === true) {
                    var work = methods.work[k];
                    if (typeof work != "function") {
                        throw new TypeError("adapter: adaptee.work['"+k+"'] is not a function");
                    }
                    return work.apply(this, arguments);
                }
            }
            if (typeof methods["default"] == "function") return methods["default"].apply(this, arguments);
        };
    }


    function readFileP(name) {
        return makePromise(function (resolve, reject) {
            return readFile(name, resolve, reject);
        });
    }

        // change to f(err, data)

    function readFile(name, callback, errback) {
        if (syntaxjs.system == "node") {
            var fs = module.require("fs");
            return fs.readFile(name, "utf8", function (err, data) {
                if (err) errback(err);
                else callback(data);
            });


        } else if (syntaxjs.system == "browser") {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", name, true);
            xhr.onloadend = function (e) {
                callback(xhr.responseText);
            };
            xhr.onerror = function (e) {
                errback(xhr.responseText);
            };
            xhr.send(null);
            // missing promise
            return true;
        } else if (syntaxjs.system == "worker") {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", name, true);
            xhr.onloadend = function (e) {
                callback(xhr.responseText);
            };
            xhr.onerror = function (e) {
                errback(xhr.responseText);
            };
            xhr.send(null);
            // missing promise
            return true;
        }
    }

    function readFileSync(name) {
        if (syntaxjs.system == "node") {
            var fs = module.require("fs");
            return fs.readFileSync(name, "utf8");
        } else if (syntaxjs.system == "browser") {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", name, false);
            xhr.send(null);
            return xhr.responseText;
        } else if (syntaxjs.system == "worker") {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", name, false);
            xhr.send(null);
            return xhr.responseText;
        }
    }

    exports.readFileP = readFileP;
    exports.readFile = readFile;
    exports.readFileSync = readFileSync;
    exports.makeAdapter = makeAdapter;

    return exports;
});


    // require("i18n").format("KEY", ...varags) translates from now on
    
//---#include "lib/intl/identifier-module.js"; // only loading takes longer, i need to learn more from m.bynens and norbert l. (seriously) and then go for Intl and Collator. :)
define("languages.de_DE", function (require, exports) {
    "use strict";


    exports.PUT_FAILS_AT_S = "Put versagt bei Eigenschaft %s";
    exports.DEFPOT_FAILS_AT_S = "DefinePropertyOrThrow versagt bei Eigenschaft %s";
    exports.DELPOT_FAILS_AT_S ="DeletePropertyOrThrow versagt bei Eigenschaft %s";


    exports.REFERENCE_S_UNRESOLVABLE = "Referenz %s ist unauflösbar";
    exports.NOT_A_REFERENCE = "Ist keine Referenz";
    exports.UNRESOLVABLE_REFERENCE = "Unaufloesbare Referenz";
    exports.SET_FAILED_IN_STRICTMODE = "[[Set]] ist im Strict Mode fehlgeschlagen."
    exports.BASE_NEVER_NULL = "Referenz Basis ist hier sonst nie null oder undefined."


    exports.P_HAS_TO_BE_A_VALID_PROPERTY_KEY = "P muss ein gültiger Eigenschaftsschlüssel sein";

    exports.S_NOT_AN_OBJECT = "%s ist kein Object";

    exports.S_HAS_NO_S = "%s hat kein %s";

    exports.S_NOT_UNDEFINED = "%s ist nicht undefined."
    exports.S_NOT_COMPLETE = "%s hat nicht alle intrinsic properties."

    exports.HAS_NO_SLOT_S = "Der Slot %s ist nicht verfügbar.";
    exports.SLOT_NOT_AVAILABLE = "slot is not available";

    exports.CAN_NOT_MAKE_SUPER_REF = "Kann keine Superreferenz erzeugen."
    exports.PROXY_CALL_ERROR =  "The Proxy Constructor ist gebaut eine Exception zu werfen, wird er ohne new gerufen..";

    exports.CREATEDATAPROPERTY_FAILED = "CreateDataProperty hat versagt."
    exports.ARRAY_LENGTH_ERROR = "Fehler beim Überprüfen der Arraylängenwerte.";

    exports.TOSTRING_ERROR = "Argument kann nicht in einen String verwandelt werden.";
    exports.SYMBOL_CREATE_ERROR = "The Symbol[@@create] Methode der Symbol Function ist aufgefordert einen TypeError zu werfen.";
    exports.SYMBOL_TOPRIMITVE_ERROR = "Symbol.prototype[@@toPrimitive] ist dazu angehalten hier einen TypeError zu werfen!";
    exports.GLOBAL_SYMBOL_REGISTRY_ERROR = "Zusicherungsfehler. Duplikat in GlobalSymbolRegistry, das nicht sein darf.";
    exports.S_NOT_A_SYMBOL = "%s ist kein Symbol";

    exports.SLOT_CONTAINS_NO_S = "Der Slot beinhaltet keine %s";
    exports.SLOT_S_OF_INVALID_TYPE = "Der Slot %s ist von unzulässigen Typs.";
    exports.SLOT_S_NOT_A_STRING = "Der Slot %s ist kein String.";

    exports.S_IS_FALSE = "%s ist false, sollte aber nicht."
    exports.S_IS_TRUE = "%s is true, sollte aber nicht."
    exports.S_IS_UNDEFINED = "%s ist undefined, sollte aber nicht."
    exports.S_NOT_OBJECT = "%s ist kein Objekt";

    exports.S_NO_CONSTRUCTOR = "%s ist keine Konstruktorfunktion.";
    exports.NO_CONSTRUCTOR = "Kein Konstruktor.";

    exports.S_NOT_CALLABLE = "%s ist nicht aufrufbar.";
    exports.NOT_CALLABLE = "Keine Funktion";

    exports.NULL_NOT_COERCIBLE = "null is nicht erzwingbar durch die Testfunktion CheckObjectCoercible";
    exports.UNDEFINED_NOT_COERCIBLE = "undefined ist nicht erzwingbar durch die Testfunktion CheckObjectCoercible";

    exports.S_ALREADY_INITIALIZED = "%s ist bereits initialisiert.";
    exports.S_NOT_INITIALIZED = "%s ist nicht richtig initialisiert.";

    exports.EXPECTING_ARRAYLIKE = "Erwartete ein Array-artiges Objekt";

    exports.NO_PARSER_FOR_S = "Habe keine Parserfunktionen für %s";
    exports.NO_COMPILER_FOR_S = "Habe keine Übersetzerfunktion for %s";
    exports.UNKNOWN_CHARACTER_S = "Unbekanntes Zeichen: %s";


    exports.UNKNOWN_INSTRUCTION_S = "Unbekannte Instruktion: %s";
    exports.UNKNOWN_ERROR         = "Unbekannter Fehler";

    // Ranges
    exports.OUT_OF_RANGE = "Nicht im Intervall";
    exports.S_OUT_OF_RANGE_S = "%s ist nicht im Intervall %s";
    exports.S_OUT_OF_RANGE = "%s ausserhalb des Bereichs.";


    exports.AVAILABLE_LANGUAGES = "Verfügbare Sprachen";
    exports.LANGUAGE_NOT_FOUND_S = "Sprache nicht gefunden: %s";

    exports.THROW_TYPE_ERROR = "Das System ist dazu angehalten hier einen Fehler mit %ThrowTypeError% zu werfen.";


    // thrown Exceptions by the system
    exports.AN_EXCEPTION = "Eine Ausnahme wurde geworfen:";
    exports.S_EXCEPTION_THROWN = "Eine %s Ausnahme wurde geworfen!";
    exports.EXCEPTION_NAME_S = "Name: %s"
    exports.EXCEPTION_MESSAGE_S = "Botschaft: %s";
    exports.EXCEPTION_STACK_S = "Aufrufstapel: %s";
    exports.LINE_S = "Zeile %s";
    exports.COLUMN_S = "Spalte %s";
    exports.AT_LINE_S_COLUMN_S = "in Zeile %s, Spalte %s";


    return exports;

});


/**
 *
 * syntax.js Language Packs
 *
 * languages.____.js
 * contain a module "languages.___" where ___ is the language
 *
 * The export Objects has a number of well known keys.
 * These keys are used for a call to format(key, ...varargs)
 *
 * The current language pack will be asked for the key and the string under the key.
 * The string will be transposed by replacing the %s placeholders
 *
 * The function format is available with syntaxjs.require("i18n").format;
 *
 * Other possibilites to use the language pack is to call trans("KEY")
 * which is not needing a loop to replace all %s
 *
 */
define("languages.en_US", function (require, exports) {
    "use strict";

    exports.PUT_FAILS_AT_S = "Put fails at property %s";
    exports.DEFPOT_FAILS_AT_S = "DefinePropertyOrThrow fails at property %s";
    exports.DELPOT_FAILS_AT_S ="DeletePropertyOrThrow fails at property %s";

    exports.CREATEDATAPROPERTYORTHROW_FAILED = "CreateDataPropertyOrThrow failed.";

    // Reference
    exports.REFERENCE_S_UNRESOLVABLE = "Reference %s is unresolvable";
    exports.NOT_A_REFERENCE = "Not a reference";
    exports.UNRESOLVABLE_REFERENCE = "Unresolvable Reference";
    exports.SET_FAILED_IN_STRICTMODE = "[[Set]] failed in strict mode";
    exports.BASE_NEVER_NULL = "Reference base may never be null or undefined here."

    //Properties
    exports.P_HAS_TO_BE_A_VALID_PROPERTY_KEY = "P has to be a valid property key";

    // Primitives
    exports.TOSTRING_ERROR = "Can not cast argument into a string."
    exports.SYMBOL_CREATE_ERROR = "The Symbol[@@create] method of the Symbol function is supposed to throw a Type Error";
    exports.SYMBOL_TOPRIMITIVE_ERROR =  "Symbol.prototype[@@toPrimitive] is supposed to throw a Type Error!";
    exports.GLOBAL_SYMBOL_REGISTRY_ERROR = "Assertion Error. Duplicate in GlobalSymbolRegistry which MUST NOT be.";
    exports.S_NOT_A_SYMBOL = "%s is not a symbol";

    exports.S_IS_FALSE = "%s is false, but shouldn´t";
    exports.S_IS_TRUE = "%s is true, but shouldn´t";

    exports.S_IS_UNDEFINED = "%s is undefined but shouldn´t."
    exports.S_NOT_OBJECT = "%s is not an object.";

    exports.S_NOT_UNDEFINED = "%s is not undefined."
        exports.S_NOT_COMPLETE = "%s is not complete with all intrinsic properties."

    exports.S_HAS_NO_S = "%s has no %s";

    // Arrays
    exports.CREATEDATAPROPERTY_FAILED = "CreateDataProperty failed but shouldn´t."
    exports.ARRAY_LENGTH_ERROR = "Error comparing array length values";

    // Objects
    exports.S_NOT_AN_OBJECT = "%s is not an object";

    // Slots
    exports.S_ALREADY_INITIALIZED = "%s is already initialized.";
    exports.S_NOT_INITIALIZED = "%s is not properly initialized";


    exports.SLOT_S_OF_INVALID_TYPE = "The slot %s is of an invalid type.";
    exports.SLOT_S_NOT_A_STRING = "The slot %s contains no string.";

    exports.SLOT_CONTAINS_NO_S = "slot is not containing %s";
    exports.HAS_NO_SLOT_S = "the slot %s is not available.";
    exports.SLOT_NOT_AVAILABLE = "slot is not available";

    // Constructor
    exports.S_NO_CONSTRUCTOR = "%s is not a constructor";
    exports.NO_CONSTRUCTOR = "Not a constructor";

    // Callable
    exports.S_NOT_CALLABLE = "%s is not a callable.";
    exports.NOT_CALLABLE = "Not a function";


    //Super

    exports.CAN_NOT_MAKE_SUPER_REF = "Can not make super reference.";


    exports.PROXY_CALL_ERROR =  "The Proxy Constructor is supposed to throw when called without new.";

    // Ranges
    exports.OUT_OF_RANGE = "Out of range";
    exports.S_OUT_OF_RANGE = "%s out of range.";
    exports.S_OUT_OF_RANGE_S = "%s is out of range %s";

    exports.EXPECTING_ARRAYLIKE = "Expected an array like object";

    // CheckObjectCoercible
    exports.NULL_NOT_COERCIBLE = "null is not coercible by the check function CheckObjectCoercible";
    exports.UNDEFINED_NOT_COERCIBLE = "undefined is not coercible by the check function CheckObjectCoercible";


    exports.NO_PARSER_FOR_S = "Got no parser functions for %s";
    exports.NO_COMPILER_FOR_S = "Got no compiler function for %s";
    exports.UNKNOWN_CHARACTER_S = "Unknown character: %s";

    // VM.eval
    exports.UNKNOWN_INSTRUCTION_S = "Unknown instruction: %s";
    exports.UNKNOWN_ERROR         = "Unknown Error";

    exports.AVAILABLE_LANGUAGES = "Available Languages";
    exports.LANGUAGE_NOT_FOUND_S = "Language not found: %s";

    exports.THROW_TYPE_ERROR = "The system is supposed to throw a Type Error with %ThrowTypeError% here.";


    // thrown Exceptions by the system
    exports.AN_EXCEPTION = "An Exception was thrown:";
    exports.S_EXCEPTION_THROWN = "A %s Exception was thrown!";
    exports.EXCEPTION_NAME_S = "name: %s"
    exports.EXCEPTION_MESSAGE_S = "message: %s";
    exports.EXCEPTION_STACK_S = "stack: %s";
    exports.LINE_S = "line %s";
    exports.COLUMN_S = "column %s";
    exports.AT_LINE_S_COLUMN_S = "at line %s, column %s";


    return exports;
});


define("i18n", function (require, exports) {
"use strict";

    var languages = exports.languages = Object.create(null);

    /**
     * add a language (any string value)
     * it requires an existing module
     * else require throws with the missing filename
     *
     * exports.languages = new Object
     * replaces this object in it´s use
     *
     * @param lang
     */
    function addLang(lang) {
        "use strict";
        languages[lang] = require("languages." + lang);
    }

    /**
     * set the specific default language
     * the module must have been added before,
     * else i throw an exception
     * @param lang
     */
    function setLang(lang) {
        "use strict";
        if (exports.languages[lang]) exports.languages.lang = exports.languages[lang];
        else throw new TypeError("the following language has not been added with setLang(): "+lang);
    }

    /**
     * set a fallback language, if the language has no string available
     * if a fallback isnt present, a "NO_STRING_PRESENT: "+index should be shown
     * @param lang
     */
    function setFallback(lang) {
        "use strict";
        if(exports.languages[lang])
        exports.languages.fallback = exports.languages[lang];
        else throw new TypeError("can not set fallback to '"+lang+"'. language doesn´t exist. Use addLang('"+lang+"') to require('languages."+lang+"')");
    }

    /**
     * format(index, "%s %s %s", "i", "am", "tool");
     * returns "i am tool" or in german, if setLang("de_DE") happened "ich bin Werkzeug"
     * %s is for any value as we are in javascript
     * better formatting can be added but is not concerned now
     *
     * @param index
     * @returns {string}
     */

    function format(index) {
        "use strict";
        var c1, c2;
        var aCount = 1;
        var str = exports.languages.lang[index];
        if (str===undefined) return format("LANGUAGE_NOT_FOUND_S", index);
        c2 = str[0];
        var out = "";
        for (var i = 1, j = str.length; i < j; i++) {
            c1 = c2;
            c2 = str[i];
            if (c1 == "%" && c2 == "s") {
                out += arguments[aCount];
                aCount += 1;
                i+=1;
                c1 = str[i-1];
                c2 = str[i];
            } else {
                out += c1;
            }
        }
        if (c2 != undefined) out+=c2;
        return out;
    }
    /**
     * formatStr is the same as format
     * returns "i am tool" or in german
     * and performs no translation
     *
     * @param str
     * @returns {string}
     */
    function formatStr(str) {
        "use strict";
        var c1, c2;
        var aCount = 1;
        c2 = str[0];
        if (str == undefined) return "";
        var out = "";
        for (var i = 1, j = str.length; i < j; i++) {
            c1 = c2;
            c2 = str[i];
            if (c1 == "%" && c2 == "s") {
                out += arguments[aCount];
                aCount += 1;
                i+=1;
                c1 = str[i-1];
                c2 = str[i];
            } else {
                out += c1;
            }
        }
        if (c2 != undefined) out+=c2;
        return out;
    }

    /**
     * This one fetches a translated string
     * and performs no formatting
     *
     * @param index
     * @returns {*}
     */
    function trans(index) {
        "use strict";
        var s = exports.languages.lang[index];
        if (s == undefined) return format("LANGUAGE_NOT_FOUND_S", lang);
        return s;
    }


exports.languages = languages;
exports.addLang = addLang;
exports.setLang = setLang;
exports.setFallback = setFallback;
exports.trans = trans;
exports.format = format;
exports.formatStr = formatStr;
exports.NOT_FOUND_ERR = "i18n-failure: '%s' not found."

// I initialise this in lib/_main_.js

});




    // the lexer and parser api ast and ast-to-string for es6 code
    
/**
 *
 *	These tables replace my first and follow sets
 *	Because i didn´t know first what they where
 *	For first you just generate the first token type into the list
 *	recursivly the deeper productions firsts bubble up into the top
 * 	level table which is starting with multiple possibilities
 *
 *	These tables here are for use in a if (isInThisObj[key]) comparison to save a
 *      lot of if´s and switch statements on the way down.
 *
 */
define("tables", function (require, exports, module) {

    "use strict";


    var captureExtraTypes = {
        __proto__:null,
        "WhiteSpace":true,
        "LineTerminator": true,
        "MultiLineComment":true,
        "LineComment":true
    };


    var captureExtraValues = {
        __proto__: null,
        "(": true,
        ")": true,
        "[": true,
        "]": true,
        "}": true,
        "{": true,
        ";": true,
        ":": true,
        ",": true
    };

    var FewUnaryKeywords = { // for setting input element regex in the standalone version of the tokenizer
	__proto_:null,
	"yield":true, // yield inputelement=regexp nolthere assignmentexpr 
	"void": true,
	"typeof": true,
	"delete": true
    };
    exports.FewUnaryKeywords = FewUnaryKeywords;

    var StartOfThreeFourPunctuators = {	// for punctuator in the tokenizer
        __proto__:null,
        "!":true,
        "=":true,
        ">":true,
        "<":true,
        ".":true
    };

    var IsTemplateToken = {
        __proto__:null,
        "NoSubstitutionTemplate": true,
        "TemplateHead": true,
        "TemplateMiddle": true,
        "TemplateTail": true
    };

    var ReservedWordsInStrictMode = {
        __proto__:null,
        "implements":true,
        "interface":true,
        "private":true,
        "package":true,
        "static":true,
        "public":true,
        "protected":true,
        "let": true,
        "yield":true,
        "enum":true
    };

    var ForbiddenArgumentsInStrict = {
        __proto__: null,
        "eval": true,
        "arguments": true
    };

    var BindingIdentifiers = {
        __proto__: null,
        "Identifier": true,
        "Keyword": true,
        "FutureReservedWord": true,
        "StringLiteral": true,
        "NumericLiteral": true,
        "BooleanLiteral": true,
        "NullLiteral": true
    };

    var propKeys = Object.create(null);
    propKeys.true = true;
    propKeys.false = true;
    propKeys.null = true;

    var ExprNoneOfs = Object.create(null);
    ExprNoneOfs["function"] = true;
    ExprNoneOfs["class"] = true;
    ExprNoneOfs["module"] = true;
    ExprNoneOfs["{"] = true;

    var MethodKeyByType = {
        __proto__: null,
        "Identifier": true,
        "StringLiteral": true,
        "NumericLiteral": true,
        "BooleanLiteral": true,
        "NullLiteral": true,
        "FutureReservedWord": true
    };

    var MethodKeyByValue = {
        __proto__: null,
        "constructor": true
    };

    var StartBinding = {
        __proto__: null,
        "{": true,
        "[": true
    };



    var SkipableToken = {
        __proto__: null,
        "WhiteSpace": true,
        "LineTerminator": true,
        "LineComment": true,
        "MultiLineComment": true
    };
    var SkipableTokenNoLT = {
        __proto__: null,
        "WhiteSpace": true,
        "LineComment": true,
        "MultiLineComment": true
    };

    var InOrOfInsOf = Object.create(null);
    InOrOfInsOf.in = true;
    InOrOfInsOf.of = true;
    InOrOfInsOf.instanceof = true;

    var InOrOf = Object.create(null);
    InOrOf.in = true;
    InOrOf.of = true;

    var FinishStatementList = {
        __proto__: null,
        ")": true,
        "]": true,
        "}": true
    };

    var FinishSwitchStatementList = {
        __proto__: null,
        ")": true,
        "]": true,
        "}": true,
        "case": true,
        "default": true
    };

    var varKinds = {
        "var": true,
        "let": true,
        "const": true
    };

    var StatementParsers = {
        __proto__: null,
        "{": "BlockStatement",
        "var": "VariableStatement",
        "let": "VariableStatement",
        "const": "VariableStatement",
        "if": "IfStatement",
        "for": "IterationStatement",
        "while": "IterationStatement",
        "do": "IterationStatement",
        "continue": "ContinueStatement",
        "break": "BreakStatement",
        "return": "ReturnStatement",
        "with": "WithStatement",
        "switch": "SwitchStatement",
        "try": "TryStatement",
        "throw": "ThrowStatement",
        "debugger": "DebuggerStatement",
        "import": "ImportStatement",
        "export": "ExportStatement",
        ";": "EmptyStatement"
    };

    var PrimaryExpressionByValue = {
        __proto__: null,
        "(": "CoverParenthesizedExpressionAndArrowParameterList",
        
        "[": "ArrayExpression",	
        "{": "ObjectExpression",
        "class": "ClassExpression",
        "function": "FunctionExpression",
        "this": "ThisExpression",
        "super": "SuperExpression",
        "+": "UnaryExpression",
        "-": "UnaryExpression",
        "~": "UnaryExpression",
        "++": "UnaryExpression",
        "--": "UnaryExpression",
        "!!": "UnaryExpression",
        "!": "UnaryExpression",
        "void":"UnaryExpression",
        "typeof":"UnaryExpression",
        "delete":"UnaryExpression"
    };
    
    var PrimaryExpressionByTypeAndFollowByValue = {
        "Identifier": { "=>": "CoverParenthesizedExpressionAndArrowParameterList" }
    };

    var PrimaryExpressionByValueAndFollowByType = {
        "...": { "Identifier": "CoverParenthesizedExpressionAndArrowParameterList" }
    };

    exports.PrimaryExpressionByValueAndFollowByType = PrimaryExpressionByValueAndFollowByType;
    exports.PrimaryExpressionByTypeAndFollowByValue = PrimaryExpressionByTypeAndFollowByValue;
    
    var PrimaryExpressionByType = {
        __proto__: null,
        "Identifier": "Identifier",
        "NumericLiteral": "Literal",
        "TemplateLiteral": "TemplateLiteral",
        "NoSubstitutionTemplate": "TemplateLiteral",
        "TemplateHead": "TemplateLiteral",
        "StringLiteral": "Literal",
        "BooleanLiteral": "Literal",
        "Literal":"Literal",
        "NullLiteral": "Literal",
        "RegularExpressionLiteral": "RegularExpressionLiteral"
    };


    var uriAlpha = {
        __proto__: null,
        "A": true,
        "B": true,
        "C": true,
        "D": true,
        "E": true,
        "F": true,
        "G": true,
        "H": true,
        "I": true,
        "J": true,
        "K": true,
        "L": true,
        "M": true,
        "N": true,
        "O": true,
        "P": true,
        "Q": true,
        "R": true,
        "S": true,
        "T": true,
        "U": true,
        "V": true,
        "W": true,
        "X": true,
        "Y": true,
        "Z": true,
        "a": true,
        "b": true,
        "c": true,
        "d": true,
        "e": true,
        "f": true,
        "g": true,
        "h": true,
        "i": true,
        "j": true,
        "k": true,
        "l": true,
        "m": true,
        "n": true,
        "o": true,
        "p": true,
        "q": true,
        "r": true,
        "s": true,
        "t": true,
        "u": true,
        "v": true,
        "w": true,
        "x": true,
        "y": true,
        "z": true
    };
    var uriMark = {
        __proto__: null,
        "~": true,
        "_": true,
        ".": true,
        "!": true,
        "-": true,
        "*": true,
        "'": true,
        "(": true,
        ")": true
    };

    var uriReserved = {
        __proto__: null,
        ";": true,
        "/": true,
        "?": true,
        ":": true,
        "@": true,
        "&": true,
        "=": true,
        "+": true,
        "$": true,
        ",": true
    };

    var ControlEscape = {
        "f": true,
        "n": true,
        "r": true,
        "t": true,
        "v": true
    };
    var ControlLetter = {
        __proto__: null,
        "A": true,
        "B": true,
        "C": true,
        "D": true,
        "E": true,
        "F": true,
        "G": true,
        "H": true,
        "I": true,
        "J": true,
        "K": true,
        "L": true,
        "M": true,
        "N": true,
        "O": true,
        "P": true,
        "Q": true,
        "R": true,
        "S": true,
        "T": true,
        "U": true,
        "V": true,
        "W": true,
        "X": true,
        "Y": true,
        "Z": true,
        "a": true,
        "b": true,
        "c": true,
        "d": true,
        "e": true,
        "f": true,
        "g": true,
        "h": true,
        "i": true,
        "j": true,
        "k": true,
        "l": true,
        "m": true,
        "n": true,
        "o": true,
        "p": true,
        "q": true,
        "r": true,
        "s": true,
        "t": true,
        "u": true,
        "v": true,
        "w": true,
        "x": true,
        "y": true,
        "z": true
    };
    var CharacterClassEscape = {
        "d": true,
        "D": true,
        "s": true,
        "S": true,
        "w": true,
        "W": true
    };

    var NonPatternCharacter = {
        "^": true,
        "$": true,
        "\\": true,
        ".": true,
        "*": true,
        "+": true,
        "?": true,
        "(": true,
        ")": true,
        "[": true,
        "]": true,
        "{": true,
        "}": true,
        "|": true
    };

    var LPAREN = {
        __proto__: null,
        "(": true,
        "[": true,
        "{": true
    };
    var RPAREN = {
        __proto__: null,
        ")": true,
        "]": true,
        "}": true
    };
    var LPARENOF = {
        __proto__: null,
        ")": "(",
        "]": "[",
        "}": "{"
    };
    var RPARENOF = {
        __proto__: null,
        "(": ")",
        "[": "]",
        "{": "}"
    };

    var typedArrayElementSize = {
        "Float64": 8,
        "Float32": 4,
        "Int32": 4,
        "Uint32": 4,
        "Int16": 2,
        "Uint16": 2,
        "Int8": 1,
        "Uint8": 1,
        "Uint8Clamped": 1
    };

    var TypedArrayElementType = {
        "Float64Array": "Float64",
        "Float32Array": "Float32",
        "Int32Array": "Int32",
        "Uint32Array": "Uint32",
        "Int16Array": "Int16",
        "Uint16Array": "Uint16",
        "Int8Array": "Int8",
        "Uint8Array": "Uint8",
        "Uint8ClampedArray": "Uint8C"
    };

    var BuildingPatterns = {
        "Identifier": "identifier",
        "Literal": "literal",
        "WhileStatement": "whileStatement",
        "BlockStatement": "blockStatement",
        "TryStatement": "tryStatement",
        "VariableDeclaration": "variableStatement",
        "LexicalDeclaration": "variableStatement",
        "DoWhileStatement": "doStatement",
        "IfStatement": "ifStatement",
        "ExpressionStatement": "expressionStatement",
        "SequenceExpression": "sequenceStatement"
    };

    var DOM = {
        __proto__: null,
        "window": true,
        "document": true,
        "navigator": true,
        "history": true,
        "screen": true,
        "XMLHttpRequest": true,
        "console": true,
        "childNodes": true,
        "firstChild": true,
        "nextSibling": true,
        "previousSibling": true,
        "appendChild": true,
        "insertBefore": true,
        "insertAdjacentHTML": true,
        "innerHTML": true,
        "outerHTML": true,
        "textContent": true,
        "removeChild": true,
        "createElement": true,
        "createDocumentFragment": true
    };

    var HTML5Objects = {
        "localStorage": true,
        "sessionStorage": true,
        "document": true,
        "window": true,
        "XMLHttpRequest": true,
        "File": true
    };
    var NodeJSObjects = {
        "process": true,
        "global": true
    };

    var StandardBuiltinNames = {
        __proto__:null,
        "Infinity": true,
        "NaN":true,
        "undefined":true

    };


    var Comment = {
        __proto__: null,
        "//": true,
        "/*": true
    };
    var Parentheses = {
        __proto__: null,
        "(": true,
        ")": true,
        "{": true,
        "}": true,
        "[": true,
        "]": true
    };
    var Quotes = {
        __proto__: null,
        '"': true,
        "'": true
    };

    var Builtins = {
        __proto__: null,
        "Object": true,
        "Function": true,
        "Array": true,
        "String": true,
        "Boolean": true,
        "Number": true,
        "Math": true,
        "Date": true,
        "RegExp": true,
        "JSON": true,
        "Error": true,
        "EvalError": true,
        "RangeError": true,
        "ReferenceError": true,
        "SyntaxError": true,
        "TypeError": true,
        "URIError": true,
        "setTimeout": true,
        "setInterval": true,
        "setImmediate": true,
        "eval": true,
        "ArrayBuffer": true,
        "DataView": true,
        "isNaN": true,
        "isFinite": true,
        "Int8Array": true,
        "Int16Array": true,
        "Int32Array": true,
        "Uint8Array": true,
        "Uint16Array": true,
        "Uint32Array": true,
        "Float32Array": true,
        "Float64Array": true,
        "Uint8ClampedArray": true,

        "escape": true,
        "unescape": true,
        "encodeURI": true,
        "decodeURI": true,
        "encodeURIComponent": true,
        "decodeURIComponent": true,
        "parseInt": true,
        "parseFloat": true,
        "Iterator": true,
        "StopIteration": true,
        "Proxy": true,
        "Map": true,
        "Set": true,
        "WeakMap": true,
        "WeakSet": true
    };
    var Punctuators = {
        __proto__: null,
        "=>": true,
        "...": true,
        ".": true,
        ",": true,
        "&": true,
        "&&": true,
        "&=": true,
        "|=": true,
        "|": true,
        "||": true,
        "!": true,
        "!!": true,
        "!=": true,
        "!==": true,
        "=": true,
        "==": true,
        "===": true,
        "{": true,
        "}": true,
        "(": true,
        ")": true,
        "[": true,
        "]": true,
        "<": true,
        ">": true,
        "<=": true,
        ">=": true,
        "<<": true,
        "<<=": true,
        ">>=": true,
        "<<<": true,
        ">>>=": true,
        ";": true,
        "::": true,
        ":=": true,
        ":": true,
        "+": true,
        "-": true,
        "*": true,
        "/": true,
        "+=": true,
        "-=": true,
        "*=": true,
        "/=": true,
        "%": true,
        "%=": true,
        "++": true,
        "--": true,
        "^": true,
        "^=": true,
        "?": true,
        "<|": true,
        "#": true,
        "~": true,
        "&lt;": true,
        "&gt;": true,
        "&amp;&amp;": true,
        "&amp": true
    };
    var WhiteSpaces = {
        __proto__: null,
        "\u0009": true,
        "\u000B": true,
        "\u000C": true,
        "\u0020": true,
        "\u00A0": true,
        "\uFEFF": true
    };
    var LineTerminators = {
        __proto__: null,
        "\u000A": true,
        "\u000D": true,
        "\u2028": true,
        "\u2029": true
    };
    var HexDigits = {
        __proto__: null,
        "0": true,
        "1": true,
        "2": true,
        "3": true,
        "4": true,
        "5": true,
        "6": true,
        "7": true,
        "8": true,
        "9": true,
        "a": true,
        "b": true,
        "c": true,
        "d": true,
        "e": true,
        "f": true,
        "A": true,
        "B": true,
        "C": true,
        "D": true,
        "E": true,
        "F": true
    };
    var BinaryDigits = {
        __proto__: null,
        "0": true,
        "1": true
    };
    var OctalDigits = {
        __proto__: null,
        "0": true,
        "1": true,
        "2": true,
        "3": true,
        "4": true,
        "5": true,
        "6": true,
        "7": true
    };
    var DecimalDigits = {
        __proto__: null,
        "0": true,
        "1": true,
        "2": true,
        "3": true,
        "4": true,
        "5": true,
        "6": true,
        "7": true,
        "8": true,
        "9": true
    };
    var NonZeroDigits = {
        __proto__: null,
        "1": true,
        "2": true,
        "3": true,
        "4": true,
        "5": true,
        "6": true,
        "7": true,
        "8": true,
        "9": true
    };
    var ExponentIndicator = {
        __proto__: null,
        "e": true,
        "E": true
    };
    var SignedInteger = {
        __proto__: null,
        "+": true,
        "-": true
    };
    var ParensSemicolonComma = {
        "{": true,
        "}": true,
        "(": true,
        ")": true,
        "[": true,
        "]": true,
        ";": true,
        ",": true,
        "?": true,
        "~": true
    };
    var NumericLiteralLetters = {
        __proto__: null,
        "x": true,
        "X": true,
        "b": true,
        "B": true,
        "O": true,
        "o": true
    };

    var SingleEscapeCharacter = {
        __proto__: null,
        "b": "\b",
        "t": "\t",
        "n": "\n",
        "v": "\v",
        "f": "\f",
        "r": "\r",
        "\\": "\\",
        "\"": "\"",
        "\'": "\'"
    };
    var IdentifierStart = {
        __proto__: null,
        "\\": true, // fuer schnelleren Vergleich mit escape sequence
        "$": true,
        "_": true,
        "A": true,
        "B": true,
        "C": true,
        "D": true,
        "E": true,
        "F": true,
        "G": true,
        "H": true,
        "I": true,
        "J": true,
        "K": true,
        "L": true,
        "M": true,
        "N": true,
        "O": true,
        "P": true,
        "Q": true,
        "R": true,
        "S": true,
        "T": true,
        "U": true,
        "V": true,
        "W": true,
        "X": true,
        "Y": true,
        "Z": true,
        "a": true,
        "b": true,
        "c": true,
        "d": true,
        "e": true,
        "f": true,
        "g": true,
        "h": true,
        "i": true,
        "j": true,
        "k": true,
        "l": true,
        "m": true,
        "n": true,
        "o": true,
        "p": true,
        "q": true,
        "r": true,
        "s": true,
        "t": true,
        "u": true,
        "v": true,
        "w": true,
        "x": true,
        "y": true,
        "z": true
    };
    var IdentifierPart = {
        __proto__: null,
        "$": true,
        "_": true,
        "A": true,
        "B": true,
        "C": true,
        "D": true,
        "E": true,
        "F": true,
        "G": true,
        "H": true,
        "I": true,
        "J": true,
        "K": true,
        "L": true,
        "M": true,
        "N": true,
        "O": true,
        "P": true,
        "Q": true,
        "R": true,
        "S": true,
        "T": true,
        "U": true,
        "V": true,
        "W": true,
        "X": true,
        "Y": true,
        "Z": true,
        "a": true,
        "b": true,
        "c": true,
        "d": true,
        "e": true,
        "f": true,
        "g": true,
        "h": true,
        "i": true,
        "j": true,
        "k": true,
        "l": true,
        "m": true,
        "n": true,
        "o": true,
        "p": true,
        "q": true,
        "r": true,
        "s": true,
        "t": true,
        "u": true,
        "v": true,
        "w": true,
        "x": true,
        "y": true,
        "z": true,
        "0": true,
        "1": true,
        "2": true,
        "3": true,
        "4": true,
        "5": true,
        "6": true,
        "7": true,
        "8": true,
        "9": true,
        /* ZWNJ, ZWJ */
        "\u200C": true,
        "\u200D": true
    };
    var Types = {
        __proto__: null,
        "null": true,
        "undefined": true,
        "boolean": true,
        "string": true,
        "number": true,
        "object": true,
        "symbol": true,
        "function": true,
        "reference": true
    };
    var SemicolonInsertionPoint = {
        __proto__: null,
        "PostFixExpression": true, // LHS[no LT]++ / bzw. nur definiert weil ich es mir merken wollte
        "ContinueStatement": true,
        "BreakStatement": true,
        "ReturnStatement": true,
        "ThrowStatement": true,
        "LineTerminator": true,
        "RightBracePunctuator": true
    };
    var ReservedWord = {
        __proto__: null,
        "Keyword": true,
        "FutureReservedWord": true,
        "BooleanLiteral": true,
        "NullLiteral": true
    };

    /** WARUM habe ich das ding nochmal geschrieben ***/
    var TypeOfToken = {
        __proto__: null,
        "\"use strict\"": "StringLiteral",
        "'use strict'": "StringLiteral",
        "\"use asm\"": "StringLiteral",
        "'use asm'": "StringLiteral",
        "{": "Punctuator",
        "(": "Punctuator",
        ")": "Punctuator",
        "[": "Punctuator",
        "]": "Punctuator",
        ".": "Punctuator",
        ";": "Punctuator",
        ",": "Punctuator",
        "<": "Punctuator",
        ">": "Punctuator",
        "<=": "Punctuator",
        ">=": "Punctuator",
        "==": "Punctuator",
        "!=": "Punctuator",
        "===": "Punctuator",
        "!==": "Punctuator",
        "+": "Punctuator",
        "-": "Punctuator",
        "*": "Punctuator",
        "%": "Punctuator",
        "++": "Punctuator",
        "--": "Punctuator",
        "<<": "Punctuator",
        ">>": "Punctuator",
        ">>>": "Punctuator",
        "&": "Punctuator",
        "|": "Punctuator",
        "^": "Punctuator",
        "!": "Punctuator",
        "~": "Punctuator",
        "&&": "Punctuator",
        "||": "Punctuator",
        "?": "Punctuator",
        ":": "Punctuator",
        "=": "Punctuator",
        "+=": "Punctuator",
        "-=": "Punctuator",
        "*=": "Punctuator",
        "%=": "Punctuator",
        "<<=": "Punctuator",
        ">>=": "Punctuator",
        ">>>=": "Punctuator",
        "&=": "Punctuator",
        "|=": "Punctuator",
        "^=": "Punctuator",
        "=>": "Punctuator",
        "}": "RightBracePunctuator",
        "/": "DivPunctuator",
        "/=": "DivPunctuator",
        "break": "Keyword",
        "case": "Keyword",
        "catch": "Keyword",
        "class": "Keyword",
        "continue": "Keyword",
        "const": "Keyword",
        "debugger": "Keyword",
        "default": "Keyword",
        "delete": "Keyword",
        "do": "Keyword",
        "else": "Keyword",
        "export": "Keyword",
        "finally": "Keyword",
        "for": "Keyword",
        "function": "Keyword",
        "if": "Keyword",
        "import": "Keyword",
        "in": "Keyword",
//        "of": "Keyword",
        "instanceof": "Keyword",
        "let": "Keyword",
        "new": "Keyword",
        "return": "Keyword",
        "super": "Keyword",
        "switch": "Keyword",
        "this": "Identifier",
        "throw": "Keyword",
        "try": "Keyword",
        "typeof": "Keyword",
        "var": "Keyword",
        "void": "Keyword",
        "while": "Keyword",
        "with": "Keyword",
        "enum": "Keyword",
        "extends": "Keyword",
        "implements": "Keyword",
        "interface": "Keyword",
        "package": "Keyword",
        "private": "Keyword",
        "protected": "Keyword",
        "public": "Keyword",
        "static": "Keyword",
        "yield": "Keyword",
        "null": "NullLiteral",
        "true": "BooleanLiteral",
        "false": "BooleanLiteral",
        "NaN": "NumericLiteral",
        "Infinity": "NumericLiteral",
        "undefined": "Identifier",
        //"async": "Keyword",
        //"await": "Keyword",
    };
    var Keywords = {
        __proto__: null,
        //"async":true,
        "case": true,
        "catch": true,
        "class": true,
        "continue": true,
        "const": true,
        "debugger": true,
        "default": true,
        "delete": true,
        "do": true,
        "else": true,
        "enum": true,
        "export": true,
        "extends": true,
        "finally": true,
        "for": true,
        "function": true,
        "if": true,
        "import": true,
        "in": true,
        "instanceof": true,
        "implements": true,
        "interface": true,
        "let": true,
        "new": true,
        "of": true,
        "package": true,
        "private": true,
        "protected": true,
        "public": true,
        "return": true,
        "static": true,
        "super": true,
        "switch": true,
        "this": true,
        "throw": true,
        "try": true,
        "typeof": true,
        "var": true,
        "void": true,
        "while": true,
        "with": true
        //"yield": true
    };

    var IsAnyLiteral = {
        __proto__: null,
        "NullLiteral": true,
        "NumericLiteral": true,
        "BooleanLiteral": true,
        "StringLiteral": true,
        "TemplateLiteral": true,
        "RegularExpressionLiteral": true,
        "Literal":true // with escape sequence.
    };

    var PunctToExprName = {
        __proto__: null,
        "delete": "UnaryExpression",
        "typeof": "UnaryExpression",
        "void": "UnaryExpression",
        "--": "UnaryExpression",
        "++": "UnaryExpression",
        "!!": "UnaryExpression",
        // + und - fehlen hier
        "!": "UnaryExpression",
        "*": "MultiplicativeExpression",
        "/": "MultiplicativeExpression",
        "%": "MultiplicativeExpression",
        "+": "AdditiveExpression",
        "-": "AdditiveExpression",
        "<<": "ShiftExpression",
        ">>": "ShiftExpression",
        "<<<": "ShiftExpression",
        "<": "RelationalExpression",
        ">": "RelationalExpression",
        "<=": "RelationalExpression",
        ">=": "RelationalExpression",
        "in": "RelationalExpression",
        "of": "RelationalExpression",
        "instanceof": "RelationalExpression",
        "=": "AssignmentExpression",
        "==": "EqualityExpression",
        "!=": "EqualityExpression",
        "===": "EqualityExpression",
        "!==": "EqualityExpression",
        "is": "EqualityExpression",
        "isnt": "EqualityExpression",
        "&": "BitwiseANDExpression",
        "|": "BitwiseORExpression",
        "^": "BitwiseXORExpression",
        "&&": "LogicalANDExpression",
        "||": "LogicalORExpression",
        "?": "ConditionalExpression"
    };
    var BinaryOperators = {
        __proto__: null,
        "==": true,
        "!=": true,
        "===": true,
        "!==": true,
        "<": true,
        "<=": true,
        ">": true,
        ">=": true,
        "<<": true,

        ">>": true,
        ">>>": true,

        "+": true,
        "-": true,
        "*": true,
        "/": true,
        "%": true,
        "&&": true,
        "||": true,
        "&": true,
        "|": true,
        "^": true,
        "in": true,
        "of": true,
        "instanceof": true
    };
    var AssignmentOperators = {
        __proto__: null,
        "=": true,
        "%=": true,
        "*=": true,
        "/=": true,
        "+=": true,
        "-=": true,
        "<<=": true,
        ">>=": true,
        ">>>=": true,
        "&=": true,
        "^=": true,
        "|=": true,
    };
    var UnaryOperators = {
        __proto__: null,
        "-": true,
        "+": true,
        "~": true,
        "!": true,
        "!!": true,
        "typeof": true,
        "void": true,
        "delete": true
    };
    var UpdateOperators = {
        __proto__: null,
        "++": true,
        "--": true
    };
    var EqualityOperators = {
        "==": true,
        "!=": true,
        "===": true,
        "!==": true,
        __proto__: null
    };
    var RelationalOperators = {
        "<": true,
        ">": true,
        "<=": true,
        ">=": true,
        "instanceof": true,
        __proto__: null
    };
    var LogicalOperators = {
        "&&": true,
        "||": true,
        __proto__: null
    };
    var BitwiseOperators = {
        __proto__: null,
        "~": true,
        "^": true,
        "|": true,
        "&": true
    };
    var InOperator = {
        __proto__: null,
        "in": true,
        "of": true
    };
    var OpenParens = {
        __proto__: null,
        "(": true,
        "{": true,
        "[": true
    };

    var ExprEndOfs = Object.create(null);
    ExprEndOfs[")"] = true;
    ExprEndOfs["]"] = true;
    ExprEndOfs["}"] = true;
    ExprEndOfs[":"] = true;
    ExprEndOfs[";"] = true;
    ExprEndOfs["case"] = true;
    ExprEndOfs["default"] = true;
    ExprEndOfs["else"] = true;
    ExprEndOfs["while"] = true;
    /*
     __proto__: null,
     ")": true,
     "}": true,
     "]": true,
     ":": true,
     ";": true,
     //",": true,
     "case": true,
     "default": true

     };
     */
    var Separators = {
        ";": true,
        ",": true
    };
    Separators.prototype = Object.create(LineTerminators);

    var OperatorPrecedence = {
        // higher is calculated first

        __proto__: null,

        ";": 0,
        ",": 1,
        "=": 10,
        "+=": 10,
        "-=": 10,
        "*=": 10,
        "/=": 10,
        "%=": 10,
        "^=": 10,
        "<<=": 10,
        ">>=": 10,
        ">>>=": 10,

        "&=": 10,
        "|=": 10,
        "?": 20,
        "|": 20,
        "&": 20,
        "<<": 20,
        ">>": 20,
        ">>>": 20,

        "^": 20,


        "||": 30,
        "&&": 30,


        "===": 40,
        "==": 40,
        "!==": 40,
        "!=": 40,
        "<": 40,
        ">": 40,
        "<=": 40,
        ">=": 40,
        "instanceof": 40,
        "in": 40,
        "of": 40,

        "+": 50,
        "-": 50,
        
        "*": 60,
        "/": 60,
        "%": 60,



        ".": 80,
        "[": 80,
        "(": 80

    };
    
    exports.UnaryOperatorPrecedence = UnaryOperatorPrecedence;
    var UnaryOperatorPrecedence = {
	__proto__: null,
	    "-":70,   
        "+":70,   
        "!!": 70,
        "~": 70,
        "!":70,
        "++":70,
        "--":70,
        "delete":70,
        "void":70,
        "typeof":70
    };

    var RegExpFlags = {
        __proto__: null,
        "m": true,
        "g": true,
        "y": true,
        "i": true,
        "u": true
    };
    var RegExpNoneOfs = {
        __proto__: null,
        "*": true,
        "/": true
    };

    /* 1. Versuch */
    var NotBeforeRegExp = {
        __proto__: null,
        "Identifier": true,
        "NumericLiteral": true,
        "BooleanLiteral": true,
        "StringLiteral": true,
        "RegularExpressionLiteral": true
    };
    var RegExpNoneOfsVal = {
	__proto__:null,
	"]": true,
	")": true
    };
    var UnicodeIDStart = {
        __proto__: null
    };
    var UnicodeIDContinue = {
        __proto__: null
    };
    var IsIteration = {
        "ForStatement": true,
        "ForInStatement": true,
        "ForOfStatement": true,
        "WhileStatement": true,
        "DoWhileStatement": true
    };
    var DeclarationKind = {
        "var": true,
        "let": true,
        "const": true
    };

    var NotExpressionStatement = {
        __proto__: null,
        "{": true,
        "function": true,
        "class": true
    };
    var AbruptCompletion = {
        "break": true,
        "continue": true,
        "throw": true,
        "return": true
    };
    var Integrities = {
        "nonextensible": true,
        "sealed": true,
        "frozen": true
    };
    var IterationStatement = {
        "ForStatement": true,
        "WhileStatement": true,
        "DoWhileStatement": true,
        "ForInStatement": true,
        "ForOfStatement": true
    };
    var ControlStatement = {
        "IfStatement": true,
        "SwitchStatement": true
    };
    var isDirective = {
        __proto__:null,
        "\"use strict\"":true,
        "\'use strict\'":true,
        "\"use asm\"":true,
        "\'use asm\'":true
    };
    var isStrictDirective = {
        __proto__:null,
        "\"use strict\"":true,
        "\'use strict\'":true
    };
    var isAsmDirective = {
        __proto__:null,
        "\"use asm\"":true,
        "\'use asm\'":true
    };
    var AllowedLastChars = {
        __proto__:true,
        "}": true,
        ";": true,
        ":": true,
        "--": true,
        "++": true
    };
    var OneOfThesePunctuators = {
        __proto__:true,
        ")": true,
        "]": true,
        "--": true,
        "++": true,
        "/": true
    };
    var PunctOrLT = {
        __proto__:null,
        "Punctuator": true,
        "LineTerminator": true
    };

    /**
     * used in lib/compile/asm-runtime and asm-compiler to map the operator which are plain text
     *
     * @type {{>>: number, >=: number, >>>: number, instanceof: number, in: number, of: number, =>: number, ...: number, .: number, ,: number, &: number, &&: number, &=: number, |=: number, |: number, ||: number, !: number, !!: number, !=: number, !==: number, =: number, ==: number, ===: number, {: number, }: number, (: number, ): number, [: number, ]: number, <: number, >: number, <=: number, <<: number, <<=: number, >>=: number, <<<: number, >>>=: number, ;: number, ::: number, :=: number, :: number, +: number, -: number, *: number, /: number, +=: number, -=: number, *=: number, /=: number, %: number, %=: number, ++: number, --: number, ^: number, ^=: number, ?: number, <|: number, #: number, ~: number}}
     */
    var codeForOperator = {
        ">>":17,
        ">=": 18,
        ">>>":19,
        "instanceof":20,
        "in":21,
        "of":22,
        "=>": 23,
        "...": 24,
        ".": 25,
        ",": 26,
        "&": 27,
        "&&": 28,
        "&=": 29,
        "|=": 30,
        "|": 31,
        "||": 32,
        "!": 33,
        "!!": 34,
        "!=": 35,
        "!==": 36,
        "=": 37,
        "==": 38,
        "===": 39,
        "{": 40,
        "}": 41,
        "(": 42,
        ")": 43,
        "[": 44,
        "]": 45,
        "<": 46,
        ">": 47,
        "<=": 48,
        "<<": 51,
        "<<=": 52,
        ">>=": 53,
        "<<<": 54,
        ">>>=": 55,
        ";": 56,
        "::": 57,
        ":=": 58,
        ":": 59,
        "+": 60,
        "-": 61,
        "*": 62,
        "/": 63,
        "+=": 64,
        "-=": 65,
        "*=": 66,
        "/=": 67,
        "%": 68,
        "%=":  69,
        "++": 70,
        "--": 71,
        "^": 72,
        "^=": 73,
        "?": 74,
        "<|": 75,
        "#": 76,
        "~": 77
    };
    var operatorForCode = {
        17:">>",
        18:">=",
        19:">>>",
        20:"instanceof",
        21:"in",
        22:"of",
         23:"=>",
         24:"...",
         25:".",
         26:",",
         27:"&",
         28:"&&",
         29:"&=",
         30:"|=",
         31:"|",
         32:"||",
         33:"!",
         34:"!!",
         35:"!=",
         36:"!==",
         37:"=",
         38:"==",
         39:"===",
         40:"{",
         41:"}",
         42:"(",
         43:")",
         44:"[",
         45:"]",
         46:"<",
         47:">",
         48:"<=",
         51:"<<",
         52:"<<=",
         53:">>=",
         54:"<<<",
         55:">>>=",
         56:";",
         57:"::",
         58:":=",
         59:":",
         60:"+",
         61:"-",
         62:"*",
         63:"/",
         64:"+=",
         65:"-=",
         66:"*=",
         67:"/=",
         68:"%",
          69:"%=",
         70:"++",
         71:"--",
         72:"^",
         73:"^=",
         74:"?",
         75:"<|",
         76:"#",
        77:"~"
    };

    /**
     * used in the VM to translate the operators
     * @type {{0: string, 1: string, 2: string, 3: string, 4: string, 5: string, 6: string, 7: string, 8: string, 9: string}}
     */
    var unaryOperatorFromCode = {
        0: "void",
        1: "delete",
        2: "typeof",
        3: "!!",
        4: "+",
        5: "-",
        6: "~",
        7: "!",
        8: "++",
        9: "--"
    };

    var unaryOperatorFromString = {
        "void": 0,
        "delete": 1,
        "typeof": 2,
        "!!": 3,
        "+": 4,
        "-": 5,
        "~": 6,
        "!": 7,
        "++":8,
        "--":9
    };


    var propDefKinds = {
        "init": 1,
        "method": 2,
        "computed": 3
    };
    var propDefCodes = {
        1: "init",
        2: "method",
        3: "computed"
    };


    exports.isDirective = isDirective;
    exports.isStrictDirective = isStrictDirective;
    exports.isAsmDirective = isAsmDirective;
    exports.FinishStatementList = FinishStatementList;
    exports.FinishSwitchStatementList = FinishSwitchStatementList;    
    exports.varKinds = varKinds;
    exports.StatementParsers = StatementParsers;
    exports.PrimaryExpressionByValue = PrimaryExpressionByValue;
    exports.PrimaryExpressionByType = PrimaryExpressionByType;
    exports.SkipableToken = SkipableToken;
    exports.SkipableTokenNoLT = SkipableTokenNoLT;
    exports.InOrOfInsOf = InOrOfInsOf;
    exports.InOrOf = InOrOf;
    exports.BindingIdentifiers = BindingIdentifiers;
    exports.propKeys = propKeys;
    exports.ExprNoneOfs = ExprNoneOfs;
    exports.MethodKeyByType = MethodKeyByType;
    exports.MethodKeyByValue = MethodKeyByValue;
    exports.StartBinding = StartBinding;
    exports.uriAlpha = uriAlpha;
    exports.uriMark = uriMark;
    exports.uriReserved = uriReserved;
    exports.NonPatternCharacter = NonPatternCharacter;
    exports.CharacterClassEscape = CharacterClassEscape;
    exports.ControlLetter = ControlLetter;
    exports.ControlEscape = ControlEscape;
    exports.DOM = DOM;
    exports.HTML5Objects = HTML5Objects;
    exports.NodeJSObjects = NodeJSObjects;
    exports.Builtins = Builtins;
    exports.Comment = Comment;
    exports.Parentheses = Parentheses;
    exports.Quotes = Quotes;
    exports.Punctuators = Punctuators;
    exports.WhiteSpaces = WhiteSpaces;
    exports.LineTerminators = LineTerminators;
    exports.HexDigits = HexDigits;
    exports.NonZeroDigits = NonZeroDigits;
    exports.BinaryDigits = BinaryDigits;
    exports.OctalDigits = OctalDigits;
    exports.DecimalDigits = DecimalDigits;
    exports.ExponentIndicator = ExponentIndicator;
    exports.SignedInteger = SignedInteger;
    exports.ParensSemicolonComma = ParensSemicolonComma;
    exports.NumericLiteralLetters = NumericLiteralLetters;
    exports.SingleEscapeCharacter = SingleEscapeCharacter;
    exports.IdentifierStart = IdentifierStart;
    exports.IdentifierPart = IdentifierPart;
    exports.Types = Types;
    exports.SemicolonInsertionPoint = SemicolonInsertionPoint;
    exports.ReservedWord = ReservedWord;
    exports.TypeOfToken = TypeOfToken;
    exports.Keywords = Keywords;
    exports.IsAnyLiteral = IsAnyLiteral;
    exports.PunctToExprName = PunctToExprName;
    exports.BinaryOperators = BinaryOperators;
    exports.AssignmentOperators = AssignmentOperators;
    exports.RelationalOperators = RelationalOperators;
    exports.UnaryOperators = UnaryOperators;
    exports.UpdateOperators = UpdateOperators;
    exports.EqualityOperators = EqualityOperators;
    exports.RelationalOperators = RelationalOperators;
    exports.LogicalOperators = LogicalOperators;
    exports.BitwiseOperators = BitwiseOperators;
    exports.InOperator = InOperator;
    exports.OpenParens = OpenParens;
    exports.ExprEndOfs = ExprEndOfs;
    exports.Separators = Separators;
    exports.OperatorPrecedence = OperatorPrecedence;
    exports.RegExpFlags = RegExpFlags;
    exports.RegExpNoneOfs = RegExpNoneOfs;
    exports.RegExpNoneOfsVal = RegExpNoneOfsVal;
    exports.NotBeforeRegExp = NotBeforeRegExp;
    exports.UnicodeIDStart = UnicodeIDStart;
    exports.UnicodeIDContinue = UnicodeIDContinue;
    exports.IsIteration = IsIteration;
    exports.NotExpressionStatement = NotExpressionStatement;
    exports.DeclarationKind = DeclarationKind;
    exports.LPAREN = LPAREN;
    exports.RPAREN = RPAREN;
    exports.LPARENOF = LPARENOF;
    exports.RPARENOF = RPAREN;
    exports.typedArrayElementSize = typedArrayElementSize;
    exports.TypedArrayElementType = TypedArrayElementType;
    exports.BuildingPatterns = BuildingPatterns;
    exports.ForbiddenArgumentsInStrict = ForbiddenArgumentsInStrict;
    exports.ReservedWordsInStrictMode = ReservedWordsInStrictMode;
    exports.IsTemplateToken = IsTemplateToken;
    exports.OneOfThesePunctuators = OneOfThesePunctuators;
    exports.AllowedLastChars = AllowedLastChars;
    exports.PunctOrLT = PunctOrLT;
    exports.StartOfThreeFourPunctuators = StartOfThreeFourPunctuators;


    exports.codeForOperator = codeForOperator;
    exports.operatorForCode = operatorForCode;
    exports.unaryOperatorFromCode = unaryOperatorFromCode;
    exports.unaryOperatorFromString = unaryOperatorFromString;
    exports.propDefKinds = propDefKinds;
    exports.propDefCodes = propDefCodes;

    return exports;

    /*
        need for the node.type replacements

        have to look into the ide if i can
        replace and convert to upper on e.g. regexp,
        or if i have to do it manually
        ctrl-shift-arrow mark + 2x strg-shift-u sucks

    exports.JSONTEXT = "JSONText";
    exports.JSONVALUE = "JSONValue";
    exports.JSONSTRING = "JSONString";
    exports.JSONNUMBER = "JSONNumber";
    exports.JSONFRACTION = "JSONFraction";
    exports.JSONNULLLITERAL = "JSONNullLiteral";
    exports.JSONBOOLEANLITERAL = "JSONBooleanLiteral";
    exports.JSONARRAY = "JSONArray";
    exports.JSONELEMENTLIST = "JSONElementList";
    exports.JSONOBJECT = "JSONObject";
    exports.JSONMember = "JSONMember";
    exports.JSONMemberList = "JSONMemberList";
    exports.ConditionalExpressionNoIn = "ConditionalExpressionNoIn";
    exports.ConditionalExpression = "ConditionalExpression";
    exports.LeftHandSideExpression = "LeftHandSideExpression";
    exports.ExpressionStatement = "ExpressionStatement";
    exports.Expression = "Expression";
    exports.PrimaryExpression = "PrimaryExpression";
    exports.PostfixExpression = "PostfixExpression";
    exports.UnaryExpression = "UnaryExpression";
    exports.YieldExpression = "YieldExpression";
    exports.YieldStatement = "YieldStatement";
    exports.DefaultAsIdentifier = "DefaultAsIdentifier";
    exports.YieldAsIdentifier = "YieldAsIdentifier";
    exports.AssignmentExpression = "AssignmentExpression";
    exports.SuperExpression = "SuperExpression";
    exports.ThisExpression = "ThisExpression";
    exports.Initializer = "Initializer";
    exports.BindingElementList = "BindingElementList";
    exports.BindingPattern = "BindingPattern";
    exports.VariableDeclaration = "VariableDeclaration";
    exports.VariableDeclarationList = "VariableDeclarationList";
    exports.VariableStatement = "VariableStatement";
    exports.Expression = "Expression";
    exports.ExpressionNoIn = "ExpressionNoIn";
    exports.AssignmentExpressionNoIn = "AssignmentExpressionNoIn";
    exports.ParenthesizedExpression = "ParenthesizedExpression";
    exports.ParenthesizedExpressionNode = "ParenthesizedExpressionNode";
    exports.ArrowParameterList = "ArrowParameterList";
    exports.CoverParenthesisedExpressionAndArrowParameterList = "CoverParenthesisedExpressionAndArrowParameterList";
    exports.ConciseBody = "ConciseBody";
    exports.CoverParenthesizedExpression = "CoverParenthesizedExpression";
    exports.Literal = "Literal";
    exports.Identifier = "Identifier";
    exports.ClassExpression = "ClassExpression";
    exports.TemplateLiteral = "TemplateLiteral";
    exports.Elision = "Elision";
    exports.ElementList = "ElementList";
    exports.ArrayExpression = "ArrayExpression";
    exports.StrictFormalParameters = "StrictFormalParameters";
    exports.PropertyDefinitionList = "PropertyDefinitionList";
    exports.ComputedPropertyName = "ComputedPropertyName";
    exports.PropertyKey = "PropertyKey";
    exports.ObjectExpression = "ObjectExpression";
    exports.MemberExpression = "MemberExpression";
    exports.Arguments = "Arguments";
    exports.CallExpression = "CallExpression";
    exports.NewExpression = "NewExpression";
    exports.ComprehensionForList = "ComprehensionForList";
    exports.ComprehensionFilters = "ComprehensionFilters";
    exports.ArrayComprehension = "ArrayComprehension";
    exports.GeneratorComprehension = "GeneratorComprehension";
    exports.ExpressionStatement = "ExpressionStatement";
    exports.SequenceExpression = "SequenceExpression";
    exports.GeneratorBody = "GeneratorBody";
    exports.FunctionBody = "FunctionBody";
    exports.MethodDefinition = "MethodDefinition";
    exports.ClassDeclaration = "ClassDeclaration";
    exports.RestParameter = "RestParameter";
    exports.SpreadExpression = "SpreadExpression";
    exports.DefaultParameter = "DefaultParameter";
    exports.FormalParameterList = "FormalParameterList";
    exports.FunctionExpression = "FunctionExpression";
    exports.FunctionDeclaration = "FunctionDeclaration";
    exports.BlockStatement = "BlockStatement";
    exports.ContinueStatement = "ContinueStatement";
    exports.BreakStatement = "BreakStatement";
    exports.ReturnStatement = "ReturnStatement";
    exports.WithStatement = "WithStatement";
    exports.ThrowStatement = "ThrowStatement";
    exports.LabelledStatement = "LabelledStatement";
    exports.TryStatement = "TryStatement";
    exports.Catch = "Catch";
    exports.Finally = "Finally";
    exports.DebuggerStatement = "DebuggerStatement";
    exports.ModuleDeclaration = "ModuleDeclaration";
    exports.ModuleSpecifier = "ModuleSpecifier";
    exports.ModuleBody = "ModuleBody";
    exports.FromClause = "FromClause";
    exports.ImportClause = "ImportClause";
    exports.NamedImports = "NamedImports";
    exports.ImportStatement = "ImportStatement";
    exports.ExportsClause = "ExportsClause";
    exports.DeclarationDefault = "DeclarationDefault";
    exports.ExportStatement = "ExportStatement";
    exports.StatementList = "StatementList";
    exports.SwitchStatementList = "SwitchStatementList";
    exports.Statement = "Statement";
    exports.IterationStatement = "IterationStatement";
    exports.ForStatement = "ForStatement";
    exports.ForDeclaration = "ForDeclaration";
    exports.ForBinding = "ForBinding";
    exports.VARIABLESTATEMENTNOIN = "VariableStatementNoIn";
    exports.SOURCEELEMENTS = "SourceElements";
    exports.EMPTYSTATEMENT = "EmptyStatement";
    exports.DIRECTIVEPROLOGUE = "DirectivePrologue";
    exports.MODULE = "Module";
    exports.PROGRAM = "Program";
    exports.REGULAREXPRESSIONLITERAL = "RegularExpressionLiteral";
    exports.FORSTATEMENT = "ForStatement";
    exports.WHILESTATEMENT = "WhileStatement";
    exports.IFSTATEMENT = "IfStatement";
    exports.DOWHILESTATEMENT = "DoWhileStatement";
    exports.SWITCHSTATEMENT = "SwitchStatement";
    exports.DEFAULTCASE = "DefaultCase";
    exports.SWITCHCASE = "SwitchCase";
    */
});

/**
 
 */
define("symboltable", function (require, exports, module) {

	function Environment (outer) {
        if (!(this instanceof Environment)) return new Environment(outer);
		var env = this;
		env.bindings = Object.create(null);
		env.names = Object.create(null);
		env.outer = outer || null;
		return env;
 	}
	Environment.prototype = {
        putVar: function (decl, type) {
            var name = getName(decl);
            var thisName = this.names[name];            
            this.bindings[name] = decl;
            this.names[name] = type || true;
        },
		put: function (decl, type) {
            var name = getName(decl);
			var thisName = this.names[name];
			if ((thisName === true && type != "static") ||
                (thisName === "static" && type != true) ||
			    (thisName === "get" && type !== "set") ||
			    (thisName === "set" && type !== "get")) { 			    
				throw new SyntaxError("Duplicate identifier in environment scope: "+name);
			}
			this.bindings[name] = decl;
			this.names[name] = type || true;
		}
	};

    function getName(decl) {
        if (typeof decl.id === "object") return decl.id.name;
        if (typeof decl.id === "string") return decl.name;
    }

	function Scope (outer) {
        if (!(this instanceof Scope)) return new Scope(outer);
		var scope = this;
		scope.varEnv = new Environment(scope.varEnv);
		scope.lexEnv = scope.varEnv;
		scope.contains = Object.create(null);
		scope.outer = outer || null;		
		return scope;		
	}
    Scope.prototype = Object.create(null);

    function SymbolTable() {
        if (!(this instanceof SymbolTable)) return new SymbolTable();
        this.scope = new Scope(this.Scope);
    }
    SymbolTable.prototype = {
    	newScope: function () {
    		this.scope = new Scope(this.scope);
    	},
    	oldScope: function () {
    		if (this.scope)
    		this.scope = this.scope.outer;
    	},    	
    	newBlock: function () {
    		this.scope.lexEnv = new Environment(this.scope.lexEnv);
    	},
    	oldBlock: function () {
            if (this.scope)
    		this.scope.lexEnv = this.scope.lexEnv.outer;
    	},
    	putVar: function (decl, type) {
    		return this.scope.varEnv.putVar(decl, type);
    	},
    	putLex: function (decl, type) {
    		return this.scope.lexEnv.put(decl, type);
    	},
        hasVar: function (name) {
           return this.scope.varEnv.names[name] === true;
        },
        hasLex: function (name) {
            return Object.hasOwnProperty.call(this.scope.lexEnv.names, name);
        },
        varNames: function () {
            return getList.call(this, this.scope.varEnv.names);
        },
        lexNames: function () {
            return getList.call(this, this.scope.lexEnv.names);
        },
        varDecls: function () {
            return getList.call(this, this.scope.varEnv.bindings);
        },
        lexDecls: function () {
            return getList.call(this, this.scope.lexEnv.bindings);
        }
    };
    function getList(names) {
        var list = [];
        for (var name in names) {
            list.push(name);
        }
        return list;
    }
    return module.exports = {
        SymbolTable: SymbolTable,
        Scope: Scope,
        Environment: Environment
    };

});
define("slower-static-semantics", function (require, exports) {
    "use strict";
    var debugmode = false;
    var hasConsole = typeof console === "object" && console && typeof console.log === "function";
    var isStrictDirective = {
        "'use strict'": true,
        '"use strict"': true
    };
    var IsIteration = {
        "ForStatement": true,
        "ForInStatement": true,
        "ForOfStatement": true,
        "WhileStatement": true,
        "DoWhileStatement": true
    };
    var BreakableStatement = {
        "BreakStatement":true,
        "ContinueStatement":true,
        "ThrowStatement":true
    };
    var IterationStatement = {
        "ForStatement": true,
        "WhileStatement": true,
        "DoWhileStatement": true,
        "ForInStatement": true,
        "ForOfStatement": true
    };
    var MVHexDecimal = {
        __proto__: null,
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15
    };
    var LetOrConst = {
        __proto__: null,
        "let": true,
        "const": true
    };
    var isComplexParameter = {
        "RestParameter": true,
        "ObjectPattern": true,
        "ArrayPattern": true,
        "Identifier": false
    };
    function debug() {
        if (debugmode && hasConsole) console.log.apply(console, arguments);
    }
    function debugdir() {
        if (debugmode && hasConsole) console.dir.apply(console, arguments);
    }
    function UTF16Encode(cp) {
        Assert(0 <= cp <= 0x10FFFF, "utf16encode: cp has to be beetween 0 and 0x10FFFF");
        if (cp <= 65535) return cp;
        var cu1 = Math.floor((cp - 65536) % 1024) + 55296;
        var cu2 = ((cp - 65536) % 1024) + 56320;
        return [cu1, cu2];
    }
    function UTF16Decode(lead, trail) {
        Assert(0xD800 <= lead <= 0xD8FF, "utf16decode: lead has to be beetween 0xD800 and 0xD8FF");
        Assert(0xDC00 <= trail <= 0xDFFF, "utf16decode: trail has to be beetween 0xDC00 and 0xDFFF");
        var cp = (lead - 55296) * 1024 + (trail - 564320);
        return cp;
    }
    function TailPosition(node, nonTerminal) {
        // Assert(nonTerminal is a parsed grammar production)
    }
    function HasProductionInTailPosition(node, nonTerminal) {
        if (Array.isArray(node)) {
            for (var i = 0, j = node.length; i < j; i++) {
                if (HasProductionInTailPosition(node[i], nonTerminal)) return true;
            }
            return false;
        } else if (node) {
            if (node.type === "ReturnStatement" && node.argument === nonTerminal) return true;
        }
    }
    function IsAnonymousFunctionDefinition(node) {
        var type = node.type;
        var id = node.id;
        var expr = node.expression;
        if (!id) {
            if ((expr && (type === "FunctionDeclaration" || type === "GeneratorDeclaration")) || (type === "FunctionExpression" || type === "GeneratorExpression")) {
                return true;
            }
        }
        return false;
    }
    function IsIdentifierRef(node) {
        var type = node.type;
        if (type === "Identifier") return true;
        else if (type === "RestParameter") return true;
        else if (type === "DefaultParameter") return true;
        return false;
    }
    function ImportEntriesForModule(module, importClause) {

    }
    function ExportEntriesForModule(module, exportClause) {

    }
    function UnknownExportEntries(node, list) {
        var nodetype = node.type;
        list = list || [];
        if (nodetype === "ModuleDeclaration") {
            var body = node.body;
            var decl;
            for (var i = 0, j = body.length; i < j; i++) {
                if (decl = body[i]) UnknownExportEntries(decl, list);
            }
        } else if (nodetype === "ExportDeclaration") {
            list = list.concat(BoundNames(node.exports));
        }
        return list;
    }
    function KnownExportEntries(node) {
        var nodetype = node.type;
        list = list || [];
        if (nodetype === "ModuleDeclaration") {
            var body = node.body;
            var decl;
            for (var i = 0, j = body.length; i < j; i++) {
                if (decl = body[i]) KnownExportEntries(decl, list);
            }
        } else if (nodetype === "ExportDeclaration") {

        }
        return list;
    }
    function ExportedBindings(node) {}
    function ExportedEntries(node) {}
    function ImportedBindings(node) {}
    function ImportedEntries(node) {}
    function ModuleRequests(node) {}
    function ImportedNames(node) {}
    function ExportedNames(node) {}

    function IsIdentifier(obj) {
        return obj.type == "Identifier";
    }
    function IsFunctionDeclaration(node) {
        return node.type === "FunctionDeclaration";
    }
    function IsFunctionExpression(node) {
        var type = node.type;
        return (type === "FunctionDeclaration" && node.expression) || type === "FunctionExpression";
    }
    function IsGeneratorDeclaration(node) {
        var type = node.type;
        return (type === "FunctionDeclaration" && node.generator) || type === "GeneratorDeclaration";
    }
    function IsGeneratorExpression(node) {
        var type = node.type;
        return (type === "FunctionDeclaration" && node.expression && node.generator) || type === "GeneratorExpression";
    }
    function IsVarDeclaration(node) {
        return node.kind === "var" && node.type === "VariableDeclaration";

    }
    function IsStrict(node) {

        if (!Array.isArray(node)) {
            if (node) {
                var type = node.type;
                if (node.strict) return true;
                else if (type === "Directive" && isStrictDirective[node.value]) return true;
                else if (type === "ModuleDeclaration") return true;
                else if (type === "GeneratorDeclaration") return true;
                else if (type === "ClassDeclaration") return true;
            }
        } else if (node) {

            var i = 0;
            var n;
            while ((n = node[i]) && n.type === "Directive") {
                i++;
                if (isStrictDirective[node.value]) return true;
            }
        }
        return false;
    }
    function Contains(R, S) {

        var contains = false;
        var body, node, type;

        if (typeof R !== "object") return false;

        if (!Array.isArray(S)) S = [S];
        if (Array.isArray(R)) body = R;
        else if (R.body) body = R.body;

        if (Array.isArray(body)) {

            for (var i = 0, j = body.length; i < j; i++) {
                node = body[i];
                type = node.type;
                if (type === "ClassDeclaration") continue;
                if (type === "FunctionDeclaration") continue;
                if (type === "GeneratorDeclaration") continue;

                if (IsIteration[type] && Contains(node, S)) {
                    contains = true;
                    return contains;
                }

                for (var k = 0, l = S.length; k < l; k++) {
                    if (type === S[k]) {
                        contains = true;
                        return contains;
                    }
                }

            }
        }
        return contains;
    }
    function BoundNames(list, names) {
        var item;
        names = names || [];
        var name;
        var node;
        var type;


        if (typeof list === "string") {
            names.push(list);
            //debug("BoundNames: " + names.join(","));
            return names;

        } else if (!Array.isArray(list)) {

            // BoundNames einzeln
            if (node = list) {

                type = node.type;

                if (type === "ArrayPattern" || type == "ObjectPattern") {
                    names = BoundNames(node.elements, names);
                } else if (type === "ForDeclaration") names = BoundNames(node.id, names);
                else if (type === "ExportStatement") names = BoundNames(node.exports, names);


                /*
                 alle nach id.name (identifier node) transformieren !!!

                 */

                else if (type === "FunctionDeclaration")names.push(node.id);
                else if (type === "VariableDeclarator") names.push(node.id.name);

                else if (type === "GeneratorDeclaration") names.push(node.id);
                else if (type === "Identifier") names.push(node.name);
                else if (type === "DefaultParameter") names.push(node.id);
                else if (type === "RestParameter") names.push(node.id);

            }
            //debug("BoundNames: " + names.join(","));
            return names;

        } else {

            // BoundNames Formals oder andere Listen.
            var name;
            for (var i = 0, j = list.length; i < j; i++) {
                if (node = list[i]) {
                    type = node.type;
                    if (type === "ArrayPattern" || type == "ObjectPattern") {
                        names = BoundNames(node.elements, names);
                    } else if (type === "Identifier") {
                        name = node.name;
                        names.push(name);
                    } else if (type === "BindingElement") {
                        name = node.target.name || node.target.value;
                        names.push(name);
                    } else if (type === "DefaultParameter") {
                        name = node.id;
                        names.push(name);
                    } else if (type === "RestParameter") {
                        name = node.id;
                        names.push(name);
                    }
                }
            }

            //debug("BoundNames: " + names.join(","));
            return names;

        }
    }
    function VarDeclaredNames(body, names) {

        var node, decl, i, j, k, l;
        if (!names) names = [];
        if (!body) return names;
        for (i = 0, j = body.length; i < j; i++) {

            if (node = body[i]) {

                var type = node.type;
                if (type === "VariableDeclaration" && node.kind === "var") {
                    var decls = node.declarations;

                    for (k = 0, l = decls.length; k < l; k++) {
                        if (decl = decls[k]) {
                            names = BoundNames(decl, names);
                        }
                    }
                } else if (type === "BlockStatement") {
                    names = VarDeclaredNames(node.body, names);
                } else if (type === "FunctionDeclaration" && !node.expression && !node.expression) {
                    names.push(node.id);
                } else if (type === "IfStatement") {
                    names = VarDeclaredNames(node.consequent, names);
                    names = VarDeclaredNames(node.alternate, names);
	            } else if (type === "WhileStatement") {
                    VarDeclaredNames(node.body, names);
                } else if (type === "DoWhileStatement") {
                    VarDeclaredNames(node.body, names);
                } else if (type === "TryStatement") {
                    VarDeclaredNames(node.guard, names);
                } else if (type === "CatchClause") {
                    VarDeclaredNames(node.block, names);
                } else if (type === "Finally") {
                    VarDeclaredNames(node.block, names);
                } else if (type === "SwitchStatement") {
                    names = VarDeclaredNames(node.discriminant, names);
                    names = VarDeclaredNames(node.cases);
                } else if (IterationStatement[type]) {
                    if (type === "ForStatement") {
                        names = VarDeclaredNames(node.init, names);
                    } else if (type === "ForInStatement") {
                        if (node.left && node.left.type) {
                            if (node.left.type === "Identifier") names.push(node.left.name);
                        } else
                            names = VarDeclaredNames(node.left, names);
                    } else if (type === "ForOfStatement") {
                        if (node.left && node.left.type) {
                            if (node.left.type === "Identifier") names.push(node.left.name);
                        } else
                            names = VarDeclaredNames(node.left, names);
                    }
                    names = VarDeclaredNames(node.body, names);
                } else if (type === "ExportStatement") {
                    if (node.exports.type === "VariableDeclaration") names = VarDeclaredNames(node.exports, names);
                }
            }
        }
        //debug("VarDeclaresNames: " + names.join(","));
        return names;
    }
    function VarScopedDeclarations(body, list) {
        var node, decl, i, j, k, l;
        var top;
        list = list || [];
        if (!Array.isArray(body)) body = [body];
        for (i = 0, j = body.length; i < j; i++) {
            if (node = body[i]) {
                var type = node.type;
                if (type === "VariableDeclaration" && node.kind === "var") {
                    var decls = node.declarations;
                    for (k = 0, l = decls.length; k < l; k++) {
                        if (decl = decls[k]) {
                            list.push(decl);
                        }
                    }
                } else if (type === "BlockStatement") {
                    VarScopedDeclarations(node.body, list);
                } else if (type === "FunctionDeclaration") {
                    if (!node.expression) list.push(node);
                } else if (type === "IfStatement") {
                    VarScopedDeclarations(node.consequent, list);
                    VarScopedDeclarations(node.alternate, list);
                } else if (type === "WhileStatement") {
                    VarScopedDeclarations(node.body, list);
                } else if (type === "DoWhileStatement") {
                    VarScopedDeclarations(node.body, list);
                } else if (type === "TryStatement") {
                    VarScopedDeclarations(node.handler, list);
                } else if (type === "CatchClause") {
                    VarScopedDeclarations(node.block, list);
                } else if (type === "Finally") {
                    VarScopedDeclarations(node.block, list);
                } else if (type === "SwitchStatement") {
                    VarScopedDeclarations(node.cases, list);
                } else if (IterationStatement[type]) {

                    if (type === "ForStatement") {
                        list = VarScopedDeclarations(node.init, list);
                    } else if (type === "ForInStatement") {
                        if (node.left && node.left.type) {
                            if (node.left.type === "Identifier") list.push(node.left.name);
                        } else

                            list = VarScopedDeclarations(node.left, list);
                    } else if (type === "ForOfStatement") {
                        if (node.left && node.left.type) {
                            if (node.left.type === "Identifier") list.push(node.left.name);
                        } else

                            list = VarScopedDeclarations(node.left, list);
                    }
                    list = VarScopedDeclarations(node.body, list);
                }
            }
        }

        //debug("VarScopedDeclarations: " + list.length);

        return list;
    }
    function LexicallyDeclaredNames(body, names) {
        var node, decl, i, j, k, l;
        if (!names) names = [];
        if (!body) return names;

        for (i = 0, j = body.length; i < j; i++) {
            if (node = body[i]) {
                var type = node.type;
                if (type === "LexicalDeclaration" || (type === "VariableDeclaration" && (node.kind === "let" || node.kind === "const"))) {
                    var decls = node.declarations;
                    for (k = 0, l = decls.length; k < l; k++) {
                        if (decl = decls[k]) {
                            names = BoundNames(decl, names);
                        }
                    }
                } else if (type === "GeneratorDeclaration") {
                    names = BoundNames(node, names);
                }
            }
        }

        //debug("LexicallyDeclaresNames: " + names.join(","));

        return names;
    }
    function LexicallyScopedDeclarations(body, list) {
        if (!body) return;
        var node, decl, i, j, k, l;
        list = list || [];
        if (!body) return list;
        if (!Array.isArray(body)) body = [body];
        for (i = 0, j = body.length; i < j; i++) {
            if (node = body[i]) {

                var type = node.type;
                if (type === "LexicalDeclaration" || (type === "VariableDeclaration" && node.kind !== "var")) {
                    var decls = node.declarations;

                    for (k = 0, l = decls.length; k < l; k++) {
                        if (decl = decls[k]) {
                            list.push(decl);
                        }
                    }
                } else if (type === "GeneratorDeclaration") {
                    list.push(node);
                }
            }
        }
        //debug("LexicallyScopedDeclarations: " + list.length);

        return list;
    }
    function LexicalDeclarations(body, list) {
        if (!body) return;
        var node, decl, i, j, k, l;
        list = list || [];


        if (!body) return list;
        if (!Array.isArray(body)) body = [body];


        for (i = 0, j = body.length; i < j; i++) {
            if (node = body[i]) {
                var type = node.type;

                if (type === "LexicalDeclaration" || (type === "VariableDeclaration" && node.kind !== "var")) {
                    var decls = node.declarations;

                    for (k = 0, l = decls.length; k < l; k++) {
                        if (decl = decls[k]) {
                            list.push(decl);
                        }
                    }

                } else if (type === "GeneratorDeclaration") {
                    list.push(node);
                }
            }
        }

        //debug("LexicalDeclarations: " + list.length);
        //debug(list.map(function (x) { return x.id; }).join());

        return list;
    }
    function DeclaredNames (node) {
        var lexNames = LexicallyDeclaredNames(node);
        var varNames = VarDeclaredNames(node);
        var names = lexNames.concat(varNames);
        return names;
    }
    function ReferencesSuper(node) {
        var type;
        var stmt, contains = false;

        if (node && !Array.isArray(node)) {
            type = node.type;
            if (type === "SuperExpression") return true;
            if (type === "MethodDefinition" || type == "FunctionDeclaration" || type == "GeneratorDeclaration") {
                if (node.needsSuper == true) return true;
                contains = ReferencesSuper(node.params);
                if (contains) return true;
                contains = ReferencesSuper(node.body);
                if (contains) return true;
            } else if (type === "NewExpression" || type === "CallExpression") {
                if (ReferencesSuper(node.callee)) return true;
            } else if (type === "MemberExpression") {
                if (ReferencesSuper(node.object)) return true;
            }
        }

        if (node && Array.isArray(node)) {

            for (var i = 0, j = node.length; i < j; i++) {
                if (stmt = node[i]) {
                    type = stmt.type;
                    if (ReferencesSuper(stmt)) return true;
                } else if (IsIteration[stmt.type]) {
                    if (ReferencesSuper(stmt.body)) return true;
                }
            }

        }
        return false;
    }
    function ConstructorMethod(defs) {
        var C, def;
        if (Array.isArray(defs)) {
            for (var i = 0, j = defs.length; i < j; i++) {
                if (def = defs[i]) {
                    if (def.isConstructor) return def;
                    if (def.id.name === "constructor") return def;
                    if (def.ctor) return def.ctor;
                }
            }
        } else {
            def = defs;
            if (!def) return null;
            if (def.isConstructor) return def;
            if (def.id.name === "constructor") return def;
            if (def.ctor) return def.ctor;
        }
        return null;
    }
    function PrototypeMethodDefinitions(defs, checkList) {
        var def, list = [];
        for (var i = 0, j = defs.length; i < j; i++) {
            def = defs[i];
            if (def && def.type === "MethodDefinition") {
                if (def.isPrototype) list.push(def);
                else if (!def.static && !def.isConstructor) list.push(def);
            }
        }
        return list;
    }
    function StaticMethodDefinitions(defs, checkList) {
        var def, list = [],
            checkList = Object.create(null);
        for (var i = 0, j = defs.length; i < j; i++) {
            def = defs[i];
            if (def && def.type === "MethodDefinition") {
                if (def.static) {
                    var id = def.id && def.id.name;
                    if (id && checkList[id] && def.kind !== "get" && def.kind !== "set") return newSyntaxError( "duplicate static method definition: " + id);
                    else {
                        checkList[id] = def.kind;
                        list.push(def);
                    }
                }
            }
        }
        return list;
    }
    function SpecialMethod() {
        if (node.kind === "get" || node.kind === "set") return true;
    }
    function HasInitializer(node) {
        var type = node.type;
        if (node.id && node.init) return true;
        else if (type === "AssignmentExpression" && node.operator === "=") return true;
        else if (type === "VariableDeclarator" && node.init) return true;
        else if (type === "DefaultParameter") return true;
    }
    function IsSimpleParameterList(list) {
        var p;
        for (var i = 0, j = list.length; i < j; i++) {
            if (p = list[i]) {
                if (isComplexParameter[p.type]) return false;
            }
        }
        return true;
    }
    function ExpectedArgumentCount(list) {
        var p;
        for (var i = 0, j = list.length; i < j; i++) {
            if (p = list[i]) {
                if (p.type === "RestParameter" || p.type === "DefaultParameter") return i;
            }
        }
        return j;
    }
    function IsValidSimpleAssignmentTarget(node) {
        var type = node.type;
        if (type === "Identifier") return true;
        if (type === "ArrayPattern") return true;
        if (type === "ObjectPattern") return true;
        if (type === "BinaryExpression") return false;
        return false;
    }
    function StringValue(node) {
        if (!node) return;
        switch (node.type) {
            case "Identifier":
                return node.name;
            case "StringLiteral":
                return node.value.slice(1, node.value.length - 1);
            case "NumericLiteral":
                return node.value;
            case "DefaultParameter":
            case "RestParameter":
                return node.id;
            case "FunctionExpression":
            case "GeneratorExpression":
            case "FunctionDeclaration":
            case "GeneratorDeclaration":
                return node.id
        }
    }
    function PropName(node) {
        if (typeof node === "string") return node;
        var type = node.type;
        var id = node.id;
        if (type === "StringLiteral") return StringValue(node);
        if (type === "Identifier") return StringValue(node);
        if (typeof id === "string") return id;
        if (type === "MethodDefinition") return PropName(id);
        if (typeof id === "object") return StringValue(id);
    }
    function PropNameList(node, checkList) {
        var list, body;
        if (body = node.properties) {

        } else if (body = node.elements) {

        } else if (body = node.body) {

        }
    }
    function ElisionWidth(E) {
        return (E && E.width)|0;
    }
    function IsConstantDeclaration(node) {
        return node.kind === "const";

    }
    function IsLexicalDeclaration(node) {
        var type = node.type;
        var kind = node.kind;
        if (LetOrConst[kind]) return true;
        if (type === "LexicalDeclaration") return true;
        if (type === "VariableDeclaration") {
            if (LetOrConst[kind]) return true;
        }
        return false;
    }
    function dupesInTheTwoLists(list1, list2, memo) {
        var hasDupe = false;
        var memo = memo || Object.create(null);
        for (var i = 0, j = list1.length; i < j; i++) memo[list1[i]] = true;
        for (i = 0, j = list2.length; i < j; i++)
            if (memo[list2[i]]) hasDupe = true;
            else memo[list2[i]] = true;
    }
    function dupesInTheList(list, memo) {
        var hasDupe = false;
        var memo = memo || Object.create(null);
        for (var i = 0, j = list.length; i < j; i++) {
            if (memo[list[i]]) hasDupe = true;
            else memo[list[i]] = true;
        }
        return hasDupe;
    }
    function TV(t) {}
    function TRV(t) {}
    function CV(lit) {
        return lit.name || lit.value;
    }
    function MV(value) {
        return +value;
    }
    function SV(value) {
        return "" + value;
    }
    function isDuplicateProperty(id, checkList) {
        if (checkList[id]) {
            return newTypeError( "duplicate property or method definition: " + id);
        } else return false;
    }

    exports.ModuleRequests = ModuleRequests;
    exports.ImportEntriesForModule = ImportEntriesForModule;
    exports.ExportEntriesForModule = ExportEntriesForModule;
    exports.ImportedEntries = ImportedEntries;
    exports.ImportedBindings = ImportedBindings;
    exports.ExportedEntries = ExportedEntries;
    exports.ExportedBindings = ExportedBindings;
    exports.IsFunctionDeclaration = IsFunctionDeclaration;
    exports.IsFunctionExpression = IsFunctionExpression;
    exports.IsGeneratorDeclaration = IsGeneratorDeclaration;
    exports.IsGeneratorExpression = IsGeneratorExpression;
    exports.IsVarDeclaration = IsVarDeclaration;
    exports.IsIdentifierRef = IsIdentifierRef;
    exports.TailPosition = TailPosition;
    exports.HasProductionInTailPosition = HasProductionInTailPosition;
    exports.IsAnonymousFunctionDefinition = IsAnonymousFunctionDefinition;
    exports.UTF16Encode = UTF16Encode;
    exports.UTF16Decode = UTF16Decode;
    exports.isStrictDirective = isStrictDirective;
    exports.IsStrict = IsStrict;
    exports.DeclaredNames = DeclaredNames;
    exports.StringValue = StringValue;
    exports.Contains = Contains;
    exports.BoundNames = BoundNames;
    exports.VarDeclaredNames = VarDeclaredNames;
    exports.LexicallyDeclaredNames = LexicallyDeclaredNames;
    exports.VarScopedDeclarations = VarScopedDeclarations;
    exports.LexicallyScopedDeclarations = LexicallyScopedDeclarations;
    exports.LexicalDeclarations = LexicalDeclarations;
    exports.ReferencesSuper = ReferencesSuper;
    exports.ConstructorMethod = ConstructorMethod;
    exports.PrototypeMethodDefinitions = PrototypeMethodDefinitions;
    exports.StaticMethodDefinitions = StaticMethodDefinitions;
    exports.SpecialMethod = SpecialMethod;
    exports.HasInitializer = HasInitializer;
    exports.IsSimpleParameterList = IsSimpleParameterList;
    exports.ExpectedArgumentCount = ExpectedArgumentCount;
    exports.IsValidSimpleAssignmentTarget = IsValidSimpleAssignmentTarget;
    exports.PropName = PropName;
    exports.PropNameList = PropNameList;
    exports.IsConstantDeclaration = IsConstantDeclaration;
    exports.IsLexicalDeclaration = IsLexicalDeclaration;
    exports.ElisionWidth = ElisionWidth;
    exports.ExportedNames = ExportedNames;
    exports.dupesInTheTwoLists = dupesInTheTwoLists;
    exports.dupesInTheList = dupesInTheList;
    exports.isDuplicateProperty = isDuplicateProperty;
    exports.TV = TV;
    exports.TRV = TRV;
    exports.CV = CV;
    exports.MV = MV;
    exports.SV = SV;
    exports.IsIdentifier = IsIdentifier;

});
define("tokenizer", function () {
//    function makeTokenizer () {
    "use strict";
    var exports = {};
    var tables = require("tables");
    var Punctuators = tables.Punctuators;
    var StartOfThreeFourPunctuators = tables.StartOfThreeFourPunctuators;
    var WhiteSpaces = tables.WhiteSpaces;
    var LineTerminators = tables.LineTerminators;
    var HexDigits = tables.HexDigits;
    var BinaryDigits = tables.BinaryDigits;
    var SingleEscapeCharacter = tables.SingleEscapeCharacter;
    var OctalDigits = tables.OctalDigits;
    var DecimalDigits = tables.DecimalDigits;
    var ExponentIndicator = tables.ExponentIndicator;
    var SignedInteger = tables.SignedInteger;
    var ParensSemicolonComma = tables.ParensSemicolonComma;
    var NumericLiteralLetters = tables.NumericLiteralLetters;
    var IdentifierStart = tables.IdentifierStart;
    var IdentifierPart = tables.IdentifierPart;
    var RegExpFlags = tables.RegExpFlags;
    var RegExpNoneOfs = tables.RegExpNoneOfs;
    var RegExpNoneOfsVal = tables.RegExpNoneOfsVal;
    var NotBeforeRegExp = tables.NotBeforeRegExp;
    var UnicodeIDStart = tables.UnicodeIDStart;
    var UnicodeIDContinue = tables.UnicodeIDContinue;
    var Quotes = tables.Quotes;
    var PunctToExprName = tables.PunctToExprName;
    var TypeOfToken = tables.TypeOfToken;
    var PunctOrLT = tables.PunctOrLT;
    var FewUnaryKeywords = tables.FewUnaryKeywords;
    var AllowedLastChars = tables.AllowedLastChars;
    var OneOfThesePunctuators = tables.OneOfThesePunctuators;
    var SkipableToken = tables.SkipableToken;
    var SkipableTokenNoLT = tables.SkipableTokenNoLT;
    /*
     var unicode = require("unicode-support");
     var isIdentifierStart = unicode.isIdentifierStart || function () {};
     var isIdentifierPart = unicode.isIdentifierPart || function () {};
     */
    var withWS = false;
    var createCustomToken = null;
    var sourceCode;
    var pos, length;
    var ltNext;
    var ltLast;
    var token;
    var tokenType; // is set at makeToken, until next token. asked for at standalone regexp
    var tokenValue;
    var lastToken;
    var ch, lookahead;	// lookahead0 and lookahead1
    var cb;
    var tokens = [];
    var tokensWithWhiteSpaces = [];
    var line = 1, column = 1;
    var lines = [];
    var offset = 0;
    var filename = null;
    var inputElementDiv = 1;
    var inputElementRegExp = 2;
    var inputElementTemplateTail = 3;
    var inputElementGoal = inputElementRegExp;
    var withExtras = false;
    var debugmode = false;
    var hasConsole = typeof console === "object" && console && typeof console.log === "function";
    function debug() {
        if (debugmode && hasConsole) {
            if (typeof arguments[0] == "object") {
                console.dir(arguments[0]);
            } else console.log.apply(console, arguments);
        }
    }
    function match(c) {
        if (c == ch) next();
        else throw new SyntaxError("tokenizer: "+ c + " expected, saw "+ch)
    }
    function Assert(test, message) {
        if (!test) throw new SyntaxError("assertion failed in tokenizer: "+message);
    }
    function updateStack(se) {
        var oldstack = se.stack;
        se.stack = "syntax.js tokenizer,\nfunction tokenize,\n does not recognize actual input. ch=" + ch + ", lookahead=" + lookahead + ", line=" + line + ", col=" + column + ", offset=" + offset + ", pos="+pos+" " +sourceCode+" \n" + oldstack;
    }    function atLineCol() {
        return ch + " at offset " + pos + " at line " + line + " at column " + column + ", lookahead="+lookahead;
    }
    function setCustomTokenMaker (func) {
        if (typeof func === null) {
            createCustomToken = null;
        } else if (typeof func === "function") {
            createCustomToken = func;
        } else throw new TypeError("tokenmaker must be a 'function token_maker(my_token) returns your_token' to return a custom token. Please fix that and try again.");
    }
    function unsetCustomTokenMaker () {
        createCustomToken = null;
    }
    function setWithExtras(bool) {
        withExtras = !!bool;
    }
    var extraBuffer = [];
    function exchangeExtraBuffer() {
        var b = extraBuffer;
        extraBuffer = [];
        tokenize.extraBuffer = b; // available in the parser.
        return b;
    }
    var saved = [];
    function saveState() {
        saved.push({
            sourceCode: sourceCode,
            pos: pos,
            length: length,
            token: token,
            tokenType: tokenType,
            ch: ch,
            lookahead: lookahead,
            inputElementGoal: inputElementGoal
        });
    }
    function restoreState() {
        var memento;
        if (memento = saved.pop()) {
            sourceCode = memento.sourceCode;
            pos = memento.pos;
            length = memento.length;
            token = memento.token;
            tokenType = memento.tokenType;
            ch = memento.ch;
            lookahead = memento.lookeahead;
            inputElementGoal = memento.inputElementGoal;
        }
    }
    function LineTerminator() {
        if (LineTerminators[ch]) {
            makeToken("LineTerminator", ch);
            if (!(ch  === "\r" && lookahead === "\n")) nextLine();
            next();
            return token;
        }
        return false;
    }
    function WhiteSpace() {
        var spaces = "";
        var spc;
        if (WhiteSpaces[ch]) {
            spaces += ch;
            spc = ch;
            while (lookahead === spc) {
                next();
                spaces += ch;
            }
            makeToken("WhiteSpace", spaces);
            next();
            return token;
        }
        return false;
    }
    function StringLiteral() {
        var quotecharacter;
        var string = "";
        var raw = "";
        var multiline = false;
        var n;
        if (Quotes[ch]) {
            quotecharacter = ch;
            string += ch;
            big: while (next()) {
                string += ch;
                if (ch === quotecharacter) {
                    n = string.length - 2;
                    do {
                        if (string[n] !== "\\") break big;
                        else if (string[n - 1] === "\\" && string[n - 2] !== "\\") break big;
                    } while (string[n -= 2] === "\\");
                }
                if (LineTerminators[lookahead]) {
                    n = string.length - 1;
                    while (string[n] === "\\") {
                        if (string[n - 1] === "\\") {
                            multiline = false;
                            n -= 2;
                        } else {
                            multiline = true;
                            string = string.substr(0, string.length-1);
                            if (lookahead == "\r") next();// pass \n
                            if (lookahead == "\n") next();
                            nextLine();
                            break;
                        }
                    }
                }



                if (LineTerminators[ch]) {
                    if (!multiline) throw new SyntaxError("Unexpected token ILLEGAL");
                    else multiline = false;
                }
            }
            makeToken("StringLiteral", string, string.substr(1, string.length - 2));
            next();
            return token;
        }

        return false;
    }
    function TemplateLiteral () {
        // `edward ${ ""+ist+y } toll ${ oder } nicht?`
        // [ "edward ", " \""+ist+y ", " toll ", " oder ", " nicht" ]

        if (ch === "`") {
            var template, cooked;
            var spans = [];
            var braces;
            match("`");
            while (ch != undefined) {
                template = "";
                while ((ch === "$" && lookahead === "{") === false) {
                    if (ch === "`") {
                        spans.push(template);
                        makeToken("TemplateLiteral", spans);
                        match("`");
                        return token;
                    }
                    template += ch;
                    next();
                }
                spans.push(template);
                match("$");
                match("{");
                cooked = "";
                braces = ["{"];
                while (ch != "}") {
                    if (ch == "{") braces.push("{");
                    cooked += ch;
                    next();
                    // addition: block nesting ${ (function(){return 10; }()) }
                    if (ch == "}") {
                        braces.pop();
                        if (!braces.length) {
                            break;
                        } else {
                            cooked += ch;
                            next();
                        }
                    }
                    // block nesting end
                }
                spans.push(cooked);
                match("}");
            }
        }
        return false;
    }
    function Comments() {
        var comment = "";
        var type;
        if ((ch + lookahead) === "//") {
            type = "LineComment";
            comment = "//";
            next();
            while (ch && !LineTerminators[lookahead]) {
                next();
                comment += ch;
            }
            makeToken(type, comment);
            next();
            return token;
        } else if (ch + lookahead === "/*") {
            type = "MultiLineComment";
            comment = "/*";
            next();	// fix /*/ funny experience
            next();
            while (ch + lookahead !== "*/") {
                if (ch == "\n") nextLine();
                if (ch === undefined) {
                    throw new SyntaxError("Unexpected end of file");
                }
                comment += ch;
                next();
            }
            comment += "*/";    // ch + lookahead
            next();
            makeToken(type, comment);
            next();
            return token;
        }
        return false;
    }
    function RegularExpressionLiteral() {
        if (ch === "/" && !NotBeforeRegExp[tokenType] && !RegExpNoneOfsVal[tokenValue]) {
            var expr = "";
            var flags = "";
            var n;
            if (!RegExpNoneOfs[lookahead] && !LineTerminators[lookahead]) {
                next(); // first char after /
                big:
                    while (ch != undefined) {
                        if (ch === "/") {
                            n = expr.length - 1;
                            do {
                                if ((expr[n] !== "\\") || (expr[n - 1] === "\\" && expr[n - 2] !== "\\")) {
                                    break big;
                                }
                            } while (expr[n -= 2] === "\\");
                        } else if (LineTerminators[ch] || ch == undefined) {
                            throw new SyntaxError("Unexpected end of line, while parsing RegularExpressionLiteral at line " + line + ", column " + column);
                        }
                        expr += ch;
                        next();
                    }
            } else {
                return false;
            }
            if (ch === "/") {
                match("/");
                var hasFlags = {};
                while (RegExpFlags[ch]) {
                    if (hasFlags[ch]) throw new SyntaxError("duplicate flags not allowed in regular expressions");
                    flags += ch;
                    hasFlags[ch] = true;
                    next();
                }
                if (!(WhiteSpaces[ch]||Punctuators[ch]||LineTerminators[ch]) && ch != undefined) {
                    throw new SyntaxError("unexpected token illegal");
                }
                makeToken("RegularExpressionLiteral", [expr, flags]);
                inputElementGoal = inputElementDiv;
                return token;
            }

        }
        return false;
    }
    function DivPunctuator() {
        var tok;
        if (ch === "/") {
            if (tok = Comments()) return token = tok;
            if (inputElementGoal === inputElementRegExp) {
                if (tok = RegularExpressionLiteral()) {
                    inputElementGoal = inputElementDiv;
                    return token = tok;
                }
                inputElementGoal = inputElementDiv;
            }
            if (inputElementGoal !== inputElementRegExp) {
                if (ch + lookahead === "/=") {
                    next();
                    makeToken("Punctuator", "/=", undefined, PunctToExprName["/="]);
                    next();
                    return token;
                } else {
                    makeToken("Punctuator", ch, undefined, PunctToExprName[ch]);
                    next();
                    return token;
                }
            }
        }
        return false;
    }
    function Punctuation() {
        if (ch == "/") return DivPunctuator();
        if (ParensSemicolonComma[ch]) {
            makeToken("Punctuator", ch, undefined, PunctToExprName[ch]);
            next();
            return token;
        }
        var punct;
        if (!StartOfThreeFourPunctuators[ch]) {
            punct = ch + lookahead;
        } else {
            punct = sourceCode[pos] + sourceCode[pos + 1] + sourceCode[pos + 2] + sourceCode[pos + 3];
            if (punct === ">>>=") {
                next();next();next();
                makeToken("Punctuator", punct, undefined, PunctToExprName[punct]);
                next();
                return token;
            }
            punct = punct[0] + punct[1] + punct[2];
            if (Punctuators[punct]) {
                next();next();
                makeToken("Punctuator", punct, undefined, PunctToExprName[punct]);
                next();
                return token;
            }
            punct = punct[0] + punct[1];
        }
        if (Punctuators[punct]) {
            next();
            makeToken("Punctuator", punct, undefined, PunctToExprName[punct]);
            next();
            return token;
        }
        punct = punct[0];
        if (Punctuators[punct]) {
            makeToken("Punctuator", punct, undefined, PunctToExprName[punct]);
            next();
            return token;
        }
        return false;
    }
    function getDecimalDigits(number) {
        var dot = false, exp = false;
        if (DecimalDigits[ch] || (ch === "." && DecimalDigits[lookahead] && (dot=true))) {
            number += ch;
            for (;;) {
                if (DecimalDigits[lookahead] || (lookahead === "." && !dot)) {
                    next();
                    number += ch;
                    if (ExponentIndicator[lookahead]) {
                        if(!exp) {
                            exp = true;
                            next();
                            number += ch;
                            if (SignedInteger[lookahead]) {
                                next();
                                number += ch;
                            }
                            while (DecimalDigits[lookahead]) {
                                next();
                                number += ch;
                            }
                            return number;
                        } else {
                            throw new SyntaxError("duplicate exponent indicator");
                        }
                    }
                } else if (lookahead === "." && dot) {
                    throw new SyntaxError("unexpected number");
                } else {
                    break;
                }
            }
            return number;
        }
        return false;
    }
    function NumericLiteral() {
        var number = "", longName, computed = 0;
        if (ch === "0" && NumericLiteralLetters[lookahead]) {
            number += ch;
            next();
            if ((ch === "x" || ch === "X") && HexDigits[lookahead]) {
                number += ch;
                while (HexDigits[lookahead]) {
                    next();
                    number += ch;
                }
                longName = "HexLiteral";
                // code for MV function
                computed = +number;
            } else if ((ch === "b" || ch === "B") && BinaryDigits[lookahead]) {
                number += ch;
                while (BinaryDigits[lookahead]) {
                    next();
                    number += ch;
                }
                longName = "BinaryLiteral";
                computed = 0;
                // optimal code for MV function:
                for (var a = 2, b = number.length - 1; a <= b; a++)
                    computed += (+(number[a]) << (b - a)); // that´s from me.
            } else if ((ch === "o" || ch == "O") && OctalDigits[lookahead]) {
                number += ch;
                while (OctalDigits[lookahead]) {
                    next();
                    number += ch;
                }
                longName = "OctalLiteral";
                // code for MV(value) function
                computed = +(parseInt(number.substr(2), 8).toString(10));
            }
            makeToken("NumericLiteral", number, computed, longName);
            // syntax error works for all three above
            if (!(WhiteSpaces[lookahead]||Punctuators[lookahead]||LineTerminators[lookahead]) && lookahead != undefined) {
                throw new SyntaxError("unexpected token illegal in "+longName);
            }
            next();
            return token;
        } else if (DecimalDigits[ch] || (ch === "." && DecimalDigits[lookahead])) {
            number = getDecimalDigits(number);
            // if (number === false) throw new SyntaxError("Error parsing decimal digit")

            computed = +number; // code for MV function
            makeToken("NumericLiteral", number, computed, "DecimalLiteral");
            if (!(WhiteSpaces[lookahead]||Punctuators[lookahead]||LineTerminators[lookahead]) && lookahead != undefined) {
                throw new SyntaxError("unexpected token illegal in "+longName);
            }
            next();
            return token;
        }
        return false;
    }
    function getUnicodeBody() {
        var max, now = 0, raw = "";
        if (lookahead == "1") max = 5;
        else if (lookahead == "0") max = 4;
        else throw new SyntaxError("unexpected kind of unicode literal");
        while (HexDigits[lookahead]) {
            next();
            ++now;
            raw += ch;
            if (now === max) break;
        }
        if (now < max) throw new SyntaxError("unexpected kind of unicode literal "+max+" digits expected");
        return raw;
    }
    function EscapeSequence() {
        var raw = "";
        var value = "";
        if (ch == "\\") {
            var longName = "EscapeSequence";
            raw += ch;
            if (lookahead === "u") {
                next();
                raw += ch;
                if (lookahead == "{") {
                    next();
                    raw += ch;
                    raw += getUnicodeBody();
                    if (lookahead === "}") {
                        next();
                        raw += ch;
                        value = eval("\'" + raw + "\'");
                    } else {
                        throw new SyntaxError("expecting } to close unicode seq.");
                    }
                } else {
                    raw += getUnicodeBody();
                    // value = String.fromCharCode(+(raw.substr(2, raw.length-1)));
                    value = eval("\'" + raw + "\'");
                }
            } else if (SingleEscapeCharacter[lookahead]) {
                next();
                raw = SingleEscapeCharacter[ch];
            } else if (OctalDigits[lookahead]) {
                next();
                raw += ch;
                while (OctalDigits[lookahead]) {
                    next();
                    raw += ch;
                }
                value = parseInt(raw.substr(1, raw.length), 8);

            } else if (lookahead === "x") {
                next();
                raw += ch;
                while (HexDigits[lookahead]) {
                    next();
                    raw += ch;
                }
                value = eval("\'" + raw + "\'");
            }
            else {
                throw new SyntaxError("invalid escape sequence "+ch+ " "+lookahead);
            }
            return value;
        }
        return false;
    }
    /*
     function UnicodeEscape() {
     var raw = "",
     value = "",
     unit, cp1, cp2;
     raw += ch;
     next();
     raw += ch;
     if (lookahead == "{") {
     next();
     raw += ch;
     while (HexDigits[lookahead]) {
     next();
     raw += ch;
     }
     if (lookahead === "}") {
     next();
     raw += ch;
     value = eval("\'" + raw + "\'");
     // String.fromCharCode((+(raw.substr(3, raw.length-2))).toFixed(4));
     }
     } else {
     while (HexDigits[lookahead]) {
     next();
     raw += ch;
     }
     unit = 0;
     for (var a = 0, b = raw.length - 1; a <= b; a++) {
     unit += (1 << (b - a) * 4) * + raw[a];
     }
     if (unit > 0x10000) {
     cp1 = Math.floor((unit - 0x10000) / 0x0400 + 0xD800);
     cp2 = (unit - 0x10000) % 0x0400 + 0xD800;
     value = String.fromCharCode(cp1, cp2);
     } else
     value = eval("\'" + raw + "\'");
     // String.fromCharCode(+(raw.substr(2, raw.length-1)));
     }
     return [ raw, value ];
     }
     */
    function KeywordOrIdentifier() {
        var token = "", e;
        var escaped = false;
        var raw = "";

        // to have an escaped and unescaped version
        // i saved it twice already in the very first version very early
        // (removed but should return)

        if (!IdentifierStart[ch] && !UnicodeIDStart[ch]) return false;
//    	    !String.isIdentifierStart(ch.codePointAt(0))) return false;
        if (ch !== "\\") {
            token += ch;
        } else {
            token = EscapeSequence();
            escaped = true;

            if (!IdentifierPart[lookahead] && (lookahead != "\\")) {
                if (IdentifierStart[token]) makeToken("Identifier", token);
                else throw new SyntaxError("unexpected escape sequence");
                next();
                return token;
            }
        }
        while (IdentifierPart[lookahead] || lookahead == "\\" ||
            // (lookahead && String.isIdentifierPart(lookahead.codePointAt(0)))
            // move table to unicodeIDcontinue
            UnicodeIDContinue[lookahead]) {
            next();
            if (ch === "\\") {
                escaped = true;
                token += EscapeSequence();
            } else {
                token += ch;
            }
        }
        makeToken((escaped ? "Identifier" : (TypeOfToken[token] || "Identifier")), token, token);
        next();
        return token;
    }

    function nextLine() {
        lines[line] = column;
        ++line;
        column = 1;
        return line;
    }

    function next(k) {
        if (pos < length) {
            pos += 1;
            ch = lookahead;
            lookahead = sourceCode[pos + 1];
            if (k) { return next(--k); }
            return ch;
        }
        return !!(ch = lookahead = undefined);
    }

    function makeToken(type, value, computed, longName) {
        lastToken = token;
        token = Object.create(null);
        ltLast = ltNext;
        if (type === "LineTerminator") ltNext = true;
        else ltNext =false;
        token.type = type;
        token.longName = longName;
        token.value = value;
        token.computed =  computed;
        if ((FewUnaryKeywords[value] || PunctOrLT[type]) && !OneOfThesePunctuators[value]) {
            inputElementGoal = inputElementRegExp;
        }
        token.loc = {
            source: filename,
            start: {
                line: line,
                column: column
            }
        };
        if (value != undefined) column += value.length;
        token.loc.end = {
            line: line,
            column: column - 1
        };
        token.offset = offset;
        //token.loc.range = [offset, offset + (((value&&value.length)-1)|0) ];
        if (createCustomToken) token = createCustomToken(token);
        if (!SkipableTokenNoLT[type]) {
            tokenType = type;
            tokenValue = value;
            tokens.push(token);
        } else {
            if (withExtras) extraBuffer.push(token);
        }
        if (withWS) tokensWithWhiteSpaces.push(token);

        // emit("token", token);
        return token;
    }

    function exchangeToken() {
        tokenize.token = token;
        tokenize.tokenType = tokenType;
        tokenize.tokenValue = tokenValue;
        tokenize.ltNext = ltNext;
    }

    function finishToken() {
        token = undefined;
        tokenType = undefined;
        tokenValue = undefined;
        ltNext = false;
        exchangeToken();
        return token;
    }

    function nextToken() {
        if (pos >= length) return finishToken();
        offset = pos;
        token = undefined;
        if (DecimalDigits[ch] || ch == ".") NumericLiteral();
        if (!token && Punctuators[ch]) Punctuation();
        if (IdentifierStart[ch]) KeywordOrIdentifier();
        else if (Quotes[ch]) StringLiteral();
        else if (ch == "`") TemplateLiteral();
        else if (WhiteSpaces[ch]) WhiteSpace();
        else if (LineTerminators[ch]) LineTerminator();

        if (!token && pos < length) throw new SyntaxError("Unknown Character: "+atLineCol());
        else if (!token) return finishToken();
        if (SkipableToken[token.type]) {
            if (token.type === "LineTerminator") ltNext = true;
            if (withExtras) {
                extraBuffer.push(token);
            }
            return nextToken(); // this one overflows the callstack
        } else {
            ltNext = false;
        }
        exchangeToken();
        exchangeExtraBuffer();
        return token;
    }

    function tokenize(jsSourceText, callback) {
        initTokenizer(jsSourceText, callback);
        return nextToken();
    }

    function initTokenizer(jsSourceText, callback) {
        if (jsSourceText) sourceCode = jsSourceText;
        if (callback) cb = callback;
        inputElementGoal = inputElementRegExp;
        tokens = tokenize.tokens = [];
        line = 1;
        column = 1;
        pos = -1;
        length = sourceCode.length;
        ch = undefined;
        lookahead = sourceCode[0];
        next();
    }

    function tokenizeIntoArray(jsSourceText, callback) {
        saveState();
        initTokenizer(jsSourceText, callback);
        if (withWS) tokenizeIntoArray.tokensWithWhiteSpaces = [];
        do {
            offset = pos;
            token = undefined;

            /*
                        if (WhiteSpaces[ch]) WhiteSpace();
                        else if (LineTerminators[ch]) LineTerminator();
                        else if (DecimalDigits[ch] || ch == ".") NumericLiteral();
                        if (!token) {
                            if (Punctuators[ch]) Punctuation();
                            else if (IdentifierStart[ch]) KeywordOrIdentifier();
                            else if (Quotes[ch]) StringLiteral();
                            else if (ch == "`") TemplateLiteral();
                        }
                    */
            switch (ch) {
                case " ":
                case "\t": WhiteSpace(); break;
                case "\r":
                case "\n": LineTerminator(); break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                case ".": NumericLiteral(); break;
                case "'":
                case "\"": StringLiteral(); break;
                case "`":  TemplateLiteral(); break;
                default:
                    if (IdentifierStart[ch]) KeywordOrIdentifier();
                    break;
            }
            if (!token && Punctuators[ch]) Punctuation();


	    /*
	    
	    // slowest ist the ORing of Functions() which have to be called,
	    // which means a whole EvaluateCall Situation. On node it´s 20% more
	    // just for calling 6 function EACH CHARACTER.
	    
	    // The second biggest lost is currently in parser´s OLD next,
	    // which skips WhiteSpaces and Co. TWICE. Simply removing causes
	    // in faults, and i didn´t see it, although it´s simple.
	    
             WhiteSpace() || LineTerminator() || DivPunctuator() || NumericLiteral() || Punctuation()|| KeywordOrIdentifier() || StringLiteral() || TemplateLiteral();

	    */

            if (!token && pos < length) {
                var errorMsg = "Unknown Character: "+ch+" at offset "+pos+" at line "+line+" at column "+column;
                restoreState();
                throw new SyntaxError(errorMsg);
            }
            if (withExtras) {
                exchangeExtraBuffer();
            }
            
        } while (ch !== undefined);
        restoreState();
        return tokens;
    }



    function tokenizeIntoArrayWithWhiteSpaces(jsSourceText, callback) {
        withWS = true;
        tokensWithWhiteSpaces = [];
        var tokens = tokenizeIntoArray(jsSourceText, callback);
        withWS = false;
        return tokensWithWhiteSpaces;
    }


    var tokenizer = {};
    tokenizer.LineTerminator = LineTerminator;
    tokenizer.KeywordOrIdentifier = KeywordOrIdentifier;
    tokenizer.StringLiteral = StringLiteral;
    tokenizer.Comments = Comments;
    tokenizer.DivPunctuator = DivPunctuator;
    tokenizer.RegularExpressionLiteral = RegularExpressionLiteral;
    tokenizer.EscapeSequence = EscapeSequence;
    tokenizer.NumericLiteral = NumericLiteral;
    tokenizer.Punctuation = Punctuation;
    tokenizer.TemplateLiteral = TemplateLiteral;


    tokenizeIntoArray.tokenize = tokenize;
    tokenizeIntoArray.tokenizeIntoArray = tokenizeIntoArray;
    //tokenizeIntoArray.makeTokenizer = makeTokenizer;
    tokenizeIntoArray.saveState = saveState;
    tokenizeIntoArray.restoreState = restoreState;
    tokenize.tokenizeIntoArray = tokenizeIntoArray;
    tokenize.tokenizeIntoArrayWithWhiteSpaces = tokenizeIntoArrayWithWhiteSpaces;


    tokenize.tokenizer = tokenizer;
    tokenize.nextToken = nextToken;
    tokenize.saveState = saveState;
    tokenize.restoreState = restoreState;
    tokenize.setCustomTokenMaker = setCustomTokenMaker;
    tokenize.unsetCustomTokenMaker = unsetCustomTokenMaker;
//        tokenize.makeTokenizer = makeTokenizer;
    tokenize.exchangeExtraBuffer = exchangeExtraBuffer;
    tokenize.setWithExtras = setWithExtras;

    return tokenize;
    //}
    //return makeTokenizer();
});


/*
 * Created by root on 06.03.14.
 *
   * Early Errors is now separated from the parser.
   * -------------------------------------------
   * This "visitor" performs a check on each node,
   * whether the data is valid or not.
   * What´s valid and what´s not is listed in the spec.
   *
   * If the data is invalid it throws a new SyntaxError()
   *
   * CONTAINS is the second experiment
   * ----------------------------------
   * Contains is now becoming a blacklist
   * test with
   * if (Contains[node.type][field]) throw SyntaxError;
   *
 *
 */
define("earlyerrors", function () {


    /**
     *
     * Early Errors - maybe be factored out again by other implementation
     * (currently a stub)
     *
     * @param node
     * @returns {*}
     * @constructor
     */
    function EarlyErrors(node) {
        var handler = EarlyErrors[node.type];
        if (handler) handler(node);
        return node;
    }

    EarlyErrors.Program = function (node) {
    };
    EarlyErrors.FunctionDeclaration = function (node) {
    };
    EarlyErrors.ModuleDeclaration = function (node) {};
    EarlyErrors.Statement = function (node) {};
    EarlyErrors.StatementList = function (node) {};
    EarlyErrors.ObjectExpression = function (node) {};
    EarlyErrors.ArrayExpression = function (node) {};
    EarlyErrors.ArrayComprehension = function (node) {};
    EarlyErrors.GeneratorComprehension = function (node) {};
    EarlyErrors.GeneratorDeclaration = function (node) {};
    EarlyErrors.ForStatement = function (node) {};
    EarlyErrors.WhileStatement = function (node) {};
    EarlyErrors.DoWhileStatement = function (node) {};
    EarlyErrors.IfStatement = function (node) {};
    EarlyErrors.SwitchStatement = function (node) {};
    EarlyErrors.VariableDeclaration = function (node) {};
    EarlyErrors.LexicalDeclaration = function (node) {};
    EarlyErrors.ClassDeclaration = function (node) {};
    EarlyErrors.BlockDeclaration = function (node) {};
    EarlyErrors.Expression = function (node) {};
    EarlyErrors.ArrowExpression = function (node) {};
    EarlyErrors.FormalParameterList = function (node) {};


    /**
     *  Contains is a blacklist
     * which has to be called
     * on each node in the parser
     * when the node is returned
     * to gain maximum performance.
     * @param containerType
     * @param nodeType
     * @returns {boolean}
     * @constructor
     */
    var Contains = function (containerType, nodeType) {
        var table = Contains[containerType];
        return !!table[nodeType];
    };


    Contains.Program = {
        __proto__:null,
       "BreakStatement":true,
       "ContinueStatement": true,
       "ReturnStatement": true,
       "SuperExpression": true
    };


    /*
	Problem:
	
	"ExpressionStatement"
	
	blocks contains.
    
    */

    Contains.FunctionDeclaration = {
	__proto__:null,
       "BreakStatement":true,
       "ContinueStatement": true
    };


    Contains.ModuleDeclaration = {
        __proto__:null,
        "BreakStatement":true,
        "ContinueStatement": true,
        "ReturnStatement": true,
        "SuperExpression": true
    };


    return {
        EarlyErrors: EarlyErrors,
        Contains: Contains
    };
});


define("parser", function () {

//    function makeParser() {
    "use strict";
//    var i18n = require("i18n-messages");
    var tables = require("tables");
    var tokenize = require("tokenizer").tokenizeIntoArray; // around one return nextToken() to go to replace

    var Contains = require("earlyerrors").Contains;
    var SymbolTable = require("symboltable").SymbolTable;
    var BoundNames = require("slower-static-semantics").BoundNames;

    // JSON uses the api.
    var api, newSyntaxError, ifAbrupt, isAbrupt;
    // separation of the independent parser
    // should be reconsidered, or a wrap in
    // a try/catch and a regular throw, then
    // JSON otherwise is regularly usable from
    // parseGoalSymbol

    var IsIteration = tables.IsIteration;
    var IsTemplateToken = tables.IsTemplateToken;
    var FinishStatementList = tables.FinishStatementList;
    var FinishSwitchStatementList = tables.FinishSwitchStatementList;
    var StatementParsers = tables.StatementParsers;
    var PrimaryExpressionByValue = tables.PrimaryExpressionByValue;
    var PrimaryExpressionByType = tables.PrimaryExpressionByType;
    var PrimaryExpressionByTypeAndFollowByValue = tables.PrimaryExpressionByTypeAndFollowByValue;
    var PrimaryExpressionByValueAndFollowByType = tables.PrimaryExpressionByValueAndFollowByType;
    var SkipableToken = tables.SkipableToken;
    var SkipableTokenNoLT = tables.SkipableTokenNoLT;
    var InOrOfInsOf = tables.InOrOfInsOf;
    var InOrOf = tables.InOrOf;
    var propKeys = tables.propKeys;
    var BindingIdentifiers = tables.BindingIdentifiers;
    var ExprNoneOfs = tables.ExprNoneOfs;
    var StartBinding = tables.StartBinding;
    var WhiteSpaces = tables.WhiteSpaces;
    var LineTerminators = tables.LineTerminators;
    var Keywords = tables.Keywords;
    var IsAnyLiteral = tables.IsAnyLiteral;
    var PunctToExprName = tables.PunctToExprName;
    var BinaryOperators = tables.BinaryOperators;
    var AssignmentOperators = tables.AssignmentOperators;
    var UnaryOperators = tables.UnaryOperators;
    var UpdateOperators = tables.UpdateOperators;
    var OperatorPrecedence = tables.OperatorPrecedence;
    var UnaryOperatorPrecedence = tables.UnaryOperatorPrecedence;
    var isDirective = tables.isDirective;
    var isStrictDirective = tables.isStrictDirective;
    var isAsmDirective = tables.isAsmDirective;
    var ForbiddenArgumentsInStrict = tables.ForbiddenArgumentsInStrict;
    var ReservedWordsInStrictMode = tables.ReservedWordsInStrictMode;
    var ExprEndOfs = tables.ExprEndOfs;
    var ast;
    var ltNext;
    var ltPassedBy;
    var gotSemi;
    var tokens;
    var token = Object.create(null);
    var lkhdTok;
    var lkhdVal, lkhdTyp;
    var t; // current token type
    var v; // current token value
    var pos; // tokens[pos] pointer     (array version)
    var lookPos;
    var tokenArrayLength; // tokens.length;        (array version)
    var symtab;
    var parser = Object.create(null);


    var inStack = [];
    var isIn = true;
    var yieldStack = [];
    var isYieldId = true;
    var defaultStack = [];
    var isDefaultId = true;
    var generatorParameter = false;
    var generatorParameterStack = [];
    var isReturn = false;
    var returnStack = [];
    var strictStack = [];
    var isStrict = false;

    var currentNode;
    var nodeStack = [];
    var currentModule;
    var moduleStack = [];
    var loc = makeLoc();
    var lastloc;
    var text;
    var builder = null;
    var compile = false;
    var compiler;
    var cb;
    var notify = false;
    var stateStack = [];
    var state = "";
    var parseGoalState;
    var ContainNoSuperIn = {
        "Program" : true,
        "ModuleDeclaration": true,
        "Module" : true
    };
    var PatternName = {
        __proto__: null,
        "{": "ObjectPattern",
        "[": "ArrayPattern"
    };
    var LetOrConst = {
        __proto__: null,
        "let": true,
        "const": true
    };
    var debugmode = false;
    var hasConsole = typeof console === "object" && console != null && typeof console.log === "function";
    var hasPrint = typeof print == "function";
    var nodeId = 1;

    var withExtras = false;
    // CST withExtras. The collection is now done in the tokenizer
    // and fetched from it´s object.

    function compile(node) {
        // i replace the old compile call (with a little cost for callBuilder)
        // to have an easier interface to maintain for debugging and POC impls
        return builder.callBuilder(node);
    }


    function exchangeBuffer() {
        var b = tokenize.extraBuffer;
        tokenize.extraBuffer = [];
        return b;
    }

    function dumpExtras(node, prop, dir) {   // dumpExtras(id, "id", "before");
        var extras;
        var extraBuffer = tokenize.extraBuffer;
        if (!node || (extraBuffer && !extraBuffer.length)) return;
        if (!node.extras) node.extras = {};
        if (!node.extras[prop]) node.extras[prop] = {};
        node.extras[prop][dir] = extraBuffer;
        tokenize.extraBuffer = [];
    }
    function dumpExtras2(node, prop) {   // dumpExtras(id, "id", "before");
        var extras;
        var extraBuffer = tokenize.extraBuffer;
        if (!node || (extraBuffer && !extraBuffer.length)) return;
        if (!node.extras) node.extras = {};
        node.extras[prop] = extraBuffer;
        tokenize.extraBuffer = [];
    }

    function startLoc() {
        return loc.start;
    }
    function endLoc(node, l1) {
        node.loc = makeLoc(l1, loc.end);
    }

    function debug() {
        if (debugmode && hasConsole) {
            if (typeof arguments[0] == "object") {
                console.dir(arguments[0]);
            } else console.log.apply(console, arguments);
        }
        if (hasPrint) print.apply(null, arguments);
    }
    function debugdir() {
        if (debugmode && hasConsole) console.dir.apply(console, arguments);
    }
    function pushStrict(v) {
        strictStack.push(isStrict);
        isStrict = v;
    }
    function popStrict() {
        isStrict = strictStack.pop();
    }
    function pushState(newState) {
        stateStack.push(state);
        state = newState;
    }
    function popState() {
        state = stateStack.pop();
    }
    function pushNoIn(new_state) {
        inStack.push(isIn);
        isIn = new_state;
    }
    function popNoIn() {
        isIn = inStack.pop();
    }
    function build(node) {
        if (!compile) return node;
        var type = node.type;
        var work = builder[type];
        return work(node);
    }
    function rotate_binexps(node) {
	if (node.right) {
    	    var tmp,
            prec = OperatorPrecedence[node.operator],
            rPrec = OperatorPrecedence[node.right.operator] || Infinity;
            if (prec > rPrec) {
                tmp = node;
                node = node.right;
                tmp.right = node.left;
                node.left = tmp;
            }
        }
        return node;
    }
    function makeLoc(start, end, filename, source) {
        return {
            start: start || {},
            end: end || {},
            source: source,
            filename: filename
        };
    }
    function stringifyTokens(array) {
        var string = "";
        for (var i = 0, j = array.length; i < j; i++) {
            string += array[i].value;
        }
        return string;
    }
    function augmentErrorStack(error) {
        var stack = error.stack;
        var line = loc.start.line;
        var column = loc.start.column;
        var location = "A syntax.js parser error occured at line " + line + ", column " + column + "\r\n";
        error.stack = location;
        if (stack) error.stack += stack;
        return error;
    }
    function charExpectedString(C) {
        var line = loc.start.line;
        var column = loc.start.column;
        return C + " expected "+atLineCol();
    }
    function atLineCol() {
        var line = loc.start.line;
        var column = loc.start.column;
        return " [[value="+v+" type="+t+" lkhdVal="+lkhdVal+" at line "+line+", column "+column+"]]";
    }
    var uqrx = /^("|')|("|')$/g;
    function unquote(str) {
        return str.replace(uqrx, ""); //'
    }
    var observers = [];
    function registerObserver(f) {
        if (typeof f === "function")
            observers.push(f);
        else
            throw new TypeError("registerObserver: argument f is not a function")
    }
    function unregisterObserver(f) {
        observers = observers.filter(function (g) { return f !== g; });
    }
    function notifyObserver(observer) {
        observer(node);
    }
    function notifyObservers(node) {
        observers.forEach(notifyObserver);
        return node;
    }

    var saveBuilder = [];
    function unsetBuilder(builderObj) {
        var state;
        if (builder === builderObj) state = saveBuilder.pop();
        if (state) {
            builder = state.builder;
            compile = state.compile;
        }
    }
    function setBuilder(builderObj, boolCompile) {
        saveBuilder.push({
            builder: builder,
            compile: compile
        });
        if (typeof builderObj !== "object") {
            throw new TypeError("builderObj ist a Mozilla Parser-API compatible Builder Object for Code Generation from the AST, see http://developers.mozilla.org/en-US/docs/SpiderMonkey/Parser_API for more how to use..");
        }
        builder = builderObj;
        if (boolCompile !== undefined) compile = !!boolCompile;
        return true;
    }
    function enableExtras () {
        Object.keys(parser).forEach(function (k) {
            var f = parser[k];
            if (typeof f === "function" && !f.wrapped) {
                if (k.indexOf("JSON")===0) return;
                var originalFunction = f;
                var parseFunction = function () {
                    var b = exchangeBuffer();
                    var node = originalFunction.apply(parser, arguments);
                    if (node) {
                        if (b.length) console.dir(b);
                        node.extras = b;
                    }
                    return node;
                };
                parseFunction.wrapped = originalFunction;
                parser[k] = parseFunction;
            }
        });
    }
    function disableExtras () {
        Object.keys(parser).forEach(function (k) {
            var f = parser[k];
            if (typeof f === "function" && f.wrapped)
                parser[k] = f.wrapped;
        });
    }
    function setWithExtras(value) {
        withExtras = !!value;
    }
    function isWithExtras() {
        return !!withExtras;
    }
    function consume(i) {
        while (i > 0) { next(); i--; }
    }
    function match(C) { // match
        if (v === C) next();
        else throw new SyntaxError(charExpectedString(C));
    }
    function skip(C) {
        if (v === C) {
            next();
            return true;
        } else return false;
    }
    function semicolon() {
        if (v == ";") {
            gotSemi = true;
            next();
        } else {
            gotSemi = false;
        }
    }
    function eos() {
        return lkhdVal === undefined;
    }

    var nextToken = nextToken__array__;

    function next() {
        if (lkhdTok) {
            token = lkhdTok;
            if (token) {
                t = token.type;
                v = token.value;
                lastloc = loc;
                loc = token.loc;
                nextToken();
                return token;
            }
        }
        return token = v = t = undefined;
    }
    function nextToken__array__() {
        ltPassedBy = ltNext;
        ltNext = false;
        lookPos = pos;
        for(;;) {
            lkhdTok = tokens[++lookPos];
            if (lkhdTok === undefined) {
                lkhdVal = lkhdTyp = undefined;
                break;
            }
            lkhdTyp = lkhdTok.type;
            lkhdVal = lkhdTok.value;
            if (lkhdTyp === "LineTerminator") {
                ltNext = true;
                continue;
            }
            if (SkipableToken[lkhdTyp]) continue;
            break;
        }
        pos = lookPos;
        return lkhdTok;
    }
    function nextToken__step__() {
        ltPassedBy = ltNext;
        ltNext = false;
        lookPos = pos;
        for(;;) {
            ++lookPos;
            lkhdTok = tokenize.nextToken();
            if (lkhdTok === undefined) {
                lkhdVal = lkhdTyp = undefined;
                break;
            }
            lkhdTyp = lkhdTok.type;
            lkhdVal = lkhdTok.value;
            ltNext = tokenize.ltNext;
            if (lkhdTyp === "LineTerminator") {
                ltNext = true;
                continue;
            }
            if (SkipableToken[lkhdTyp]) continue;
            break;
        }
        pos = lookPos;
        return lkhdTok;
    }

    function Node2(type) {   // this one seems to get optimized and costs nothing more than inlined {}
        return {
            type: type,
            _id_: ++nodeId
        };
    }
    function Node(type) {
        switch(type) {
            case "Program":
                return {type:type,_id_:++nodeId,strict:undefined,body:undefined,loc:undefined,extras:undefined};
            case "Identifier":
                return {type:type,_id_:++nodeId,name:undefined,loc:undefined,extras:undefined};
            case "ParenthesizedExpression":
            case "ExpressionStatement":
                return {type:type,_id_:++nodeId,expression:undefined,loc:undefined,extras:undefined};
            case "LexicalDeclaration":
            case "VariableDeclaration":
                return {type:type,_id_:++nodeId,kind:undefined,declarations:undefined,loc:undefined,extras:undefined};
            case "VariableDeclarator":
               return {type:type,_id_:++nodeId,kind:undefined,id:undefined,init:undefined};
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "GeneratorDeclaration":
            case "GeneratorExpression":
                return {type:type,_id_:++nodeId,expression:undefined,generator:undefined,strict:undefined,id:undefined,params:undefined,body:undefined,loc:undefined,extras:undefined};
            case "ArrowExpression":
                return {type:type,_id_:++nodeId,params:undefined,body:undefined,loc:undefined,ebxtras:undefined};
            case "NumericLiteral":
            case "StringLiteral":
            case "BooleanLiteral":
            case "Literal":
                return {type:type,_id_:++nodeId,value:undefined,loc:undefined,extras:undefined}
            case "TemplateLiteral":
                return {type:type,_id_:++nodeId,spans:undefined,loc:undefined,extras:undefined}
            case "ObjectExpression":
                return {type:type,_id_:++nodeId,properties:undefined,loc:undefined,extras:undefined};
            case "ArrayExpression":
                return {type:type,_id_:++nodeId,elements:undefined,loc:undefined,extras:undefined};
            case "ObjectPattern":
            case "ArrayPattern":
                return {type:type,_id_:++nodeId,elements:undefined,loc:undefined,extras:undefined};
            case "WhileStatement":
            case "DoWhileStatement":
                return {type:type,_id_:++nodeId,test:undefined, body:undefined,loc:undefined,extras:undefined};
            case "BlockStatement":
                return {type:type,_id_:++nodeId,body:undefined,loc:undefined,extras:undefined};
            case "IfStatement":
                return {type:type,_id_:++nodeId,test:undefined,consequent:undefined,alternate:undefined,loc:undefined,extras:undefined};
            case "ConditionalExpression":
                return {type:type,_id_:++nodeId,test:undefined,consequent:undefined,alternate:undefined,loc:undefined,extras:undefined};
            case "BinaryExpression":
            case "AssignmentExpression":
                return {type:type,_id_:++nodeId,operator:undefined,left:undefined,right:undefined,loc:undefined,extras:undefined};
            case "ForInOfStatement":
                return {type:type,_id_:++nodeId,left:undefined,right:undefined,body:undefined,loc:undefined,extras:undefined};
            case "ForStatement":
                return {type:type,_id_:++nodeId,init:undefined,test:undefined,update:undefined,loc:undefined,extras:undefined};
            case "NewExpression":
                return {type:type,_id_:++nodeId, callee:undefined, arguments:undefined, loc:undefined, extras:undefined};
            case "CallExpression":
                return {type:type,_id_:++nodeId, callee:undefined, arguments:undefined, loc:undefined, extras:undefined};
            case "RestParameter":
                return {type:type,_id_:++nodeId, id:undefined, loc:undefined, extras:undefined};
            case "SpreadExpression":
                return {type:type,_id_:++nodeId, id:undefined, loc:undefined, extras:undefined};
            case "BindingPattern":
                return {type:type,_id_:++nodeId, id:undefined, target:undefined, loc:undefined, extras:undefined};
            case "ArrayComprehension":
                return {type:type,_id_:++nodeId, blocks:undefined, filter:undefined, expression:undefined, loc:undefined, extras:undefined};
            case "GeneratorComprehension":
                return {type:type,_id_:++nodeId, loc:undefined, extras:undefined};
            case "SwitchStatement":
                return {type:type,_id_:++nodeId, discriminant:undefined, cases:undefined, loc:undefined, extras:undefined};
            case "DefaultCase":
                return {type:type,_id_:++nodeId, consequent:undefined, loc:undefined, extras:undefined};
            case "SwitchCase":
                return {type:type,_id_:++nodeId, test:undefined, consequent:undefined, loc:undefined, extras:undefined};
            case "TryStatement":
                return {type:type,_id_:++nodeId, handler:undefined, guard:undefined, finalizer:undefined, loc:undefined, extras:undefined};
            case "CatchClause":
                return {type:type,_id_:++nodeId, block:undefined, loc:undefined, extras:undefined};
            case "Finally":
                return {type:type,_id_:++nodeId, block:undefined, loc:undefined, extras:undefined};
            case "Elision":
                return {type:type,_id_:++nodeId, width: undefined, loc: undefined, extras: undefined};
            default:
                return {type:type,_id_:++nodeId, loc:undefined, extras:undefined};
        }
    }

    var positions = [];
    function saveTheDot() {
        var memento = {
            ast: ast,
            loc: loc,
            tokens: tokens,
            pos: pos,
            tokenArrayLength: tokenArrayLength,
            token: token,
            t: t,
            v: v,
            nextToken: nextToken,
            lookPos: lookPos,
            lkhdTok: lkhdTok,
            lkhdVal: lkhdVal,
            lkhdTyp: lkhdTyp,
            isIn: isIn,
            inStack: inStack,
            isYieldId: isYieldId,
            isDefaultId: isDefaultId,
            yieldStack: yieldStack,
            defaultStack: defaultStack,
            symtab: symtab
            //           nodeTable: nodeTable
        };
        positions.push(memento);
        return memento;
    }
    function restoreTheDot(memento) {
        memento = memento || positions.pop();
        if (memento) {
            loc = memento.loc;
            symtab = memento.symtab;
            tokens = memento.tokens;
            pos = memento.pos;
            tokenArrayLength = memento.tokenArrayLength;
            token = memento.token;
            ast = memento.ast;
            t = memento.t;
            v = memento.v;

            nextToken = memento.nextToken;
            lookPos = memento.lookPos;
            lkhdTok = memento.lkhdTok;
            lkhdVal = memento.lkhdVal;
            lkhdTyp = memento.lkhdTyp;

            isIn = memento.isIn;
            inStack = memento.inStack;
            isYieldId = memento.isYieldId;
            isDefaultId = memento.isDefaultId;
            yieldStack = memento.yieldStack;
            defaultStack = memento.defaultStack;
            //         nodeTable = memento.nodeTable;
        }
    }
    function Literal() {
        var node;
        if (IsAnyLiteral[t]) {
            node = Node(t);
            node.longName = token.longName;
            node.value = v;
            node.computed = token.computed;
            node.loc = makeLoc(loc.start, loc.end);
            match(v);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function Identifier() {
        if (t === "Identifier" || (v === "yield" && isYieldId) || (v === "default" && isDefaultId)) {
            var node = Node("Identifier");
            node.name = v;
            node.loc = token.loc;
            match(v);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ComprehensionForList() {
        var list = [], el, binding, ae;
        while (v === "for") {
            match("for");
            match("(");
            binding = this.ForBinding();
            match("of");
            ae = this.AssignmentExpression();
            var block = Node("ComprehensionBlock");
            block.left = binding;
            block.right = ae;
            list.push(block);
            match(")");
        }
        return list.length ? list : null;
    }
    function ComprehensionFilters() {
        var list = [];
        while (v == "if") {
            match("if");
            match("(");
            list.push(this.AssignmentExpression());
            match(")");
        }
        return list.length ? list : null
    }
    function ArrayComprehension() {
        var node, blocks, filter;
        if (v === "[") {
            var l1, l2;
            l1 = loc.start;
            node = Node("ArrayComprehension");
            node.blocks = [];
            node.filter = [];
            match("[");
            while (v === "for") {
                blocks = this.ComprehensionForList();
                if (blocks) node.blocks = node.blocks.concat(blocks);
                filter = this.ComprehensionFilters();
                if (filter) node.filter = node.filter.concat(filter);
            }
            node.expression = this.AssignmentExpression();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            match("]");
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function GeneratorComprehension() {
        var node;
        if (v === "(") {
            var l1, l2;
            l1 = loc.start;
            node = Node("GeneratorComprehension");
            match("(");
            node.blocks = this.ComprehensionForList();
            node.filter = [];
            while (v == "if") {
                match("if");
                node.filter.push(this.Expression());
            }
            node.expression = this.AssignmentExpression();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function YieldAsIdentifier() {
        if (v === "yield") {
            if (isYieldId) {
                var node = Node("Identifier");
                node.name = "yield";
                node.loc = token && token.loc;
                match("yield");
                if (compile) return compiler(node);
                return node;
            }
        }
        return null;
    }
    function YieldExpression() {
        if (v === "yield" && !isYieldId) {
            match("yield");
            var node = Node("YieldExpression");
            node.argument = this.Expression();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ClassExpression() {
        if (v === "class") {
            var isExpr = true;
            var node = this.ClassDeclaration(isExpr);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function TemplateLiteral() {
        if (t === "TemplateLiteral") {
            var l1, l2;
            l1 = loc.start;
            var node = Node("TemplateLiteral");
            node.spans = v;
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            match(v);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function Elision(node) {
        if (v === ",") {
            var l1, l2;
            if (node) {
                node.width += 1;
                if (node.loc) {
                    node.loc.end = loc.end;
                }
            } else {
                node = Node("Elision");
                node.width = 1;
                l1 = loc.start;
                l2 = loc.end;
                node.loc = makeLoc(l1, l2);
            }
            match(v);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ElementList() {
        var list = [], el;
        if (v === "]") return list;
        do {
            if (v === "," && lkhdVal == ",") {
                el = null;
                do {
                    el = this.Elision(el);
                } while (v === ",");
                list.push(el);
            }
            if (v === "]") break;
            if (v === "...") el = this.SpreadExpression()
            else el = this.AssignmentExpression();
            if (el) list.push(el);
            if (v === "," && lkhdVal !== ",") match(",");
        } while (v && v !== "]");
        return list;
    }
    function ArrayExpression() {
        var node, l1, l2;
        if (v === "[") {
            l1 = loc.start;
            if (lkhdVal === "for") return this.ArrayComprehension();
            match("[");
            var node = Node("ArrayExpression");
            node.elements = this.ElementList();
            l2 = loc.end;
            match("]");
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function StrictFormalParameters() {
        return this.FormalParameterList.apply(this, arguments);
    }
    
    function ComputedPropertyName() {
        var propertyName;
        if (v === "[") {
            match("[");
            propertyName = this.AssignmentExpression();
            match("]");
            return propertyName;
        }
        return null;
    }
    function PropertyKey() {
        var node = /*this.ComputedPropertyName() ||*/ this.Identifier() || this.Literal();

        if (!node && (Keywords[v])) {
            node = Node("Identifier");
            node.name = v;
            node.loc = token && token.loc;
        }

        if (node) {
            if (compile) return compiler(node);
            return node;
        }

        throw new SyntaxError("invalid property key in definition"+atLineCol());

    }
    function PropertyDefinitionList() {
        var list = [];
        list.type = "PropertyDefinitionList";
        var id;
        var node, hasAsterisk, computedPropertyName; // p ist hier der node-name (renamen)
        var method;
        do {

            if (v == "}") break;

            if ((v === "get" || v === "set") && lkhdVal !== ":" && lkhdVal !== "(") {

                node = Node("PropertyDefinition");
                node.kind = v;
                method = this.MethodDefinition(true); // isObjectMethod = true
                if (!method) throw new SyntaxError("Error parsing MethodDefinition in ObjectExpression");
                node.key = method.id;
                node.value = method;
                list.push(node);

            } else {

                /*
                 This has to be cleaned up. I did today, and removed the double method, the double "init", the computedPropertyName,
                 and used PropertyKey() for both. It looked nice and clean. But it failed. So i restored it for now. I want to write
                 it again (from scratch), but tomorrow.
                 */

                if (v === "[") {
                    computedPropertyName = this.ComputedPropertyName();
                } else computedPropertyName = undefined;

                if (v === "*" || computedPropertyName || (BindingIdentifiers[t] || v === "constructor")) { //*[ Id

                    node = Node("PropertyDefinition");

                    if (!computedPropertyName && (lkhdVal === "," || lkhdVal === "}") && (BindingIdentifiers[t] || v === "constructor")) { // {x,y}

                        node.kind = "init";
                        id = this.PropertyKey();
                        if (!id) throw new SyntaxError("error parsing objectliteral shorthand"+atLineCol());
                        node.key = id;
                        node.value = id;
                        list.push(node);

                    } else if (computedPropertyName && v === ":") { // [s]:

                        node.kind = "init";
                        node.key = computedPropertyName;
                        node.computed = true;
                        match(":");
                        node.value = this.AssignmentExpression();
                        if (!node.value) throw new SyntaxError("error parsing objectliteral := [symbol_expr]: assignmentexpression"+atLineCol());
                        list.push(node);

                    } else if (lkhdVal === ":") { // key: AssignmentExpression

                        node.kind = "init";
                        node.key = this.PropertyKey();
                        match(":");
                        node.value = this.AssignmentExpression();
                        if (!node.value) throw new SyntaxError("error parsing objectliteral := propertykey : assignmentexpression");
                        list.push(node);

                    } else if (computedPropertyName && v == "(") {

                        node.kind = "method";
                        method = this.MethodDefinition(true, computedPropertyName);
                        if (!method) throw new SyntaxError("Error parsing method definition in ObjectExpression"+atLineCol());
                        node.key = method.id;
                        node.computed = method.computed;
                        node.value = method;
                        list.push(node);

                    } else if (((v == "[" || BindingIdentifiers[t] || v === "constructor") && lkhdVal === "(") || (v === "*" && (lkhdVal == "[" || BindingIdentifiers[lkhdTyp] || lkhdVal === "constructor"))) {

                        node.kind = "method";
                        method = this.MethodDefinition(true);
                        if (!method) throw new SyntaxError("Error parsing method definition in ObjectExpression"+atLineCol());
                        node.key = method.id;
                        node.computed = method.computed;
                        node.value = method;
                        list.push(node);
                    }
                }
            }
            computedPropertyName = undefined;

            if (v === ",") {
                match(",");
            } else break;

        } while (v !== "}" && v !== undefined);

        return list;
    }
    function ObjectExpression() {
        var node, l1, l2;
        if (v === "{") {

            l1 = loc.start;
            node = Node("ObjectExpression");
            node.properties = [];
            match("{");
            node.properties = this.PropertyDefinitionList();
            l2 = loc.end;
            match("}");
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ExpressionNoIn() {
        inStack.push(isIn);
        isIn = false;
        var node = this.Expression();
        isIn = inStack.pop();
        return node;
    }
    function CoverParenthesizedExpression(tokens) {
        return parseGoal("ParenthesizedExpression", tokens);
    }
    function ParenthesizedExpression() {
        var l1 = loc.start;
        var node = Node("ParenthesizedExpression");
        // match("(");
        node.expression = this.Expression();
        // match(")");
        var l2 = loc.end;
        node.loc = makeLoc(l1, l2);
        if (compile) return compiler(node);
        return node;
    }
    function ArrowParameterList(tokens) {
        return parseGoal("FormalParameterList", tokens);
    }
    function CoverParenthesizedExpressionAndArrowParameterList() {
        var parens = [];
        var covered = [];
        var cover = false;
        var expr, node, l1, l2;
        l1 = loc.start;
        if (t === "Identifier" && lkhdVal === "=>") {
            expr = this.Identifier();
            cover = true;
        } else if (v === "..." && lkhdTyp === "Identifier") {
            expr = this.RestParameter();
            cover = true;
        } else if (v === "(") {
            if (lkhdVal === "for") return this.GeneratorComprehension();
            cover = true;
            parens.push(v);

            while (next()) {
                if (v === "(") {
                    parens.push(v);
                } else if (v === ")") {
                    parens.pop();
                    if (!parens.length) {
                        break;
                    }
                }
                covered.push(token);
                if (v === undefined) throw new SyntaxError("no tokens left over covering expression"+atLineCol());
            }
            match(")");
        }
        if (cover) {
            if (v === "=>") {
                match("=>");
                node = Node("ArrowExpression");
                node.kind = "arrow";
                node.strict = true;
                pushStrict(true);
                node.expression = true;
                node.params = (expr ? [expr] : this.ArrowParameterList(covered));
                node.body = this.ConciseBody(node);
                l2 = loc.end;
                node.loc = makeLoc(l1, l2);
                popStrict();
                if (compile) return compiler(node);
                return node;
            } else {
                return this.CoverParenthesizedExpression(covered);
            }
        }
        return null;
    }
    function PrimaryExpression() {
        var fn, node;
        fn = PrimaryExpressionByTypeAndFollowByValue[t];
        if (fn) fn = this[fn[lkhdVal]];
        else {
            fn = PrimaryExpressionByValueAndFollowByType[v];
            if (fn) fn = this[fn[lkhdTyp]];
        }
        if (!fn) fn = this[PrimaryExpressionByValue[v]];
        if (!fn) fn = this[PrimaryExpressionByType[t]];
        if (!fn && v === "yield") {
            if (isYieldId) fn = this.YieldAsIdentifier;
            else fn = this.YieldExpression;
        }
        if (!fn && isDefaultId && v === "default") fn = this.DefaultAsIdentifier;
        if (fn) node = fn.call(this);
        if (node) return this.PostfixExpression(node);
        return null;
    }
    function MemberExpression(obj) {
        var node, l1, l2;
        if (obj = obj || this.PrimaryExpression()) {
            l1 = obj.loc && obj.loc.start;
            var node = Node("MemberExpression");
            node.object = obj;
            if (t === "TemplateLiteral") {
                return this.CallExpression(obj);
            } else if (v === "[") {
                match("[");
                node.computed = true;
                node.property = this.AssignmentExpression();
                match("]");
            } else if (v === ".") {
                match(".");
                node.computed = false;
                var property = Object.create(null);
                if (t === "Identifier" || t === "Keyword" || propKeys[v] || t === "NumericLiteral") {
                    property.type = "Identifier";
                    property.name = v;
                    property.loc = token.loc;
                    match(v);
                }
                /*else if (v === "!") {
                 match("!");
                 if (v == "[") {
                 var
                 } else if (v == "(") {
                 var args = this.Arguments();


                 } else if (t === "Identifier") {
                 property = {};
                 property.name = v;
                 }
                 property.eventual = true;
                 node.eventual = true;

                 // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency
                 // MemberExpression ! [Expression]
                 // MemberExpression ! Arguments
                 // MemberExpression ! Identifier
                 // setzt .eventual auf true
                 } */
                else {
                    throw new SyntaxError("MemberExpression . Identifier expects a valid IdentifierString or an Integer or null,true,false as PropertyKey"+atLineCol());
                }
                node.property = property;
            } else {
                return obj;
            }

            if (v == "[" || v == ".") return this.MemberExpression(node);
            else if (v == "(") return this.CallExpression(node);
            else if (IsTemplateToken[t]) return this.CallExpression(node);
            // strawman:concurrency addition
            else if (v == "!") return this.MemberExpression(node);
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function Arguments() {
        var args, arg;
        if (v === "(") {
            match("(");
            args = [];
            if (v !== ")") {
                do {
                    if (v === ")") break;

                    if (v === "...") arg = this.SpreadExpression();
                    else arg = this.AssignmentExpression();
                    if (arg)
                    args.push(arg);

                    if (v === ",") match(",");
                    else if (v != ")" && v != undefined) throw new SyntaxError("illegal argument list"+atLineCol());

                } while (v !== undefined);
            }
            match(")");
            return args;
        }
        return null;
    }
    function ConditionalExpressionNoIn(test) {
        inStack.push(isIn);
        isIn = false;
        var r = this.ConditionalExpression(test);
        isIn = inStack.pop();
        return r;
    }
    function ConditionalExpression(test) {
        if (test && v === "?") {
            var l1 = loc.start,
                l2;
            var node = Node("ConditionalExpression");
            node.test = test;
            match("?");
            node.consequent = this.AssignmentExpression();
            match(":");
            node.alternate = this.AssignmentExpression();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);

            if (node.test.type === "AssignmentExpression") {
                // Hier knallt der Compiler am Test ohne Fkt.
                var tmp = node.test;
                node.test = tmp.right;
                tmp.right = node;
                node = tmp;
            }

            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function PostfixExpression(lhs) {
        var l1 = loc.start;
        lhs = lhs || this.LeftHandSideExpression();
        if (lhs && UpdateOperators[v]) {
            var node = Node("UnaryExpression");
            node.operator = v;
            node.prefix = false;
            node.argument = lhs;
            node.loc = makeLoc(l1, loc.end);
            match(v);
            if (compile) return compiler(node);
            return node;
        }
        return lhs;
    }
    function UnaryExpression() {
        if (UnaryOperators[v] || UpdateOperators[v]) {
            var l1 = loc.start;
            var node = Node("UnaryExpression");
            node.operator = v;
            node.prefix = true;
            match(v);
            if (UnaryOperators[v]) node.argument = this.UnaryExpression();
            else node.argument = this.PostfixExpression();
            var l2 = loc.end;
            if (node.argument == null) throw new SyntaxError("invalid unary expression "+node.operator+", operand missing " + atLineCol());
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return this.PostfixExpression();
    }
    function AssignmentExpressionNoIn() {
        inStack.push(isIn);
        isIn = false;
        var node = this.AssignmentExpression();
        isIn = inStack.pop();
        return node;
    }
    function StartAssignmentExpressionNoIn() {
        inStack.push(isIn);
        isIn = false;
        var node = this.StartAssignmentExpression();
        isIn = inStack.pop();
        return node;
    }

    function StartAssignmentExpression() {
        var node = null, leftHand, l1, l2;
        l1 = loc.start;
        leftHand = this.LeftHandSideExpression();
        if (AssignmentOperators[v] && (isIn || (!isIn && v != "in"))) {
            var node = Node("AssignmentExpression");
            node.longName = PunctToExprName[v];
            node.operator = v;
            node.left = leftHand;
            match(v);
            node.right = this.StartAssignmentExpression();
            if (!node.right) throw new SyntaxError("can not parse a valid righthandside for this assignment expression"+atLineCol());
            var l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            node = rotate_binexps(node);
        } else if (BinaryOperators[v] && (isIn || (!isIn && v != "in"))) {
            var node = Node("BinaryExpression");
            node.longName = PunctToExprName[v];
            node.operator = v;
            node.left = leftHand;
            match(v);
            node.right = this.StartAssignmentExpression();
            if (!node.right) {
                throw new SyntaxError("can not parse a valid righthandside for this binary expression "+atLineCol());
            }
            var l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            node = rotate_binexps(node);
        }
        else return leftHand;
        if (compile) return compiler(node);
        return node;
    }
    function AssignmentExpression() {
        var node = this.StartAssignmentExpression();
        if (v == "?") return this.ConditionalExpressionNoIn(node);
        return node;
    }
    function CallExpression(callee) {
        var node, l1, l2;
        l1 = l2 = (loc.start);
        if (callee = (callee||this.MemberExpression())) {
            l1 = callee.loc && callee.loc.start;
            node = Node("CallExpression");
            node.callee = callee;
            node.arguments = null;
            if (t === "TemplateLiteral") {
                var template = this.TemplateLiteral();
                node.arguments = [ template ];
                l2 = loc.end;
                node.loc = makeLoc(l1, l2);
                // if (compile) return builder.callExpression(node.callee, node.arguments, node.loc);
                return node;
            } else if (v === "(") {
                node.arguments = this.Arguments();
                if (v === "(") {
                    // ..()()()
                    l2 = loc.end;
                    node.loc = makeLoc(l1, l2);
                    return this.CallExpression(node);
                } else if (v === "[" || v == ".") {
                    // .. [][][]
                    l2 = loc.end;
                    node.loc = makeLoc(l1, l2);
                    return this.MemberExpression(node);
                } else {
                    l2 = loc.end;
                    node.loc = makeLoc(l1, l2);
                    if (compile) return compiler(node);
                    return node;
                }
            } else {
                return callee;
            }
        }
        return null;
    }
    function NewExpression() {
        var node, l1, l2;
        if (v === "new") {
            l1 = loc.start;
            l2 = loc.end;
            node = Node("NewExpression");
            match("new");
            if (v === "new") node.callee = this.NewExpression();
            else {
                var callee = this.CallExpression();
                if (callee && callee.type === "CallExpression") {
                    node = callee;
                    node.type = "NewExpression";
                } else if (!callee) {
                    throw new SyntaxError("NewExpression: can not identify callee");
                } else {
                    node.callee = callee;
                }
            }
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function LeftHandSideExpression(callee) {
        return this.NewExpression(callee) || this.CallExpression(callee);
    }
    function ExpressionStatement() {
        if (!ExprNoneOfs[v] && !(v === "let" && lkhdVal=="[")) {
            var expression = this.Expression();
            if (!expression) return null;
            var node = Node("ExpressionStatement");
            node.expression = expression;
            node.loc = expression.loc;
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function SequenceExpressionNode(list, l1, l2) {
        var node = Node("SequenceExpression");
        node.sequence = list;
        node.loc = makeLoc(l1, l2);
        if (compile) return compiler(node);
        return node;
    }
    function Expression() {
        var list = [];
        var node;
        var ae;
        var l1 = loc.start;
        var l2;
        if (ExprEndOfs[v]) return null;

        while (v != undefined) {
            if (ae = this.AssignmentExpression()) list.push(ae);
            if (v === ",") match(",");
            else break;
        }
        l2 = loc.end;
        switch (list.length) {
            case 0: return null;
            case 1: return list[0];
            default: return this.SequenceExpressionNode(list, l1, l2);
        }
    }
    function SuperExpression() {
        if (v === "super") {
            var l1 = loc.start;
            var node = Node("SuperExpression");
            node.loc = makeLoc(l1, l1);
            if (withExtras && tokenize.extraBuffer.length) dumpExtras2(node, "before");
            match("super");
            if (withExtras && tokenize.extraBuffer.length) dumpExtras2(node, "after");
            if (currentNode) {
                if (ContainNoSuperIn[currentNode.type]) {
                    throw new SyntaxError("contains: super is not allowed in "+currentNode.type);
                }
                currentNode.needsSuper = true;
            }
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ThisExpression() {
        if (v === "this") {
            var l1 = loc.start;
            var node = Node("ThisExpression");
            node.loc = makeLoc(l1, l1);
            if (withExtras && tokenize.extraBuffer.length) dumpExtras2(node, "before");
            match("this");
            if (withExtras && tokenize.extraBuffer.length) dumpExtras2(node, "after");
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function Initializer() {
        if (v === "=") {
            match("=");
            return this.AssignmentExpression();
        }
        return null;
    }
    function BindingElementList() {
        var list = [];
        var id, bindEl, l1, l2;
        if (v === "{") {
            match("{");
            while (v != "}") {
                // iif (StartBinding[v]) id = this.BindingPattern();

                id = this.Identifier();

                if (v === ":") {
                    l1 = id.loc && id.loc.start;
                    bindEl = Node("BindingElement");
                    bindEl.id = id;
                    match(":");
                    if (StartBinding[v]) bindEl.target = this.BindingPattern();
                    else bindEl.target = this.LeftHandSideExpression();
                    if (bindEl.target.type === "Identifier") {
                        if (isStrict && ForbiddenArgumentsInStrict[bindEl.target.name]) {
                            throw new SyntaxError(bindEl.target.name + " is not a valid binding identifier in strict mode");
                        }
                    }
                    l2 = loc.end;
                    bindEl.loc = makeLoc(l1, l2);
                    list.push(bindEl);
                    if (v === "=") {
                        bindEl.init = this.Initializer();
                    }
                } else {
                    if (isStrict && ForbiddenArgumentsInStrict[id.name]) {
                        throw new SyntaxError(v + " is not a valid binding identifier in strict mode");
                    }
                    list.push(id);
                    if (v === "=") {
                        id.init = this.Initializer();
                    }
                }
                if (v === ",") {
                    match(",");
                    if (v === "}") break;
                    continue;

                } else if (v != "}") {
                    throw new SyntaxError("invalid binding property list. csv and terminating }");
                }
            }
            match("}");
        } else if (v === "[") {
            match("[");
            while (v !== "]") {
                switch(v) {
                    case "...":
                        id = this.RestParameter();
                        break;
                    case "{":
                    case "[":
                        id = this.BindingPattern();
                        break;
                    default:
                        id = this.Identifier();
                        break;
                }
                if (id) list.push(id);
                if (v === "=") {
                    id.init = this.Initializer();
                }
                if (v === ",") {
                    match(",");
                    if (v === "]") break;
                    continue;
                } else if (v !== "]") {
                    throw new SyntaxError("invalid binding element list. csv and terminating ]");
                }
            }
            match("]");
        }
        return list;
    }
    function BindingPattern() {
        var node, l1, l2;
        if (StartBinding[v]) {
            l1 = loc.start;
            node = Node(PatternName[v]);
            node.elements = this.BindingElementList();
            if (v === "=") node.init = this.Initializer();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function VariableDeclaration(kind) {
        var node = this.BindingPattern();
        if (node) {
            node.kind = kind;
            return node;
        }
        if (t === "Identifier" || (v === "yield" && isYieldId) || (v === "default" && isDefaultId)) {
            node = Node("VariableDeclarator");
            node.kind = kind;
            var id = this.Identifier();
            node.id = id;

            var name = id.name;
            if (isStrict && (ReservedWordsInStrictMode[name] || ForbiddenArgumentsInStrict[name])) {
                throw new SyntaxError(name + " is not a valid identifier in strict mode");
            }

            // throws error on duplicate identifier
            if (kind === "var") symtab.putVar(node);
            else symtab.putLex(node);

            if (v === "=") node.init = this.Initializer();
            else node.init = null;
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function VariableDeclarationList(kind) {
        var list = [];
        var decl;
        for (;;) {
            decl = this.VariableDeclaration(kind);
            if (decl) list.push(decl);
            else throw new SyntaxError(kind + " declaration expected");
            if (!isIn && InOrOf[v]) break;
            if (v === ",") {
                match(",");
                continue;
            } else if (v === ";") {
                match(";");
                break;
            } else break;
            // else throw new SyntaxError("illegal "+v+" after "+kind);
        }
        if (!list.length) throw new SyntaxError("expecting identifier names after "+kind);
        return list;
    }
    function VariableStatement() {
        var node, decl, l1, l2;
        if (v === "var" || v === "let" || v === "const") {

            if (v == "const" && lkhdVal == "class") {
                match("const");
                return this.ConstClassDeclaration();
            }

            l1 = loc.start;
            node = Node("VariableDeclaration");
            node.declarations = [];
            node.kind = v;
            if (v !== "var") node.type = "LexicalDeclaration";
            match(v);
            node.declarations = this.VariableDeclarationList(node.kind);
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function VariableStatementNoIn() {
        inStack.push(isIn);
        isIn = false;
        var node = this.VariableStatement();
        isIn = inStack.pop();
        return node;
    }


    function ConstClassDeclaration() {
        return this.ClassDeclaration(false, true);
    }

    function ClassDeclaration(isExpr, isConst) {
        var node, m;
        if (v === "class") {
            //pushDecls();
            node = Node("ClassDeclaration");
            node.id = null;
            node.strict = true;
            node.expression = !! isExpr;
            if (isConst) node.const = true;
            node.extends = null;
            node.elements = [];
            
            pushStrict(true);
            
            match("class");
            var id = this.Identifier();
            node.id = id.name;
            if (v === "extends") {
                match("extends");
                node.extends = this.AssignmentExpression();
            }
            match("{");
            while (v !== "}") {
                m = this.MethodDefinition();
                node.elements.push(m);
            }
            match("}");
            
            popStrict();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function MethodDefinition(isObjectMethod, computedPropertyName) {
        var l1, l2;
        var node;

        var isStaticMethod = false;
        var isGenerator = false;
        var isGetter = false;
        var isSetter = false;
        var specialMethod = false;
        
        
        if (v === "}") return null; // end of the class body, or the object body

        l1 = loc.start;

        if (v === ";") {
            if (!isObjectMethod) match(";");
            else throw new SyntaxError("invalid ; in object literal");
        }
        
        
        if (v === "static") {
            if (!isObjectMethod) {
                isStaticMethod = true;
                match(v);
            } else throw new SyntaxError("static is not allowed in objects");
        }

        
        if (v === "*") {
            isGenerator = true;
            match(v);
        } else if (v === "get") {
            isGetter = true;
            match(v);
            // get c() {}
        } else if (v === "set") {
            isSetter = true;
            match(v);
            // set c() {}
        }


        node = Node("MethodDefinition");
        
        nodeStack.push(currentNode);
        currentNode = node;


        if (computedPropertyName) {
    	    node.id = computedPropertyName;
    	    node.computed = true;
        } else if (v =="[") {
    	    node.id = this.ComputedPropertyName();
    	    node.computed = true;
    	} else {
    	    node.id = this.PropertyKey();
	}
    	
        if (isStrict && ForbiddenArgumentsInStrict[node.id.name]) throw new SyntaxError(node.id.name + " is not a valid method identifier in strict mode");
        node.generator = isGenerator;
        if (!isObjectMethod) node.static = isStaticMethod;
        
        if (isGetter) node.kind = "get";
        else if (isSetter) node.kind = "set";

        match("(");
        node.params = this.FormalParameterList();
        match(")");
        match("{");
        node.body = this.FunctionBody(node);
        match("}");

        l2 = loc.end;
        node.loc = makeLoc(l1, l2);
        currentNode = nodeStack.pop();

        if (compile) return compiler(node);
        return node;

    }
    function RestParameter() {
        if (v === "...") {
            var l1 = loc.start;
            match("...");
            var node = Node("RestParameter");
            node.id = v;
            if (t !== "Identifier") {
                throw new SyntaxError("invalid rest parameter, identifier expected");
            }
            if (isStrict && ForbiddenArgumentsInStrict[v]) {
                throw new SyntaxError(v + " is not a valid rest identifier in strict mode");
            }
            match(v);
            var l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function SpreadExpression() {
        if (v === "...") {
            var l1 = loc.start;
            match("...");
            var node = Node("SpreadExpression");
            node.argument = this.AssignmentExpression();
            var l2 = node.argument && node.argument.loc && node.argument.loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function DefaultParameter() { // ES6
        var node;
        if (t == "Identifier" && lkhdVal == "=") {
            var l1 = loc.start;
            node = Node("DefaultParameter");
            var id = this.Identifier();
            node.id = id.name;
            match("=");
            node.init = this.AssignmentExpression();
            node.loc = makeLoc(l1, loc.end);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function FormalParameterList() {
        var list = [];
        list.type = "FormalParameterList";
        var id;
        if (v && v != ")")
            do {
                if (v === "...") {
                    id = this.RestParameter();
                    list.push(id);
                } else if (StartBinding[v]) {
                    id = this.BindingPattern();
                    list.push(id);
                } else if (t === "Identifier") {
                    if (lkhdVal == "=") {
                        id = this.DefaultParameter();
                    } else {
                        id = this.Identifier();
                    }
                    if (isStrict && ForbiddenArgumentsInStrict[id.name]) {
                        throw new SyntaxError(id.name + " is not allowed in strict mode");
                    }
                    list.push(id);
                }
                if (v === ",") {
                    match(",");
                } else if (v !== undefined && v !== ")") {
                    throw new SyntaxError("error parsing formal parameter list "+atLineCol());
                }
            } while (v !== undefined && v !== ")");
        return list;
    }
    function FunctionDeclaration(isExpr) {
        var node, start, end, sourceStart, sourceEnd;
        if (v === "function") {
            defaultStack.push(isDefaultId);
            isDefaultId = true;
            start = loc.start;
            match("function");
            if (v === "*") {
                node = Node("GeneratorDeclaration");
                node.generator = true; // i am a legacy man :) (otherwise my node.type is violating the parser api)
                match("*");
            } else {
                node = Node("FunctionDeclaration");
                node.generator = false;
            }
            nodeStack.push(currentNode);
            currentNode = node;
            node.id = null;
            node.params = [];
            node.expression = !!isExpr;
            node.strict = isStrict;
            node.body = [];
            var id;
            if (v !== "(") {
                id = this.Identifier();
                node.id = id.name;
            } else {
                if (!node.expression) {
                    throw new SyntaxError("Function and Generator Declarations must have a name [only expressions can be anonymous]");
                }
            }
            symtab.newScope();
            match("(");
            node.params = this.FormalParameterList();
            match(")");
            if (!node.generator) {
                yieldStack.push(isYieldId);
                isYieldId = true;
            } else {
                yieldStack.push(isYieldId);
                isYieldId = false;
                node.strict = true;
            }
            //pushDecls();
            match("{");
            node.body = this.FunctionBody(node);
            match("}");
            //popDecls(node);
            isYieldId = yieldStack.pop();
            end = loc.end;
            node.loc = makeLoc(start, end);
            if (node.generator) {
                node.nodesById = CreateTablePlusAddParentPointerIds(node);
            }
            isDefaultId = defaultStack.pop();
            currentNode = nodeStack.pop();
            symtab.oldScope();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function FunctionExpression() {
        return this.FunctionDeclaration(true);
    }
    function GeneratorBody(parent) {
        yieldStack.push(isYieldId);
        isYieldId = false;
        var body = this.FunctionBody(parent);
        isYieldId = yieldStack.pop();
        return body;
    }
    function FunctionBody(parent) {
        var contains = Contains["FunctionDeclaration"];
        var node;
        var body = [];
        body.type = "FunctionStatementList";
        if (v === "}") return body;
        pushStrict(this.DirectivePrologue(parent, body) || isStrict);
        while (v !== undefined && v !== "}") {
            switch (v) {
                case "function": node = this.FunctionDeclaration(); break;
                case "module": node = this.ModuleDeclaration(); break;
                case "class": node = this.ClassDeclaration(); break;
                default: node = this.Statement(); break;
            }
            if (node) {
                if (!contains[node.type]) body.push(node);
                else throw new SyntaxError("contains: "+node.type+" is not allowed in a functionBody");
            }
        }
        popStrict();
        return body;
    }
    function ConciseBody(parent) {
        if (v == "{") {
            var body;
            yieldStack.push(isYieldId);
            isYieldId = true;
            match("{");
            body = this.FunctionBody(parent);
            match("}");
            isYieldId = yieldStack.pop();
            return body;
        }
        return this.AssignmentExpression();
    }
    function CreateTablePlusAddParentPointerIds (node, parent, nodeTable) {
        nodeTable = nodeTable || Object.create(null);
        if (Array.isArray(node)) {
            for (var i = 0, j = node.length; i < j; i++) {
                CreateTablePlusAddParentPointerIds(node[i], parent, nodeTable);
            }
            return nodeTable;
        }
        else if (typeof node === "object" && node != null && node.loc) {
            if (parent) {
                node.parent = parent["_id_"];
                nodeTable["_id_"] = parent;
            }
            Object.keys(node).forEach(function (key) {
                if (typeof node[key] != "object" || !node || key === "parent" || key === "loc" || key == "extras") return;
                CreateTablePlusAddParentPointerIds(node[key], node, nodeTable);
            });
        }
        return nodeTable;
    }
    function AddParentPointers(node, parent) {
        var n;
        if (Array.isArray(node)) {
            for (var i = 0, j = node.length; i < j; i++) {
                AddParentPointers(node[i], parent);
            }
        } else {
            for (var k in node) {
                if (Object.hasOwnProperty.call(node, k)) {
                    n = node[k];
                    if (n && typeof n === "object") {
                        if (n.type || Array.isArray(n)) AddParentPointers(n, node);
                    }
                }
            }
            if (node && parent) node.parent = parent;
        }
    }
    function BlockStatement() {
        if (v === "{") {
            symtab.newBlock();
            var l1, l2;
            l1 = loc.start;
            var node = Node("BlockStatement");
            defaultStack.push(isDefaultId);
            isDefaultId = true;
            //pushLexOnly();
            match("{");
            node.body = this.StatementList();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            isDefaultId = defaultStack.pop();
            match("}");
            symtab.oldBlock();
            //popLexOnly(node);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function BreakStatement() {
        if (v === "break") {
            var node, l1, l2;
            l1 = loc.start;
            node = Node("BreakStatement");
            match("break");
            if (v !== ";") {
                if (ltPassedBy) {
                    l2 = loc.start;
                    node.loc = makeLoc(l1,l2);
                    return node;

                }
                if (t === "Identifier") {
                    var id = this.Identifier();
                    node.label = id.name;
                }
            }
            semicolon();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null; 
    }
    function ContinueStatement() {
        var node, l1, l2;
        if (v === "continue") {
            node = Node("ContinueStatement");
            l1 = loc.start;
            match("continue");
            if (v !== ";") {
                if (ltPassedBy) {
                    l2 = loc.start;
                    node.loc = makeLoc(l1,l2);
                    return node;
                }
                if (t === "Identifier") {
                    var id = this.Identifier();
                    node.label = id.name;
                }
            }
            semicolon();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
    }
    function ReturnStatement() {
        var node, l1, l2;
        if (v === "return") {
            l1 = loc.start;
            node = Node("ReturnStatement");
            if (withExtras && tokenize.extraBuffer.length) dumpExtras2(node, "before");
            match("return");
            if (withExtras && tokenize.extraBuffer.length) dumpExtras2(node, "after");
            if (v !== ";") {
                if (ltPassedBy) {
                    l2 = loc.end;
                    node.loc = makeLoc(l1, l2);
                    return node;
                }
                node.argument = this.Expression();
            }
            semicolon();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ThrowStatement() {
        if (v === "throw") {
            var node, l1, l2;
            node = Node("ThrowStatement");
            l1 = loc.start;
            match("throw");
            if (v !== ";") {
                if (ltPassedBy) {
                    l2 = loc.end;
                    node.loc = makeLoc(l1, l2);
                    return node;
                }
                else node.argument = this.Expression();
            } else semicolon();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function LabelledStatement() {
        if (t === "Identifier" && lkhdVal === ":") {
            var node = Node("LabelledStatement");
            var l1 = loc.start;
            var label = this.Identifier();
            node.label = label.name;
            match(":");
            var stmt = this.Statement();
            if (!IsIteration[stmt.type]) {
                throw new SyntaxError("A LabelledStatement must be an Iteration Statement");
            }
            node.statement = stmt;
            var l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function TryStatement() {
        if (v === "try") {
            var node = Node("TryStatement");
            var l1, l2;
            l1 = loc.start;
            match("try");
            node.handler = this.Statement();
            if (v === "catch") node.guard = this.Catch();
            if (v === "finally") node.finalizer = this.Finally();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function Catch() {
        if (v === "catch") {
            var node, l1, l2;
            node = Node("CatchClause");
            l1 = loc.start;
            match("catch");
            match("(");
            node.params = this.FormalParameterList();
            match(")");
            node.block = this.Statement();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function Finally() {
        if (v === "finally") {
            var node, l1, l2;
            l1 = loc.start;
            var node = Node("Finally");
            match("finally");
            node.block = this.Statement();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function WithStatement() {
        if (v === "with") {
            if (isStrict) {
                throw new SyntaxError("with not allowed in strict mode" + atLineCol());
            }
            var node = Node("WithStatement");
            var l1 = loc.start;
            if (withExtras) dumpExtras(node, "with", "before");
            match("with");
            if (withExtras) dumpExtras(node, "with", "after");
            match("(");
            node.object = this.Expression();
            match(")");
            node.body = this.BlockStatement();
            var l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function DebuggerStatement() {
        if (v === "debugger") {
            var node, l1, l2;
            node = Node("DebuggerStatement");
            l1 = loc.start;
            match("debugger");
            semicolon();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ModuleDeclaration() {
        if (v === "module") {
            var node, l1, l2;
            l1 = loc.start;
            //pushDecls();
            symtab.newScope();
            node = Node("ModuleDeclaration");
            node.strict = true;
            nodeStack.push(currentNode);
            moduleStack.push(currentModule);
            currentNode = currentModule = node;
            node.exportEntries = [];
            node.knownExports = [];
            node.unknownExports = [];
            node.knownImports = [];
            node.unknownImports = [];
            node.moduleRequests = [];
            match("module");
            node.id = this.ModuleSpecifier();
            node.body = this.ModuleBody(node);
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            //popDecls(node);
            // EarlyErrors(node);
            currentNode = nodeStack.pop();
            currentModule =  moduleStack.pop();
            symtab.oldScope();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ModuleSpecifier() {
        if (t === "StringLiteral") {
            var specifier = v.slice(1, v.length - 1);
            match(v);
            return specifier;
        }
        throw new SyntaxError("can not make out ModuleSpecifier");
    }
    function ModuleBody() {
        var list = [];
        match("{");
        var item;
        while (v !== undefined && v !== "}") {
            switch (v) {
                case "export": item = this.ExportStatement();
                    break;
                case "module": item = this.ModuleDeclaration();
                    break;
                case "import": item = this.ImportStatement();
                    break;
                default:
                    item = this.Statement();
                    break;
            }
            if (item) {
                if (!Contains.ModuleDeclaration[item.type]) list.push(item);
                else throw new SyntaxError("contains: "+item.type+" not allowed in ModuleDeclarations" + atLineCol());
            }
        }
        match("}");
        return list;
    }
    function FromClause() {
        match("from");
        var frm = this.ModuleSpecifier();
        return frm;
    }
    function ImportClause() {
        var node = Node("ImportClause");
        var id = this.Identifier();
        node.id = id;
        if (id) {
            if (v === ",") {
                match(v);
                var node2 = this.NamedImports();
                node.named = node2;
            }
        }
        if (compile) return compiler(node);
        return node;
    }
    function NamedImports() {
        if (v === "{") {
            var list = [];
            while (v && v !== "}") {
                var node = Node("ImportSpecifier");
                node.id = this.Identifier();
                if (v === "as") {
                    match("as");
                    node.target = this.Identifier();
                }
                list.push(node);
                if (v === ",") {
                    match(",");

                } else {
                    throw new SyntaxError("BindingElement did not terminate with a , or }" + atLineCol());
                }
            }
            return list;
        }
        return null;
    }
    function ImportStatement() {
        if (v === "import") {
            var l1 = loc.start;
            var l2;
            var node = Node("ImportStatement");
            match("import");
            var list = node.imports = [];
            var imp;
            if (v === "module") {
                if (ltNext) return null;
                node.module = true;
                node.id = this.Identifier();
            } else {
                while (v !== "from") {
                    if (v === "{") {
                        imp = this.ImportClause();
                        if (imp) list.push(imp);
                    } else if (t = "Identifier") {
                        imp = this.Identifier();
                        if (imp) list.push(imp);
                    } else if (v === ",") {
                        match(",");
                    } else if (v !== "from") {
                        throw new SyntaxError("invalid import statement" + atLineCol());
                    }
                }
            }
            node.from = this.FromClause();
            semicolon();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ExportsClause() {
        if (v === "{") {
            var list = [];
            while (v && v !== "}") {
                var node = Node("ExportsSpecifier");
                node.id = this.Identifier();
                if (v === "as") {
                    match("as");
                    node.target = this.Identifier();
                }
                currentNode.moduleRequests.push(node);
                list.push(node);
                if (v === ",") {
                    match(",");
                } else {
                    throw new SyntaxError("BindingElement did not terminate with a , or }" + atLineCol());
                }
            }
            return list;
        }
        return null;
    }
    function DeclarationDefault() {
        defaultStack.push(isDefaultId);
        isDefaultId = true;
        var node = this.FunctionDeclaration();
        isDefaultId = defaultStack.pop();
        return node;
    }
    function ExportStatement() {
        if (v === "export") {
            var l1 = loc.start;
            var l2;
            var node = Node("ExportStatement");
            match("export");
            if (v === "default") {
                match("default");
                node.default = true;
                node.exports = this.AssignmentExpression();
            } else if (v === "*") {
                node.all = true;
                match(v);
                node.from = this.FromClause();
            } else {
                node.exports = this.ExportsClause();
                if (node.exports) node.from = this.FromClause();
                else node.exports = this.VariableStatement() || this.DeclarationDefault();
                var names = BoundNames(node.exports);
                for (var i = 0, j = names.length; i < j; i++) {
                    var name = names[i];
                    currentModule.exportEntries.push({ ModuleRequest: null, ImportName: null, LocalName: name, ExportName: name });
                }
                if (!node.exports) throw new SyntaxError("should be an error in the export statement");
            }
            l2 = loc.end;
            makeLoc(l1, l2);
            semicolon();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function SwitchStatementList() {
        var list = [];
        list.type = "StatementList";
        list.switch = true;
        var s;
        if (v)
            do {
                list.push(this.Statement());
            } while (!FinishSwitchStatementList[v] && v != undefined );
        return list;
    }
    function StatementList() {
        var list = [];
        list.type = "StatementList";
        var s;
        if (v)
            do {
                list.push(this.Statement());
            } while (!FinishStatementList[v] && v != undefined);
        return list;
    }
    function Statement() {
        var node;
        var fn = this[StatementParsers[v]];
        if (fn) node = fn.call(this);
        if (!node) {
            if (t === "Identifier" && lkhdVal == ":") node = this.LabelledStatement();
            else node = this.ExpressionStatement();
        }


        if (!node && (v === "function")) {
            if (isStrict)
            throw new SyntaxError("FunctionDeclarations are not allowed outside of the Top-Level in strict mode");
            else node = this.FunctionDeclaration();
        }


        semicolon();
        if (compile) return compiler(node);
        return node;
    }
    function IterationStatement() {
        if (v === "for") return this.ForStatement();
        if (v === "do") return this.DoWhileStatement();
        if (v === "while") return this.WhileStatement();
        return null;
    }
    function ForDeclaration() {
        var node;
        if (LetOrConst[v]) {
            var l1 = loc.start;
            var l2;
            node = Node("ForDeclaration");
            node.kind = v;
            match(v);
            node.id = this.ForBinding();
            l2 = loc.end;
            node.loc = makeLoc(l1,l2);
            if (v != "in" && v != "of") {
                throw new SyntaxError("invalid token '"+v+"' after let or const declaration at the for statement "+atLineCol() );
            }
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function ForBinding() {
        switch (v) {
            case "{":
            case "[":
                return this.BindingPattern();
            default:
                return this.Identifier();
        }
        return null;
    }
    function ForStatementHead() {
        var node = Node("ForStatement");
        if (v === ";") {
            node.init = null;
            match(";");
        } else {
            if (v === "var") {
                node.init = this.VariableStatementNoIn();
            } else if (LetOrConst[v]) {
                node.init = this.VariableStatementNoIn();
            } else {
                node.init = this.ExpressionNoIn();
                match(";")
            }
        }
        if (v === ";") {
            node.test = null;
            match(";");
        } else {
            node.test = this.Expression();
            match(";");
        }
        if (v === ")") node.update = null;
        else node.update = this.Expression();
        return node;
    }
    function ForInOfStatementHead() {
        var node = Node("ForInOfStatement");
        if (v === "var") {
            match("var");
            node.left = this.ForBinding();
        } else if (LetOrConst[v]) {
            node.left = this.ForDeclaration();
        } else {
            node.left = this.LeftHandSideExpression();
        }
        if (!node.left) throw new SyntaxError("can not parse a valid lefthandside expression for for statement");
        if (v === "in") {
            node.type = "ForInStatement";
            match("in");
            node.right = this.Expression();
        } else if (v === "of") {
            node.type = "ForOfStatement";
            match("of");
            node.right = this.AssignmentExpression();
        } else {
            throw new SyntaxError("in or of expected "+atLineCol());
        }
        if (!node.right) throw new SyntaxError("can not parse a valid righthandside expression for for statement");
        return node;
    }
    function ForStatement() {
        var node;
        var statement;
        var parens = [];
        var peek;
        var numSemi = 0;
        var hasInOf = false;
        var l1, l2;
        if (v === "for") {
            l1 = loc.start;
            match("for");
            match("(");
            /* predict */
            parens.push("(");
            var collected = [];
            loop:
                for (;;) {
                    peek = token && token.value;
                    switch(peek) {
                        case ";": numSemi += 1;
                            break;
                        case "in":
                        case "of":
                            hasInOf = peek;
                            break;
                        case "(":
                            parens.push("(");
                            break;
                        case ")":
                            parens.pop();
                            if (!parens.length) break loop;
                            break;
                        case undefined:
                            throw new SyntaxError("unexpeceted end of token stream");
                            break;
                    }
                    collected.push(token);
                    next();
                }
            /* parse */
            if (numSemi === 2) {
                node = parseGoal("ForStatementHead", collected);
            } else if (numSemi === 0 && hasInOf) {
                node = parseGoal("ForInOfStatementHead", collected);
            } else {
                throw new SyntaxError("invalid syntax in for statement");
            }
            match(")");
            node.body = this.Statement();
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function IfStatement() {
        if (v === "if") {
            var node = Node("IfStatement");
            match("if");
            match("(");
            node.test = this.Expression();
            match(")");
            node.consequent = this.Statement();
            if (v === "else") {
                match("else");
                node.alternate = this.Statement();
            }
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function WhileStatement() {
        if (v === "while") {
            var l1, l2;
            l1 = loc.start;
            var node = Node("WhileStatement");
            match("while");
            match("(");
            node.test = this.Expression();
            match(")");
            node.body = this.Statement();
            l2 = loc.end;
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function DoWhileStatement() {
        if (v === "do") {
            var l1, l2;
            l1 = loc.start;
            var node = Node("DoWhileStatement");
            match("do");
            node.body = this.Statement();
            match("while");
            match("(");
            node.test = this.Expression();
            match(")");
            l2 = loc.end;
            semicolon();
            node.loc = makeLoc(l1, l2);
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function SwitchStatement() {
        if (v === "switch") {
            defaultStack.push(isDefaultId);
            isDefaultId = false;
            var c;
            var node = Node("SwitchStatement");
            var l1 = loc.start;
            var l2;
            match("switch");
            match("(");
            node.discriminant = this.Expression();
            match(")");
            match("{");
            var cases = node.cases = [];
            while (v !== "}") {
                switch (v) {
                    case "case": cases.push(this.SwitchCase()); break;
                    case "default": cases.push(this.DefaultCase()); break;
                    default:
                        throw new SyntaxError("invalid statment in switch")
                }
            }
            match("}");
            l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            isDefaultId = defaultStack.pop();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function DefaultCase() {
        if (v === "default" && lkhdVal === ":") {
            var node = Node("DefaultCase");
            match("default");
            match(":");
            node.consequent = this.SwitchStatementList();
            semicolon();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function SwitchCase() {
        if (v === "case") {
            var node = Node("SwitchCase");
            match("case");
            node.test = this.Expression();
            match(":");
            node.consequent = this.SwitchStatementList();
            semicolon();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function EmptyStatement() {
        var node;
        if (v === ";") {
            node = Node("EmptyStatement");
            node.loc = makeLoc(loc.start, loc.end);
        //  dumpExtras2(node, "before");
            match(";");
         //   dumpExtras2(node, "after");
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function DirectivePrologue(containingNode, nodes) {
        var strict = false;
        while (t === "StringLiteral" && isDirective[v]) {
            if (isStrictDirective[v]) strict = containingNode.strict = true;
            else if (isAsmDirective[v]) containingNode.asm = true;
            var l1 = loc.start;
            var node = Node("Directive");
            node.value = v;
            match(v);
            var l2 = loc.end;
            node.loc = makeLoc(l1, l2);
            semicolon();
            if (compile) node = compiler(node);
            nodes.push(node);
        }
        return strict;
    }
    function SourceElements(program) {
        var body = [];
        var node;
        pushStrict(this.DirectivePrologue(program, body));
        var contains = Contains["Program"];
        do {
            switch (v) {
                case "function": node = this.FunctionDeclaration(); break;
                case "class": node = this.ClassDeclaration(); break;
                case "module": node = this.ModuleDeclaration(); break;
                default: node = this.Statement(); break;
            }
            if (node) {
                if (!contains[node.type]) body.push(node);
                else throw new SyntaxError("contains: "+node.type+" is not allowed in Program");
            } else {
                if (token != undefined)
                    throw new SyntaxError("unexpected token " + t + " with value " +v);
            }
        } while (token != undefined);
        popStrict();
        return body;
    }
    function Module() {
        var root = Node("Module");
        var l1 = loc.start;
        root.body = this.ModuleBody();
        root.strict = true;
        var l2 = loc.end;
        root.loc = makeLoc(l1, l2);
        if (compile) return compiler(root);
        return root;
    }
    function DefaultAsIdentifier() {
        if (v === "default") {
            if (isDefaultId) {
                var node = Node("Identifier");
                node.name = "default";
                node.loc = token && token.loc;
                match("default");
                if (compile) return compiler(node);
                return node;
            }
        }
        return null;
    }
    function Program() {
        var node = Node("Program");
        node.loc = loc = makeLoc();
        loc.start.line = 1;
        loc.start.column = 1;
        var l1 = loc.start;
        //pushDecls();
        currentNode = node;
        node.body = this.SourceElements(node);
        var l2;
        l2 = lastloc && lastloc.end;
        node.loc = makeLoc(l1, l2);
        if (compile) return compiler(node);
        return node;
    }
    function RegularExpressionLiteral() {
        if (t === "RegularExpressionLiteral") {
            var l1 = loc.start;
            var node = Node("RegularExpressionLiteral");
            node.value = v[0];
            node.flags = v[1];
            var l2 = loc.end;
            node.loc = makeLoc(l1,l2);
            next();
            if (compile) return compiler(node);
            return node;
        }
        return null;
    }
    function JSONText() {
        if (!newSyntaxError) {
            newSyntaxError = require("api").newSyntaxError;
            ifAbrupt = require("api").ifAbrupt;
            isAbrupt = require("api").isAbrupt;
        }
        return this.JSONValue();
    }
    function JSONValue() {
        return this.JSONObject() || this.JSONArray() || this.JSONNumber() || this.JSONString() || this.JSONBooleanLiteral() || this.JSONNullLiteral();
    }
    function JSONString() {
        if (t === "StringLiteral" || (t == "Literal" && typeof v == "string"))  {
            var q1, q2;
            q1 = v[0];
            q2 = v[v.length - 1];
            if (q1 !== "\"" || q2 !== "\"") return newSyntaxError("JSONString: Expecting double quoted strings.");
            var node = Node("JSONString");
            node.value = v;
            next();
            return node;
        }
        return null;
    }
    function JSONNumber() {
        if (t === "NumericLiteral" || (t == "Literal" && typeof v === "number")) {
            var node = Node("JSONNumber");
            node.value = v;
            next();
            return node;
        }
    }
    function JSONFraction() {
        return null;
    }
    function JSONNullLiteral() {
        if (t === "NullLiteral") {
            var node = Node("JSONNullLiteral");
            node.value = v;
            next();
            return node;
        }
        return null;
    }
    function JSONBooleanLiteral() {
        if (t === "BooleanLiteral") {
            var node = Node("JSONBooleanLiteral");
            node.value = v;
            next();
            return node;
        }
        return null;
    }
    function JSONArray() {
        if (v === "[") {
            var node = Node("JSONArray");
            match("[");
            var elements = this.JSONElementList();
            if (isAbrupt(elements = ifAbrupt(elements))) return elements;
            node.elements = elements;
            match("]");
            return node;
        }
        return null;

    }
    function JSONElementList() {
        var list = [];
        while (v !== "]" && v !== undefined) {
            var node = this.JSONValue();
            if (isAbrupt(node = ifAbrupt(node))) return node;
            if (node) list.push(node);
            else return newSyntaxError("JSONElementList: Error parsing Element");
            if (v === ",") match(",");
            else if (v === "]") break;
            else return newSyntaxError("JSONElementList: Invalid formatted literal. Comma or ] expected. Got " + v);
        }
        return list;
    }
    function JSONObject() {
        if (v === "{") {
            var node = Node("JSONObject");
            match("{");
            var properties = this.JSONMemberList();
            if (isAbrupt(properties = ifAbrupt(properties))) return properties;
            node.properties = properties;
            match("}");
            return node;
        }
        return null;
    }
    function JSONMember() {
        var node = Node("JSONMember");
        var key = this.JSONString();
        if (!key) return newSyntaxError( "JSONMember: Expecting double quoted string keys in object literals.");
        if (isAbrupt(key = ifAbrupt(key))) return key;
        match(":");
        var value = this.JSONValue();
        if (isAbrupt(value = ifAbrupt(value))) return value;
        node.key = key;
        node.value = value;
        return node;
    }
    function JSONMemberList() {
        var list = [];
        while (v !== "}" && v !== undefined) {
            var node = this.JSONMember();
            if (isAbrupt(node = ifAbrupt(node))) return node;
            if (node) list.push(node);
            else return newSyntaxError("JSONMemberList: Error parsing Member");
            if (v === ",") match(",");
            else if (v === "}") break;
            else return newSyntaxError("JSONMemberList: Invalid formatted literal. Comma or } expected. Got: " + v);
        }
        return list;
    }
    function initOldLexer(sourceOrTokens, opts) {
        if (!Array.isArray(sourceOrTokens)) tokens = tokenize.tokenizeIntoArray(sourceOrTokens);
        else tokens = sourceOrTokens;
        if (typeof opts == "object" && opts) {
            if (opts.builder) {
                compile = true;
                builder = opts.builder;
                compiler = opts.builder.build;
            }
        }
        nextToken = nextToken__array__;
        pos = -1;
        lookPos = 0;
        token = t = v = undefined;
        tokenArrayLength = tokens.length;
        ast = null;
        loc = lastloc = undefined;
        currentNode = undefined;
        symtab = SymbolTable();
        nextToken(); // load lookahead
        next();     // move lookahead and get new
    }

    function initNewLexer(sourceOrTokens, opts) {
        currentNode = loc = lastloc = pos = t = v = token = lkhdTok = lkhdVal = lkhdTyp = undefined;
        ast = null;
        symtab = SymbolTable();
        if (typeof opts == "object" && opts) {
            if (opts.builder) {
                compile = true;
                builder = opts.builder;
            }
        }
        if (sourceOrTokens != undefined) {
            if (Array.isArray(sourceOrTokens)) {
                initOldLexer(sourceOrTokens, opts);
            } else {
                nextToken = nextToken__step__;
                lkhdTok = tokenize(sourceOrTokens);
                next();
            }
        }
    }
    function parse(sourceOrTokens, opts) {
        tokenize.saveState();
        if (tokenize === tokenize.tokenizeIntoArray) initOldLexer(sourceOrTokens, opts);
        else initNewLexer(sourceOrTokens, opts);
        try {
            ast = parser.Program();
        } catch (ex) {
            console.log("[ParserException@parse]: " + ex.name + " "+atLineCol());
            console.log(ex.message);
            console.log(ex.stack);
            ast = ex;
        } finally {
            tokenize.restoreState();
        }
        return ast;
    }
    function initParseGoal(source) {
        initOldLexer(source);
    }
    function parseGoal(goal, source, opts) {
        tokenize.saveState();
        saveTheDot();
        initOldLexer(source, opts);
        var fn = parser[goal];
        if (!fn) throw "Sorry, got no parser for " + goal;
        try {
            var node = fn.call(parser);
        } catch (ex) {
            console.log("[ParserException@parseGoal]: " + ex.name + " " +atLineCol());
            console.log(ex.name);
            console.log(ex.message);
            console.log(ex.stack);
            node = ex;
        } finally {
            restoreTheDot();
            tokenize.restoreState();
        }
        return node;
    }

    parser.ExpressionStatement = ExpressionStatement;
    parser.StartAssignmentExpression = StartAssignmentExpression;
    parser.StartAssignmentExpressionNoIn = StartAssignmentExpressionNoIn;
    parser.ConstClassDeclaration = ConstClassDeclaration;
    parser.JSONText = JSONText;
    parser.JSONValue = JSONValue;
    parser.JSONString = JSONString;
    parser.JSONNumber = JSONNumber;
    parser.JSONFraction = JSONFraction;
    parser.JSONNullLiteral = JSONNullLiteral;
    parser.JSONBooleanLiteral = JSONBooleanLiteral;
    parser.JSONArray = JSONArray;
    parser.JSONElementList = JSONElementList;
    parser.JSONObject = JSONObject;
    parser.JSONMember = JSONMember;
    parser.JSONMemberList = JSONMemberList;
    parser.ConditionalExpressionNoIn = ConditionalExpressionNoIn;
    parser.ConditionalExpression = ConditionalExpression;
    parser.LeftHandSideExpression = LeftHandSideExpression;
    parser.Expression = Expression;
    parser.PrimaryExpression = PrimaryExpression;
    parser.PostfixExpression = PostfixExpression;
    parser.UnaryExpression = UnaryExpression;
    parser.YieldExpression = YieldExpression;
    parser.YieldStatement = YieldExpression;
    parser.DefaultAsIdentifier = DefaultAsIdentifier;
    parser.YieldAsIdentifier = YieldAsIdentifier;
    parser.AssignmentExpression = AssignmentExpression;
    parser.SuperExpression = SuperExpression;
    parser.ThisExpression = ThisExpression;
    parser.Initializer = Initializer;
    parser.BindingElementList = BindingElementList;
    parser.BindingPattern = BindingPattern;
    parser.VariableDeclaration = VariableDeclaration;
    parser.VariableDeclarationList = VariableDeclarationList;
    parser.VariableStatement = VariableStatement;
    parser.Expression = Expression;
    parser.ExpressionNoIn = ExpressionNoIn;
    parser.AssignmentExpressionNoIn = AssignmentExpressionNoIn;
    parser.ParenthesizedExpression = ParenthesizedExpression;
    parser.ArrowParameterList = ArrowParameterList;
    parser.CoverParenthesizedExpressionAndArrowParameterList = CoverParenthesizedExpressionAndArrowParameterList;
    parser.ConciseBody = ConciseBody;
    parser.CoverParenthesizedExpression = CoverParenthesizedExpression;
    parser.Literal = Literal;
    parser.Identifier = Identifier;
    parser.ClassExpression = ClassExpression;
    parser.TemplateLiteral = TemplateLiteral;
    parser.Elision = Elision;
    parser.ElementList = ElementList;
    parser.ArrayExpression = ArrayExpression;
    parser.StrictFormalParameters = StrictFormalParameters;
    parser.PropertyDefinitionList = PropertyDefinitionList;
    parser.ComputedPropertyName = ComputedPropertyName;
    parser.PropertyKey = PropertyKey;
    parser.ObjectExpression = ObjectExpression;
    parser.MemberExpression = MemberExpression;
    parser.Arguments = Arguments;
    parser.CallExpression = CallExpression;
    parser.NewExpression = NewExpression;
    parser.ComprehensionForList = ComprehensionForList;
    parser.ComprehensionFilters = ComprehensionFilters;
    parser.ArrayComprehension = ArrayComprehension;
    parser.GeneratorComprehension = GeneratorComprehension;
    parser.SequenceExpressionNode = SequenceExpressionNode;
    parser.GeneratorBody = GeneratorBody;
    parser.FunctionBody = FunctionBody;
    parser.MethodDefinition = MethodDefinition;
    parser.ClassDeclaration = ClassDeclaration;
    parser.RestParameter = RestParameter;
    parser.SpreadExpression = SpreadExpression;
    parser.DefaultParameter = DefaultParameter;
    parser.FormalParameterList = FormalParameterList;
    parser.FunctionExpression = FunctionExpression;
    parser.FunctionDeclaration = FunctionDeclaration;
    parser.BlockStatement = BlockStatement;
    parser.ContinueStatement = ContinueStatement;
    parser.BreakStatement = BreakStatement;
    parser.ReturnStatement = ReturnStatement;
    parser.WithStatement = WithStatement;
    parser.ThrowStatement = ThrowStatement;
    parser.LabelledStatement = LabelledStatement;
    parser.TryStatement = TryStatement;
    parser.Catch = Catch;
    parser.Finally = Finally;
    parser.DebuggerStatement = DebuggerStatement;
    parser.ModuleDeclaration = ModuleDeclaration;
    parser.ModuleSpecifier = ModuleSpecifier;
    parser.ModuleBody = ModuleBody;
    parser.FromClause = FromClause;
    parser.ImportClause = ImportClause;
    parser.NamedImports = NamedImports;
    parser.ImportStatement = ImportStatement;
    parser.ExportsClause = ExportsClause;
    parser.DeclarationDefault = DeclarationDefault;
    parser.ExportStatement = ExportStatement;
    parser.StatementList = StatementList;
    parser.SwitchStatementList = SwitchStatementList;
    parser.Statement = Statement;
    parser.IterationStatement = IterationStatement;
    parser.ForStatement = ForStatement;
    parser.ForDeclaration = ForDeclaration;
    parser.ForBinding = ForBinding;
    parser.VariableStatementNoIn = VariableStatementNoIn;
    parser.SourceElements = SourceElements;
    parser.EmptyStatement = EmptyStatement;
    parser.DirectivePrologue = DirectivePrologue;
    parser.Module = Module;
    parser.Program = Program;
    parser.RegularExpressionLiteral = RegularExpressionLiteral;
    parser.ForStatement = ForStatement;
    parser.WhileStatement = WhileStatement;
    parser.IfStatement = IfStatement;
    parser.DoWhileStatement = DoWhileStatement;
    parser.SwitchStatement = SwitchStatement;
    parser.DefaultCase = DefaultCase;
    parser.SwitchCase = SwitchCase;
    parser.ForStatementHead = ForStatementHead;
    parser.ForInOfStatementHead = ForInOfStatementHead;

    var exports = parse;
    exports.parser = parser;
    exports.parseGoal = parseGoal;
    exports.setBuilder = setBuilder;
    exports.unsetBuilder = unsetBuilder;
    exports.registerObserver = registerObserver;
    exports.unregisterObserver = unregisterObserver;
    exports.enableExtras = enableExtras;
    exports.disableExtras = disableExtras;
    exports.setWithExtras = setWithExtras;
    exports.isWithExtras = isWithExtras;
    //   exports.makeParser = makeParser;
    return exports;
    // }
    // return makeParser();
});


/*

    The tokenizer is different from the remaining tokenization.
    I just need the array of code points.

    So i thought it´s better to separate it.

    Mistakes will be resolved when i´m through the whole evaluation specification
    and have completed implementing the RegExp.prototype methods.

      MY own question to myself is, how do i generate the automaton from (without violating spec)?

      Starting one from scratch is easy for me. But to see through the
      mist here, i got still some work to do. I will answer the question soon.

 */

define("regexp-parser", function (require, exports) {
"use strict";
    var tables = require("tables");

    var ch, lookahead, index, input, length;
    var parser = Object.create(null);

    function Node(type) {
        return {
            type: type
        };
    }

    function match(c) {
        if (c == ch) next();
        else throw new SyntaxError("RegExpParser: " + c + " expected")
    }

    function next() {
        if (index < length) {
            ch = lookahead;
            lookahead = input[++index];
            return ch;
        }
        return undefined;
    }

    var FirstOfQuantifierPrefix = {
        "*": true,
        "+": true,
        "?": true,
        "{": true
    };


    var FirstOfAssertion = {
        __proto__: null,
        "^": true,
        "$": true,
        "\\": true,
        "(": true
    };

    var FollowOfAssertion = {
        __proto__: null,
        "b": "\\",
        "B": "\\"
    };

    var FirstOfAtom = {
        __proto__: null,
        "^": true,
        "$": true,
        "\\": true,
        ".": true
    };

    var ControlLetter = tables.ControlLetter;
    var ControlEscape = tables.ControlEscape;
    var CharacterClassEscape = tables.CharacterClassEscape;
    var NonPatternCharacter = tables.NonPatternCharacter;

    Object.keys(ControlLetter).forEach(function (key) {
        FirstOfAtom[key] = true;
    });


    function Term() {
        var node;
        if (FirstOfAssertion[ch] || !NonPatternCharacter[ch]) {
            node = Node("Assertion");
            var assertion;
            var first = ch;
            switch (ch) {
                case "^":
                    node.assertion = "^";
                    match("^");
                    break;
                case "$":
                    node.assertion = "$";
                    match("$");
                    break;
                case "\\":
                    if (lookahead === "b" || lookahead === "B") {
                        next();
                        node.assertion = "\\" + ch;
                    }
                    break;
                case "(":
                    if (lookahead === "?") {
                        match("(");
                        match("?");
                        if (ch == "=") {
                            match("=");
                            node.assertion = this.Disjunction();
                            node.prefix = "?=";
                        } else if (ch == "!") {
                            match("!");
                            node.assertion = this.Disjunction();
                            node.prefix = "?!";
                        }
                    }
                    break;
                default:
                    return null;
            }
            return node;
        }
        if (FirstOfAtom[ch]) {
            node = Node("Atom");
            switch (ch) {
                case "\\":
                    node.atom = this.AtomEscape();
                    break;
                case "[":
                    node.atom = this.CharacterClass();
                    break;
                case "(":
                    match("(");
                    if (ch == "?" && lookhead == ":") {
                        match("?");
                        match(":");
                        node.atom = "?:";
                        node.disjunction = this.Disjunction();
                    } else {
                        node.atom = this.Disjunction();
                    }
                    break;
                case ".":
                    node.atom = ".";
                    match(".");
                    break;
                default:
                    if (!NonPatternCharacter[ch]) {
                        node.atom = ch;
                        next();
                    }

            }
            if (node) {
                var quantifier = this.Quantifier();
                if (quantifier) node.quantifier = quantifier;
            }
            return node;
        }
        return null;
    }

    function Quantifier() {
        if (FirstOfQuantifierPrefix[ch]) {

            var quantifier = ch;
            if (ch == "{") {

                match("{");
                if (DecimalDigits[ch]) {
                    var q1 = "";
                    while (DecimalDigits[ch]) {
                        q1 += ch;
                        next();
                    }
                    if (ch == ",") {
                        var q2 = "";
                        match(",");
                        while (DecimalDigits[ch]) {
                            q1 += ch;
                            next();
                        }
                    } else if (ch == "}") {
                        match("}");
                        return [q1];
                    } else {
                        throw new SyntaxError("invalid quantifier");
                    }
                    match("}");
                    return [q1, q2];
                } else {
                    throw new SyntaxError("invalid quantifier");
                }

            } else {
                match(quantifier);
                return quantifier;
            }
        }
        return null;
    }

    function AtomEscape() {
        var escape = "\\";
        if (DecimalDigits[lookahead]) {
            match("\\");
            while (DecimalDigits[ch]) {
                escape += ch;
                next();
            }
            return escape;
        }
        else if (ControlLetter[lookahead]) {
            match("\\");
            escape += ch;
            match(ch);
            return escape;
        } else if (CharacterClassEscape[lookahead]) {
            match("\\");
            escape += ch;
            return escape;
        }
        return escape;
    }

    var DecimalDigits = tables.DecimalDigits;
    var Hexdigits = tables.HexDigits;

    function ClassEscape() {
        var escape = "\\";
        if (DecimalDigits[lookahead]) {
            match("\\");
            if (ch == "0" && (lookahead === "x" || lookahead === "X")) {
                // HexEscapeSequence
                escape += "0";
                match("0");
                escape += ch;
                match(ch);
                while (HexDigits[ch]) {
                    escape += ch;
                    next();
                }
                return escape;
            }
            if (ch == "u") {
                // UnicodeEscapeSequence
                escape += "u";
                match("u");
                while (HexDigits[ch]) {
                    escape += ch;
                    next();
                }
                return escape;
            }
            while (DecimalDigits[ch]) {
                escape += ch;
                next();
            }
            return escape;
        } else if (lookahead === "b") {
            match("\\");
            escape += "b";
            match("b");
            return escape;
        } else if (CharacterClassEscape[lookahead]) {
            match("\\");
            escape += ch;
            match(ch);
            return escape;
        } else {

            if (lookahead == "c") {
                match("\\");
                match("c");
                // not strikt (requires 3 token lookahead)
                if (ControlLetter[ch]) {
                    escape += ch;
                }
                match(ch);
                return escape;
            }
            if (ControlEscape[lookahead]) {
                match("\\");
                escape += ch;
                match(ch);
                return escape;
            }
        }
    }

    function ClassRanges() {
        // ranges = [ 0, [1-7], 8, 9, [10-125] ]
        var ranges = [];
        while (ch != "]" && ch != undefined) {
            var left = ch;
            if (ch == "\\") {
                left = ClassEscape();
                if (!left) return null; // ???
            } else {
                match(ch);
            }
            if (ch == "-") {
                match("-");
                var right = ch;
                ranges.push([left, right]);
            } else {
                ranges.push(left);
            }
        }
        return ranges;
    }

    function CharacterClass() {
        var node = Node("CharacterClass");
        match("[");e;
        if (ch == "^") {
            node.negation = true;
            match("^");
        }
        node.ranges = this.ClassRanges();
        match("]");
        return node;
    }

    function Disjunction() {
        var node = Node("Disjunction");
        node.alternative = this.Alternative();
        if (ch === "|") {
            match("|");
            node.disjunction = Disjunction();
        }
        return node;
    }

    function Alternative() {
        var alternative = [];
        do {
            var term = this.Term();
            alternative.push(term);
        } while (term && ch != "|" && ch != undefined);
	return alternative;
    }

    function Pattern() {
        var node = Node("Pattern");
        node.disjunction = this.Disjunction();
        return node;
    }
    
    function parse(string) {
        input = string || "";
        length = input.length;
        if (length === 0) return Node("Pattern");
        index = -1;
        lookahead = string[0];
        next();
        try {
        var result = Pattern.call(parser);
        } catch (ex) {
    	    console.log("DEBUG REGULAR EXPRESSION PARSER EXCEPTION");
    	    console.log(ex.name);
    	    console.log(ex.message);
    	    console.log(""+ex.stack);
        }
        return result;
    }

    parser.Pattern = Pattern;
    parser.Alternative = Alternative;
    parser.Disjunction = Disjunction;
    parser.ClassRanges = ClassRanges;
    parser.ClassEscape = ClassEscape;
    parser.Term = Term;
    parser.CharacterClass = CharacterClass;
    parser.AtomEscape = AtomEscape;
        
    exports.parser = parser;
    exports.parse = parse;
    return exports;
});
define("js-codegen", function (require, exports, module) {
    "use strict";



    var builder = {};
    var parser = require("parser").parser;

    var parseGoal = parser.parseGoal;
    var setBuilder = parser.setBuilder;
    var unsetBuilder = parser.unsetBuilder;

    var TAB = "    ";
    var SPC = " ";
    var indent = 0;


    function tabs(indent) {
        var str = "";
        for (var i = 1; i <= indent; i++) {
            str += TAB;
        }
        return str;
    }

    function nl() {
        return "\r\n";
    }

    var names = {
        __proto__: null,
        "Directive": "directive",
        "BooleanLiteral": "literal",
        "StringLiteral": "literal",
        "NullLiteral": "literal",
        "NumericLiteral": "literal",
        "VariableDeclarator": "variableDeclarator",
        "BinaryExpression": "binaryExpression"
    };
     Object.keys(parser).forEach(function (k) {
        names[k] = (k[0]).toLowerCase() + k.slice(1);
     });

    function callBuilder(node) {
        var args;
        var name;

        if (!node) return "";

        if (Array.isArray(node)) {

            var src = "";
            var stm;
            for (var i = 0, j = node.length; i < j; i++) {
                if (stm = node[i]) {
                    src += callBuilder(stm);
                }
            }
            return src;

        } else if (typeof node === "string") {

            return node;

        } else {

            name = node.type;

            switch (name) {
                case "BlockStatement":
                    return this.blockStatement(node.body, node.loc, node.extras);
                    break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "GeneratorDeclaration":
                case "GeneratorExpression":
                    return this.functionDeclaration(node.id, node.params, node.body, node.strict, node.generator, node.expression, node.loc, node.extras);
                case "MethodDefinition":
                    return this.methodDefinition(node.id, node.params, node.body, node.strict, node.static, node.generator, node.loc, node.extras);
                case "ArrowExpression":
                    return this.arrowExpression(node.id, node.params, node.body, node.loc, node.extras);
                case "ParenthesizedExpression":
                    return this.parenthesizedExpression(node.expression, node.loc, node.extras);
                case "ExpressionStatement":
                    return this.expressionStatement(node.expression, node.loc, node.extras);
                case "SequenceExpression":
                    return this.sequenceExpression(node.sequence, node.loc, node.extras);
                case "VariableDeclarator":
                    return this.variableDeclarator(node.id, node.init, node.loc, node.extras);
                    break;
                case "VariableDeclaration": return this.variableDeclaration(node.kind, node.declarations, node.loc, node.extras);
                case "LexicalDeclaration": return this.lexicalDeclaration(node.kind, node.declarations, node.loc, node.extras);
                case "EmptyStatement":
                    return this.emptyStatement(node.loc, node.extras);
                    break;
                case "ForStatement":
                    args = [node.init, node.test, node.update, node.body, node.loc, node.extras];
                    break;
                case "ForInStatement":
                case "ForOfStatement":
                    args = [node.left, node.right, node.body, node.loc, node.extras];
                    break;
                case "DoWhileStatement":
                case "WhileStatement":
                    args = [node.test, node.body, node.loc, node.extras];
                    break;
                case "LabelledStatement":
                    args = [node.label, node.statement, node.loc, node.extras];
                    break;
                case "IfStatement":
                    args = [node.test, node.consequent, node.alternate, node.loc, node.extras];
                    break;
                case "TryStatement":
                    args = [node.handler, node.guard, node.finalizer, node.loc, node.extras];
                    break;
                case "SwitchStatement":
                    args = [node.discriminant, node.cases, node.loc, node.extras];
                    break;
                case "WithStatement":
                    args = [node.object, node.body, node.loc, node.extras];
                    break;
                case "ComprehensionExpression":
                    args = [node.blocks, node.filter, node.expression, node.loc, node.extras];
                    break;
                case "AssignmentExpression":
                case "BinaryExpression":
                case "LogicalExpression":
                    args = [node.operator, node.left, node.right, node.loc, node.extras];
                    break;
                case "UnaryExpression":
                    args = [node.operator, node.argument, node.prefix, node.loc, node.extras];
                    break;
                case "MemberExpression":
                    args = [node.object, node.property, node.computed, node.loc, node.extras];
                    break;
                case "CallExpression":
                case "NewExpression":
                    args = [node.callee, node.arguments, node.loc, node.extras];
                    break;
                case "ObjectPattern":
                case "ArrayPattern":
                    args = [node.elements, node.loc, node.extras];
                    break;
                case "BindingElement":
                    args = [node.id.name, node.target.name, node.loc, node.extras];
                    break;
                case "ObjectExpression":
                    args = [node.properties, node.loc, node.extras];
                    break;
                case "ArrayExpression":
                    args = [node.elements, node.loc, node.extras];
                    break;
                case "DefaultParameter":
                    args = [node.id, node.init, node.loc, node.extras];
                    break;
                case "RestParameter":
                    args = [node.id, node.init, node.loc, node.extras];
                    break;
                case "SpreadExpression":
                    args = [node.argument, node.loc, node.extras];
                    break;
                case "ClassDeclaration":
                case "ClassExpression":
                    args = [node.id, node.extends, node.elements, node.expression, node.loc, node.extras];
                    break;
                case "ThisExpression":
                case "SuperExpression":
                    args = [node.extras, node.loc];
                    break;
                case "Program":
                    args = [node.body, node.loc, node.extras];
                    break;
                case "Identifier":
                    args = [node.name || node.value, node.loc, node.extras];
                    break;
                case "ReturnStatement":
                case "ThrowStatement":
                    args = [node.argument, node.loc, node.extras];
                    break;
                case "BreakStatement":
                case "ContinueStatement":
                    args = [node.argument, node.label, node.loc, node.extras];
                    break;
                case "YieldExpression":
                    args = [node.argument, node.delegator, node.loc, node.extras];
                    break;
                case "Directive":
                case "Literal":
                case "NumericLiteral":
                case "StringLiteral":
                case "NullLiteral":
                case "BooleanLiteral":
                    args = [node.value, node.loc, node.extras];
                    break;
                case "TemplateLiteral":
                    args = [node.spans, node.loc, node.extras];
                    break;
                case "WhiteSpace":
                case "LineComment":
                case "MultiLineComment":
                case "LineTerminator":
                    args = [node.value, node.loc];
                    break;
                case "ConditionalExpression":
                    args = [node.test, node.consequent, node.alternate, node.loc, node.extras];
                    break;
            }
            var fn;
            // name = name[0].toLowerCase() + name.slice(1);
            //if (name)
                fn = builder[names[name]];

            if (fn) return fn.apply(builder, args);
            else throw new TypeError("can not generate code for " + name);
        }
    }

    builder.spreadExpression = function (argument, loc, extras) {
        var src = "..." + callBuilder(argument);
        return src;
    };

    builder.restParameter = function (id, init, loc, extras) {
        var src = "..." + callBuilder(id);
        if (init) src += " = " + callBuilder(init);
        return src;
    };

    builder.defaultParameter = function (id, init, loc, extras) {
        var src = "";
        src += callBuilder(id);
        src += " = ";
        src += callBuilder(init);
        return src;
    };

    builder.classExpression =
        builder.classDeclaration = function (id, extend, elements, expression, loc, extras) {
            var src = "class ";
            var e;
            src += id;
            if (extend) src += " extends " + callBuilder(extend);
            src += "{";
            ++indent;
            for (var i = 0, j = elements.length; i < j; i++) {
                if (e = elements[i]) {
                    src += tabs(indent) + callBuilder(e) + nl();
                }
            }
            --indent;
            src += "}";
            return src;
        };

    builder.program = function (body, loc, extras) {
        var src = "";
        var inst;
        for (var i = 0, j = body.length; i < j; i++) {
            if (inst = body[i]) {
                src += tabs(indent) + callBuilder(inst) + ";" + nl();
            }
        }
        return src;
    };

    builder.bindingElement = function (name, as, initializer, loc, extras) {
        var src = "";
        src += name;
        src += ":";
        src += as;
        if (initializer) src += " = " + callBuilder(initializer);
        return src;
    };
    builder.objectPattern = function (elements, loc, extras) {
        var src = "", e;
        src += "{";
        for (var i = 0, j = elements.length; i < j; i++) {
            if (e = elements[i]) {
                src += callBuilder(e);
                if (i < j - 1) src += ", ";
            }
        }
        src += "}";
        return src;
    };
    builder.arrayPattern = function (elements, loc, extras) {
        var src ="", e;
        src += "[";
        for (var i = 0, j = elements.length; i < j; i++) {
            if (e = elements[i]) {
                src += callBuilder(e);
                if (i < j - 1) src += ", ";
            }
        }
        src += "]";
        return src;
    };
    builder.identifier = function (name, loc, extras) {
        var src = "";
        src += name;
        return src;
    };

    builder.directive =
        builder.stringLiteral =
            builder.numericLiteral =
                builder.booleanLiteral =
                    builder.nullLiteral =
                    builder.literal = function (literal, loc, extras) {
                        var src = "";
                        src += literal;
                        return src;
                    };

    builder.emptyStatement = function emptyStatement(loc, extras) {
        var src = "";
        if (extras && extras.before) src += callBuilder(extras.before);
        src += ";";
        if (extras && extras.after) src += callBuilder(extras.after);
        return src;
    };

    builder.variableDeclarator = function (id, init, loc, extras) {
        var src = "";

        if (typeof id == "string")	// for identifier strings
            src += id;			    // esprima uses identifier nodes
        else src += id.name;		// which is fine for me, too.

        // must align (will replace id strings
        // with nodes)

        return src;
    };
    builder.lexicalDeclaration =
        builder.variableDeclaration = function variableStatement(kind, declarations, loc, extras) {
            var src = kind + " ";
            var decl;
            for (var i = 0, j = declarations.length; i < j; i++) {
                if (decl = declarations[i]) {

                    src += callBuilder(decl);

                    if (decl.init) {
                        src += " = " + callBuilder(decl.init);
                    }

                    if (i < j - 1) {
                        src += ", ";
                    }
                }
            }
            return src;
        };

    builder.functionBody = function (body) {
        if (body.type === "BlockStatement") return this.blockStatement(body.body, body.loc, body.extras);
        var src = "";
        var st;
        src += "{";
        src += nl();
        ++indent;
        for (var i = 0, j = body.length; i < j; i++) {
            if (st = body[i]) {
                src += tabs(indent) + callBuilder(st) + ";" + nl();
            }
        }
        --indent;
        src += "}";
        return src;
    };

    builder.arrowExpression =
        function (id, params, body, loc, extras) {
            var src = "";
            src += this.formalParameters(params);
            src += " => ";
            if (Array.isArray(body))
                src += this.functionBody(body);
            else
                src += callBuilder(body);
            return src;

        };

    builder.functionDeclaration =
        builder.functionExpression =
            builder.generatorDeclaration =
                builder.generatorExpression = function (id, params, body, strict, generator, expression, loc, extras) {

                    var src = "function";
                    if (generator) src += "*";
                    src += " ";


                    if (typeof id == "string") {		//change id to node.
                        src += id;
                    } else if (id) src += id.name;

                    src += this.formalParameters(params);
                    src += " ";
                    src += this.functionBody(body);
                    return src;
                };

    builder.generatorMethod =
        builder.methodDefinition = function (id, params, body, strict, generator, loc, extras) {
            ++indent;
            var src = "";
            if (generator) src += "*";
            src += id;
            src += this.formalParameters(params);
            src += " ";
            src += this.functionBody(body);
            return src;
        };

    builder.formalParameters = function (formals) {
        var a;
        var src = "";
        src += "(";
        if (formals && formals.length) {
            for (var i = 0, j = formals.length; i < j; i++) {
                if (a = formals[i]) {
                    src += callBuilder(a);
                    if (i < j - 1) src += ", ";
                }
            }
        }
        src += ")";
        return src;
    };

    builder.memberExpression = function (object, property, computed) {
        var src = "";
        src += callBuilder(object);
        if (computed) src += "[" + callBuilder(property) + "]";
        else src += "." + callBuilder(property);
        return src;
    };

    builder.callExpression = function (callee, args, loc, extras) {
        var src = "";
        src += callBuilder(callee);
        src += this.formalParameters(args);
        return src;

    };
    builder.newExpression = function (callee, args, loc, extras) {
        var src = "new ";
        src += callBuilder(callee);
        src += this.formalParameters(args);
        return src;
    };

    builder.objectExpression = function (properties, loc, extras) {
        var p, e;
        var src = "{";
        for (var i = 0, j = properties.length; i < j; i++) {
            if (p = properties[i]) {

                switch (p.kind) {
                    case "init":
                        src += callBuilder(p.key);
                        src += ":";
                        src += callBuilder(p.value);
                        break;
                    case "get":
                        src += "get ";
                        src += callBuilder(p.value);
                        break;
                    case "set":
                        src += "set ";
                        src += callBuilder(p.value);
                        break;
                }

                if (i < j - 1) {
                    src += ", ";
                }
            }
        }
        src += "}";
        return src;
    };
    builder.arrayExpression = function (elements, loc, extras) {
        var e;
        var src = "[";
        for (var i = 0, j = elements.length; i < j; i++) {
            if (e = elements[i]) {

                src += callBuilder(e);

                if (i < j - 1) {
                    src += ", ";
                }
            }
        }
        src += "]";
        return src;

    };

    builder.blockStatement = function (body, loc, extras) {
        var stm;
        var src = "{";

        if (body) {
            src += nl();
            ++indent;
            for (var i = 0, j = body.length; i < j; i++) {
                if (stm = body[i]) {

                    src += tabs(indent);
                    src += callBuilder(stm);
                    src += ";";
                    src += nl();

                }
            }
            --indent;
        }
        src += "}";
        return src;
    };

    var isOneOfThoseUnaryOperators = {
       "typeof": true,
        "void": true,
        "delete": true
    };
    builder.unaryExpression = function (operator, argument, prefix, loc, extras) {
        var src = "";
        if (prefix) src += operator;
        if (isOneOfThoseUnaryOperators[operator]) src += " ";
        src += callBuilder(argument);
        if (!prefix) src += operator;
        return src;
    };

    builder.binaryExpression = function (operator, left, right, loc, extras) {
        var src = "";
        src += callBuilder(left);
        src += SPC + operator + SPC;
        src += callBuilder(right);
        return src;
    };

    builder.assignmentExpression = function (operator, left, right, loc, extras) {
        var src = "";
        src += callBuilder(left);
        src += SPC + operator + SPC;
        src += callBuilder(right);
        return src;
    };

    builder.pattern = function () {};
    builder.expressionStatement = function expressionStatement(expr, loc, extras) {
        var src = "";
        src += callBuilder(expr);
        return src;
    };
    builder.labelledStatement = function labelledStatement(label, body, loc, extras) {
        var src = "";
        src += label + ": ";
        src += nl();
        src += tabs(indent);
        src += callBuilder(body);
        return src;
    };
    builder.sequenceExpression = function (seq, loc, extras) {
        var src = "";
        var e;
        for (var i = 0, j = seq.length; i < j; i++) {
            if (e = seq[i]) {
                src += callBuilder(e);
                if (i < j - 1) {
                    src += ", ";
                }
            }
        }
        return src;
    };
    builder.ifStatement = function ifStatement(test, condition, alternate, loc, extras) {
        var src = tabs(indent) + "if (" + callBuilder(test) + ") " + callBuilder(condition);
        if (alternate) src += tabs(indent) + " else " + callBuilder(alternate);
        return src;
    };
    builder.switchStatement = function (discriminant, cases, isLexical, loc, extras) {
        var c;
        var src = "switch (" + callBuilder(discriminant) + ") {";
        for (var i = 0, j = cases.length; i < j; i++) {
            if (c = cases[i]) {
                if (c.type === "DefaultCase") {
                    src += "default: " + nl();
                    ++indent;
                    src += callBuilder(c.consequent);
                    --indent;
                } else {
                    src += "case " + callBuilder(c.test) + ":" + nl();
                    ++indent;
                    src += callBuilder(c.consequent);
                    --indent;
                }
            }
        }
        src += "}";
        return src;
    };
    builder.whileStatement = function whileStatement(test, body, loc, extras) {
        var src = "while (" + callBuilder(test) + ")" + callBuilder(body);
        return src;
    };
    builder.doWhileStatement = function doWhileStatement(test, body, loc, extras) {
        var src = "do " + callBuilder(body) + " while (" + callBuilder(test) + ");";
        return src;
    };
    builder.withStatement = function withStatement(obj, body, loc, extras) {
        var src = "";
        if (extras && extras.with) src += callBuilder(extras.with.before);
        src += "with";
        if (extras && extras.with) src += callBuilder(extras.with.after);
        src += " (" + callBuilder(obj) + ") " + callBuilder(body);
        return src;
    };
    builder.debuggerStatement = function debuggerStatement(loc, extras) {
        var src = "";
        if (extras && extras.before) src += callBuilder(extras.before);
        src += "debugger";
    	if (extras && extras.after) src += callBuilder(extras.after);
        return src;
    };

    builder.parenthesizedExpression = function (expression, loc, extras) {
        var src = "";
        src += "(";
        src += callBuilder(expression);
        src += ")";
        return src;
    };
    builder.tryStatement = function (block, guard, finalizer, loc, extras) {
        var src = "try " + callBuilder(block);
        if (guard) src += " catch (" + callBuilder(guard.params) + ") " + callBuilder(guard.block);
        if (finalizer) src += "finally " + callBuilder(finalizer.block);
        return src;
    };
    builder.forInStatement = function forInStatement(left, right, body, isForEach, loc, extras) {
        var src = "for (";
        src += callBuilder(left);
        src += " in ";
        src += callBuilder(right);
        src += ") ";
        src += callBuilder(body);
        return src;
    };
    builder.forOfStatement = function forOfStatement(left, right, body, loc, extras) {
        var src = "for (";
        src += callBuilder(left);
        src += " of ";
        src += callBuilder(right);
        src += ") ";
        src += callBuilder(body);
        return src;
    };
    builder.forStatement = function forStatement(init, test, update, body, loc, extras) {
        var src = "for (";
        if (init) src += callBuilder(init);
        src += ";";
        if (test) src += callBuilder(test);
        src += ";";
        if (update) src += callBuilder(update);
        src += ") ";
        src += callBuilder(body);
        return src;
    };

    builder.throwStatement = function (expression, loc, extras) {
        var src = "throw";
        if (expression) {
            src += SPC;
            src += callBuilder(expression);
        }
        return src;
    };
    builder.breakStatement = function (label, loc, extras) {
        var src = "break";
        if (label) {
            src += SPC;
            src += callBuilder(label);
        }
        return src;
    };
    builder.continueStatement = function (label, loc, extras) {
        var src = "continue";
        if (label) {
            src += SPC;
            src += callBuilder(label);
        }
        return src;
    };
    builder.returnStatement = function (expression, loc, extras) {
        var src = "";
        if (extras && extras.before) src += callBuilder(extras.before);

        src += "return";
        if (extras && extras.after) src += callBuilder(extras.after);
        if (expression) {
            src += " " + callBuilder(expression);
        }
        return src;
    };
    builder.thisExpression = function (loc, extras) {
        var src = "";
        if (extras) src += callBuilder(extras.before);
        src += "this";
        if (extras) src += callBuilder(extras.after);
        return src;
    };
    builder.superExpression = function (loc, extras) {
        var src = "";
        if (extras) src += callBuilder(extras.before);
        src += "super";
        if (extras) src += callBuilder(extras.after);
        return src;
    };

    builder.conditionalExpression = function (test, consequent, alternate, loc, extras) {
       var src = "";
       src += callBuilder(test);
       src += " ? ";
       src += callBuilder(consequent);
        src += " : ";
        src += callBuilder(alternate);
        return src;
    };

    builder.whiteSpace = function (value, loc) {
        return value;
    };
    builder.lineComment = function(value, loc) {
        return value + "\n";
    };
    builder.multiLineComment = function (value, loc) {
        return value;
    };
    builder.lineTerminator = function (value, loc) {
        return value;
    };

    function buildFromSrc(src) {
        setBuilder(builder, true);
        try {
            var result = parser(src);
        } catch (ex) {
            result = "[" + ex.name + "]" + ex.message + ";\r\n" + tabs(1) + ex.stack + "\r\n";
        }
        unsetBuilder(builder);
        return result;
    }

    function build(ast) {
        if (typeof ast === "string") {
            return buildFromSrc(ast);
        }
        if (typeof ast.type === "string") {
            return callBuilder(ast);
        }
        if (Array.isArray(ast)) {
            return callBuilder(ast);
        }
        throw new TypeError("undefined input for build()")
    }

    build.callBuilder = callBuilder;
    build.buildFromSrc = buildFromSrc;
    build.builder = builder;

    return build;
});


    // ecma-262 operations and astnode evaluation
    // lib/api.js #includes lib/api/*.js; lib/intrinsics/*.js
    
/*
    API contains ecma-262 specification devices

    it includes the complete /lib/api/ and /lib/intrinsics/ subdirectories
    with /tools/inlinefiles.js

    refactoring for typed memory is on the list and i´m working towards.

 */


define("api", function (require, exports) {
    "use strict";

    var realm;
    var intrinsics;
    var globalEnv;
    var globalThis;
    var stack;
    var eventQueue;

    var _call = Function.prototype.call;   // I´ve seen little of jquery conf
    var _bind = Function.prototype.bind;
    var objectHasOwnProperty = _call.bind(Object.prototype.hasOwnProperty);
    var arraySlice = _call.bind(Array.prototype.slice);
    // gotta find and replace the rest, this gets a compiler, etc, it´s worth to do.

    var intl = require("i18n");
    var format = intl.format;
    var formatStr = intl.formatStr;
    var trans = intl.trans;

    var all = {
        toString: function () {
            return "[all imports/exports value]";
        }
    };
    var empty = {
        toString: function () {
            return "[empty completion value]";
        }
    };
    exports.all = all;
    exports.empty = empty;

    var statics = require("slower-static-semantics");
    var Contains = statics.Contains;
    var BoundNames = statics.BoundNames;
    var IsSimpleParameterList = statics.IsSimpleParameterList;
    var VarDeclaredNames = statics.VarDeclaredNames;
    var LexicallyDeclaredNames = statics.LexicallyDeclaredNames;
    var ExpectedArgumentCount = statics.ExpectedArgumentCount;
    var ModuleRequests = statics.ModuleRequests;
        var dupesInTheTwoLists = statics.dupesInTheTwoLists; // self defined
    
    var parse = require("parser");
    var parseGoal = parse.parseGoal;
    var debugmode = false;

    var detector = require("detector");
    var hasConsole = detector.hasConsole;
    var hasPrint = detector.hasPrint;
    var isNode = detector.isNode;
    var isWindow = detector.isWindow;
    var isWorker = detector.isWorker;

    function debug() {
        if (debugmode && hasConsole) console.log.apply(console, arguments);
    }
    function debug2() {
        if (hasConsole) console.log.apply(console, arguments);
    }
    function debugdir() {
        if (debugmode && hasConsole) console.dir.apply(console, arguments);
    }
    
    /*
	These include files include the main ecma 262 abstract operations.
    */
    
var DefineOwnProperty = OrdinaryDefineOwnProperty;
var GetOwnProperty = OrdinaryGetOwnProperty;

function Push(array, data) {
    return array.push(data);
}
function Length(array) {
    return array.length;
}
function getField(array, index) {
    return array[index];
}
function setField(array, index, value) {
    return array[index] = value;
}
function getRec(obj, key) {
    return obj[key];
}
function setRec(obj, key, value) {
    return obj[key] = value;
}
function genericArray(arr) {
    return arr;
}

function genericRecord(obj) {
    return obj;
}


function compareInternalSlot(O, N, V) {
    var value = getInternalSlot(O, N);
    return value === V;
}

function getInternalSlot(O, N) {
    return O[N];
}

function setInternalSlot(O, N, V) {
    return O[N] = V;
}

function hasInternalSlot(O, N) {
    return N in O;
}

function callInternalSlot(name, object, a, b, c, d) {
    return object[name](a,b,c,d);
}

function assignConstructorAndPrototype(Function, Prototype) {
    setInternalSlot(Function, SLOTS.PROTOTYPE, Prototype);
    DefineOwnProperty(Function, "prototype", {
        value: Prototype,
        enumerable: false,
        writable: true,
        configurable: true
    });
    DefineOwnProperty(Prototype, "constructor", {
        value: Function,
        enumerable: false,
        writable: true,
        configurable: true
    });
}

// ===========================================================================================================
// assign (copies properties)
// ===========================================================================================================

function addMissingProperties(target, mixin) {
    for (var k in mixin) {
        if (Object.hasOwnProperty.call(mixin, k)) {
            if (!Object.hasOwnProperty.call(target, k)) Object.defineProperty(target, k, Object.getOwnPropertyDescriptor(mixin, k));
        }
    }
    return target;
}

function assign(obj, obj2) {
    for (var k in obj2) {
        obj[k] = obj2[k];
    }
    return obj;
}


// ===========================================================================================================
// LazyDefineProperty (used intermediary)
// ===========================================================================================================

function LazyDefineFalseTrueFalse(O, name, value) {
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, name, {
        configurable: false,
        enumerable: true,
        value: value,
        writable: false
    });
}

function LazyDefineBuiltinConstant(O, name, value) {
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, name, {
        configurable: false,
        enumerable: false,
        value: value,
        writable: false
    });
}

// noch was vereinfacht
function LazyDefineBuiltinFunction(O, name, arity, fproto, e, w, c) {
    if (e === undefined) e = false;
    if (w === undefined) w = true;
    if (c === undefined) c = true;
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, name, {
        configurable: c,
        enumerable: e,
        value: CreateBuiltinFunction(getRealm(),fproto, arity, name),
        writable: w
    });
}

exports.LazyDefineAccessorFunction = LazyDefineAccessorFunction;
function LazyDefineAccessorFunction(O, name, arity, g, s, e, c) {
    if (e === undefined) e = false;
    if (c === undefined) c = true;
    var fname = name;
    if (IsSymbol(name)) fname = "["+(getInternalSlot(name, SLOTS.DESCRIPTION)||"")+"]";
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, name, {
        configurable: c,
        enumerable: e,
        get: g ? CreateBuiltinFunction(getRealm(), g, arity, "get "+fname) : undefined,
        set: s ? CreateBuiltinFunction(getRealm(), s, arity, "set "+fname) : undefined
    });
}

function LazyDefineAccessor(obj, name, g, s, e, c) {
    if (e === undefined) e = false;
    if (c === undefined) c = true;
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj, name, {
        configurable: c,
        enumerable: e,
        get: g,
        set: s
    });
}

function LazyDefineProperty(O, P, V, w, e, c) {
    var desc;
    if (w === undefined) w = true;
    if (e === undefined) e = false;
    if (c === undefined) c = true;
    if (IsDataDescriptor(V) || IsAccessorDescriptor(V)) {
        desc = V;
    } else {
        desc = {
            configurable: c,
            enumerable: e,
            value: V,
            writable: w
        };
    }
    //return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, P, desc);
    return OrdinaryDefineOwnProperty(O, P, desc);
}

/*

 getting context. stack, realm


 realm is a local variable set
 with setCodeRealm(realm)

 and can be saved and restored with
 saveCodeRealm()
 restoreCodeRealm()
 for interrupting the shared runtime

 because of the "realm" variable, all
 accesses to realm can be done with the
 variable, everything else should be queried
 functional at the moment. plans for local vars
 where discarded, until it´s safe to redo.
 */


function getContext() {
    var stack = realm.stack;
    return stack[stack.length-1];
}
function getEventQueue() {
    return realm.eventQueue;
}

function getGlobalThis() {
    return realm.globalThis;
}

function getGlobalEnv() {
    return realm.globalEnv;
}

function getIntrinsics() {
    return realm.intrinsics;
}

function getIntrinsic(name) {
    var desc = realm.intrinsics.Bindings[name];
    return desc && desc.value;
}

function getIntrinsicFromRealm(name, otherRealm) {
    var desc = otherRealm.intrinsics.Bindings[name];
    return desc && desc.value;
}

function getRealm() {
    return realm;
}

function getLexEnv() {
    var cx = getContext();
    return cx && cx.LexEnv;
    //    return getGlobalEnv().LexEnv;
}

function getVarEnv() {
    var cx = getContext();
    return cx && cx.VarEnv;
    //    return getGlobalEnv().objEnv;
}


function getStack() {
    return realm.stack;
}



// ===========================================================================================================
// Error Stack
// ===========================================================================================================


function printException (error) {
    var name = Get(error, "name");
    var message = Get(error, "message");
    var callstack = Get(error, "stack");
    var text = createExceptionTextOutput(name, message, callstack);
    console.log(text);
}

function createExceptionTextOutput(name, message, callstack) {
    var text = "\n";
    text += format("S_EXCEPTION_THROWN", name) + "\n";
    text += format("EXCEPTION_MESSAGE_S", message) + "\n";
    text += format("EXCEPTION_STACK_S", callstack) + "\n";
    return text;
}

function stringifyErrorStack(type, message) {
    var callStack = getStack();
    var len = callStack.length || 0;
    var frame = getContext();
    var start = 0;
    var node, ntype, line ,column, pos, fn, clr;
    var stackTraceLimit = realm.stackTraceLimit;
    var url = realm.scriptLocation;
    var cnt = 1;

    if (type === undefined) {
        type = ""; message = ""; stack = "";
    } else {
        if (message === undefined) message = "";
        stack = type+": ";
        stack += message;
        stack += "\r\n";
    }

    if (len > stackTraceLimit) start = len - stackTraceLimit;

    for (pos = len - 1; pos >= start; pos--) {
        if (frame = callStack[pos]) {
            node = frame.state.node;
            ntype = node && node.type;
            line = frame.line;
            column = frame.column;
            fn = frame.callee;
            clr = frame.caller;
            stack += cnt + ". ";
            stack += fn + "/" + ntype + "  " + format("AT_LINE_S_COLUMN_S", line, column);
            stack += "[caller " + clr + " @ "+url+"]";
            stack += "\r\n";
            cnt = cnt + 1;
        }
    }
    return stack;
}


function makeNativeException (error) {
    if (Type(error) != OBJECT) return error;
    var name = unwrap(Get(error, "name"));
    var message = unwrap(Get(error, "message"));
    var callstack = unwrap(Get(error, "stack"));
    var text = createExceptionTextOutput(name, message, callstack);

    var nativeError = new Error(name);
    nativeError.name = name;
    nativeError.message = message;
    nativeError.stack = text;
    return nativeError;
}

exports.makeNativeException = makeNativeException;


function CreateSelfHostingFunction(realm, name, arity, source) {
    var parseGoal = require("parser").parseGoal;
    var fn = parseGoal("FunctionDeclaration", source);
    var F = OrdinaryFunction();
    setInternalSlot(SLOTS.CODE, fn.body);
    setInternalSlot(SLOTS.FORMALPARAMETERS, fn.params);
    setInternalSlot(SLOTS.REALM, realm);
    SetFunctionName(F, name);
    SetFunctionLength(F, arity);
    return F;
}


function LazyDefineSelfHostingFunction(O, name, arity, fproto, e, w, c) {
    if (e === undefined) e = false;
    if (w === undefined) w = true;
    if (c === undefined) c = true;
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, name, {
        configurable: c,
        enumerable: e,
        value: CreateSelfHostingFunction(getRealm(), name, arity, fproto),
        writable: w
    });
}

exports.CreateSelfHostingFunction = CreateSelfHostingFunction;
exports.LazyDefineSelfHostingFunction = LazyDefineSelfHostingFunction;

var SLOTS = Object.create(null);
// Object Properties
SLOTS.BINDINGS = "Bindings";
SLOTS.SYMBOLS = "Symbols";
// Objects
SLOTS.PROTOTYPE = "Prototype";
SLOTS.EXTENSIBLE = "Extensible";
SLOTS.GET = "Get";
SLOTS.SET = "Set";
SLOTS.DEFINEOWNPROPERTY = "DefineOwnProperty";
SLOTS.GETOWNPROPERTY = "GetOwnProperty";
SLOTS.OWNPROPERTYKEYS = "OwnPropertyKeys";
SLOTS.ENUMERATE = "Enumerate";
SLOTS.GETPROTOTYPEOF = "GetPrototypeOf";
SLOTS.SETPROTOTYPEOF = "SetPrototypeOf";
SLOTS.INVOKE = "Invoke";
SLOTS.HASPROPERTY = "HasProperty";
SLOTS.ISEXTENSIBLE = "IsExtensible";
SLOTS.INTEGRITY = "Integrity";
// Arguments
SLOTS.PARAMETERMAP = "ParameterMap";
// Functions
SLOTS.CODE = "Code";
SLOTS.CALL = "Call";
SLOTS.CONSTRUCT = "Construct";
SLOTS.FORMALPARAMETERS = "FormalParameters";
SLOTS.THISMODE = "ThisMode";
SLOTS.STRICT = "Strict";
SLOTS.FUNCTIONKIND = "FunctionKind";
SLOTS.NEEDSSUPER = "NeedsSuper";
SLOTS.HOMEOBJECT = "HomeObject";
SLOTS.METHODNAME = "MethodName";
SLOTS.ENVIRONMENT = "Environment";
// Bound Functions
SLOTS.BOUNDTHIS = "BoundThis";
SLOTS.BOUNDTARGETFUNCTION = "BoundTargetFunction";
SLOTS.BOUNDARGUMENTS = "BoundArguments";
// Primitive Types
SLOTS.NUMBERDATA = "NumberData";
// Str
SLOTS.STRINGDATA = "StringData";
SLOTS.ITERATEDSTRING = "IteratedString";
SLOTS.ITERATIONKIND = "IterationKind";
SLOTS.ITERATORNEXTINDEX = "IteratorNextIndex";
SLOTS.BOOLEANDATA = "BooleanData";
// Symbol
SLOTS.ES5ID = "es5id";
SLOTS.SYMBOLDATA = "SymbolData";
SLOTS.DESCRIPTION = "Description";
// ArrayBuffer, TypedArray, DataView Slots
SLOTS.ARRAYBUFFERDATA = "ArrayBufferData";
SLOTS.TYPEDARRAYNAME = "TypedArrayName";
SLOTS.TYPEDARRAYCONSTRUCTOR = "TypedArrayConstructor";
SLOTS.BYTELENGTH = "ByteLength";
SLOTS.BYTEOFFSET = "ByteOffset";
SLOTS.ARRAYLENGTH = "ArrayLength";
SLOTS.DATAVIEW = "DataView";
SLOTS.ARRAYBUFFERBYTELENGTH = "ArrayBufferByteLength";
SLOTS.VIEWEDARRAYBUFFER = "ViewedArrayBuffer";
// Array Slots
SLOTS.ARRAYINITIALISATIONSTATE = "ArrayInitialisationState";
SLOTS.ITERATEDOBJECT = "IteratedObject";
SLOTS.ARRAYITERATIONNEXTINDEX = "ArrayIterationNextIndex";
SLOTS.ARRAYITERATIONKIND = "ArrayIterationKind";
// Proxy Slots (first replaced)
SLOTS.PROXYTARGET = "ProxyTarget";
SLOTS.PROXYHANDLER = "ProxyHandler";
SLOTS.REVOKABLEPROXY = "RevokableProxy";
// SetIterator Slots
SLOTS.ITERATEDSET = "IteratedSet";
SLOTS.SETNEXTINDEX = "SetNextIndex";
SLOTS.SETITERATIONKIND = "SetIterationKind";
// Promise Slots
SLOTS.PROMISESTATE = "PromiseState";
SLOTS.PROMISERESULT = "PromiseResult";
SLOTS.PROMISEREJECTREACTIONS = "PromiseRejectReactions";
SLOTS.PROMISERESOLVEREACTIONS = "PromiseResolveReactions";
SLOTS.INDEX = "Index";
SLOTS.VALUES = "Values";
SLOTS.CAPABILITY = "Capability";
SLOTS.REMAININGELEMENTS = "RemainingElements";
SLOTS.FULFILLMENTHANDLER = "FulfillmentHandler";
SLOTS.REJECTIONHANDLER = "RejectionHandler";
SLOTS.PROMISE = "Promise";
SLOTS.ALREADYRESOLVED = "AlreadyResolved";
SLOTS.PROMISECONSTRUCTOR = "PromiseConstructor";
// Loader Slots
SLOTS.LOADERRECORD = "LoaderRecord";
SLOTS.LOADER = "Loader";
SLOTS.LOAD = "Load";
SLOTS.LOADERITERATIONKIND = "LoaderIterationKind";
SLOTS.LOADERNEXTINDEX = "LoaderNextIndex";
SLOTS.REQUEST = "Request";
SLOTS.REFERERADDRESS = "RefererAddress";
SLOTS.REFERERNAME = "RefererName";
// RegExp Slots
SLOTS.REGEXPMATCHER = "RegExpMatcher";
SLOTS.ORIGINALSOURCE = "OriginalSource";
SLOTS.ORIGINALFLAGS = "OriginalFlags";
// Date
SLOTS.DATEVALUE = "DateValue";
// JSON
SLOTS.JSONTAG = "JSONTag";
// Math
SLOTS.MATHTAG = "MathTag";
// Set
SLOTS.SETDATA = "SetData";
SLOTS.SETCOMPARATOR = "SetComparator";
// Map
SLOTS.MAPDATA = "MapData";
SLOTS.MAPCOMPARATOR = "MapComparator";
// Realm
SLOTS.REALM = "Realm";
SLOTS.REALMRECORD = "RealmRecord";
// observe
SLOTS.NOTIFIER = "Notifier";
SLOTS.CHANGEOBSERVERS = "ChangeObservers";
SLOTS.ACTIVECHANGE = "ActiveChange";
SLOTS.TARGET = "Target";
SLOTS.PENDINGCHANGERECORDS = "PendingChangeRecords";
// Generator
SLOTS.GENERATORCONTEXT = "GeneratorContext";
SLOTS.GENERATORSTATE = "GeneratorState";
// Emitter
SLOTS.EVENTLISTENERS = "EventListeners";
// StructTypes
SLOTS.TYPEDESCRIPTOR = "TypeDescriptor";
SLOTS.OPACITY = "Opacity";
SLOTS.STRUCTURE = "Structure";
SLOTS.DIMENSIONS = "Dimensions";
SLOTS.RANK = "Rank";
SLOTS.ARRAYDESCRIPTOR = "ArrayDescriptor";
SLOTS.OPAQUEDESCRIPTOR = "OpaqueDescriptor";
// Structured Clones
SLOTS.TRANSFER = "Transfer";
SLOTS.ONSUCCESSFULTRANSFER = "OnSuccessfulTransfer";

Object.freeze(SLOTS); // DOES A FREEZE HELP OPTIMIZING? The pointers can´t change anymore, or?

/**
 * Created by root on 10.05.14.
 */

var INTRINSICS = Object.create(null);

INTRINSICS.OBJECT = "%Object%";
INTRINSICS.OBJECTPROTOTYPE = "%ObjectPrototype%";
INTRINSICS.FUNCTION = "%Function%";
INTRINSICS.FUNCTIONPROTOTYPE = "%FunctionPrototype%";
INTRINSICS.ARRAY = "%Array%";
INTRINSICS.ARRAYPROTOTYPE = "%ArrayPrototype%";
INTRINSICS.ARRAYITERATORPROTOTYPE = "%ArrayIteratorPrototype%";
INTRINSICS.GENERATOR = "%Generator%";
INTRINSICS.GENERATORPROTOTYPE = "%GeneratorPrototype%";
INTRINSICS.MATH = "%Math%";
INTRINSICS.JSON = "%JSON%";
INTRINSICS.REFLECT = "%Reflect%";
INTRINSICS.LOADER = "%Loader%";
INTRINSICS.LOADERPROTOTYPE = "%LoaderPrototype%";
INTRINSICS.LOADERITERATORPROTOTYPE = "%LoaderIteratorPrototype%";
INTRINSICS.GENERATORFUNCTION = "%GeneratorFunction%";
INTRINSICS.ARRAYBUFFER = "%ArrayBuffer%";
INTRINSICS.ARRAYBUFFERPROTOTYPE = "%ArrayBufferPrototype%";
INTRINSICS.DATAVIEW = "%DataView%";
INTRINSICS.DATAVIEWPROTOTYPE = "%DataViewPrototype%";
INTRINSICS.ERROR = "%Error%";
INTRINSICS.ERRORPROTOTYPE = "%ErrorPrototype%";
INTRINSICS.TYPEERROR = "%TypeError%";
INTRINSICS.TYPEERRORPROTOTYPE = "%TypeErrorPrototype%";
INTRINSICS.REFERENCEERROR = "%ReferenceError%";
INTRINSICS.REFERENCEERRORPROTOTYPE = "%ReferenceErrorPrototype%";
INTRINSICS.STRING = "%String%";
INTRINSICS.STRINGPROTOTYPE = "%StringPrototype%";
INTRINSICS.STRINGITERATORPROTOTYPE = "%StringIteratorPrototype%";
INTRINSICS.SETITERATORPROTOTYPE = "%SetIteratorPrototype%";
INTRINSICS.MAPITERATORPROTOTYPE = "%MapIteratorPrototype%";
INTRINSICS.MAP = "%Map%";
INTRINSICS.SET = "%Set%";
INTRINSICS.MAPPROTOTYPE = "%MapPrototype%";
INTRINSICS.SETPROTOTYPE = "%SetPrototype%";
INTRINSICS.SYNTAXERROR = "%SyntaxError%";
INTRINSICS.SYNTAXERRORPROTOTYPE = "%SyntaxErrorPrototype%";
INTRINSICS.URIERROR = "%URIError%";
INTRINSICS.URIERRORPROTOTYPE = "%URIErrorPrototype%";
INTRINSICS.EVALERROR = "%EvalError%";
INTRINSICS.EVALERRORPROTOTYPE = "%EvalErrorPrototype%";
INTRINSICS.RANGEERROR = "%RangeError%";
INTRINSICS.RANGEERRORPROTOTYPE = "%RangeErrorPrototype%";
INTRINSICS.CONSOLE = "%Console%";
INTRINSICS.EMITTER = "%Emitter%";
INTRINSICS.EMITTERPROTOTYPE = "%EmitterPrototype%";
INTRINSICS.SYMBOL = "%Symbol%";
INTRINSICS.SYMBOLPROTOTYPE = "%SymbolPrototype%";
INTRINSICS.NUMBER = "%Number%";
INTRINSICS.NUMBERPROTOTYPE = "%NumberPrototype%";
INTRINSICS.REGEXP   = "%RegExp%";
INTRINSICS.REGEXPPROTOTYPE  = "%RegExpPrototype%";
INTRINSICS.DATE = "%Date%";
INTRINSICS.DATEPROTOTYPE = "%DatePrototype%";
INTRINSICS.TYPEDARRAY = "%TypedArray%";
INTRINSICS.TYPEDARRAYPROTOTYPE = "%TypedArrayPrototype%";
INTRINSICS.UINT8ARRAY = "%Uint8Array%";
INTRINSICS.INT8ARRAY = "%Int8Array%";
INTRINSICS.INT16ARRAY = "%Int16Array%";
INTRINSICS.UINT16ARRAY = "%Uint16Array%";
INTRINSICS.INT32ARRAY = "%Int32Array%";
INTRINSICS.UINT32ARRAY = "%Uint32Array%";
INTRINSICS.FLOAT32ARRAY = "%Float32Array%";
INTRINSICS.FLOAT64ARRAY = "%Float64Array%";
INTRINSICS.UINT8ARRAYPROTOTYPE = "%Uint8ArrayPrototype%";
INTRINSICS.INT8ARRAYPROTOTYPE = "%Int8ArrayPrototype%";
INTRINSICS.INT16ARRAYPROTOTYPE = "%Int16ArrayPrototype%";
INTRINSICS.UINT16ARRAYPROTOTYPE = "%Uint16ArrayPrototype%";
INTRINSICS.INT32ARRAYPROTOTYPE = "%Int32ArrayPrototype%";
INTRINSICS.UINT32ARRAYPROTOTYPE = "%Uint32ArrayPrototype%";
INTRINSICS.FLOAT32ARRAYPROTOTYPE = "%Float32ArrayPrototype%";
INTRINSICS.FLOAT64ARRAYPROTOTYPE = "%Float64ArrayPrototype%";
INTRINSICS.UINT8CLAMPEDARRAY = "%Uint8ClampedArray%";
INTRINSICS.UINT8CLAMPEDARRAYPROTOTYPE = "%Uint8ClampedArrayPrototype%";
INTRINSICS.PROMISE = "%Promise%";
INTRINSICS.PROMISEPROTOTYPE = "%PromisePrototype%";
INTRINSICS.ISNAN = "%IsNaN%";
INTRINSICS.ISFINITE = "%IsFinite%";
INTRINSICS.ESCAPE = "%Escape%";
INTRINSICS.UNESCAPE = "%Unescape%";
INTRINSICS.DECODEURI = "%DecodeURI%";
INTRINSICS.ENCODEURI = "%EncodeURI%";
INTRINSICS.DECODEURICOMPONENT = "%DecodeURIComponent%";
INTRINSICS.ENCODEURICOMPONENT = "%EncodeURIComponent%";
INTRINSICS.PARSEINT = "%ParseInt%";
INTRINSICS.PARSEFLOAT = "%ParseFloat%";
INTRINSICS.PROXY = "%Proxy%";
INTRINSICS.PROXYPROTOTYPE = "%ProxyPrototype%";
INTRINSICS.REALM = "%Realm%";
INTRINSICS.REALMPROTOTYPE = "%RealmPrototype%";
INTRINSICS.SETTIMEOUT = "%SetTimeout%";
INTRINSICS.SETIMMEDIATE = "%SetImmediate%";
INTRINSICS.EVAL = "%Eval%";
INTRINSICS.MODULE = "%Module%";
INTRINSICS.REQUEST = "%Request%";
INTRINSICS.LOAD = "%Load%";
INTRINSICS.WEAKSET = "%WeakSet%";
INTRINSICS.WEAKMAP = "%WeakMap%";
INTRINSICS.WEAKSETPROTOTYPE = "%WeakSetPrototype%";
INTRINSICS.WEAKMAPPROTOTYPE = "%WeakMapPrototype%";
INTRINSICS.BOOLEAN = "%Boolean%";
INTRINSICS.BOOLEANPROTOTYPE = "%BooleanPrototype%";
INTRINSICS.EVENT = "%Event%";
INTRINSICS.EVENTTARGET = "%EventTarget%";
INTRINSICS.EVENTPROTOTYPE = "%EventPrototype%";
INTRINSICS.EVENTTARGETPROTOTYPE = "%EventTargetPrototype%";
INTRINSICS.NOTIFIERPROTOTYPE = "%NotifierPrototype%";
INTRINSICS.DEBUGFUNCTION = "%DebugFunction%";
INTRINSICS.PRINTFUNCTION = "%PrintFunction%";
INTRINSICS.MESSAGEPORT = "%MessagePort%";
INTRINSICS.MESSAGEPORTPROTOTYPE = "%MessagePortPrototype%";
INTRINSICS.THROWTYPEERROR = "%ThrowTypeError%";
INTRINSICS.STRUCTTYPE = "%StructType%";
INTRINSICS.STRUCTTYPEPROTOTYPE = "%StructTypePrototype%";
INTRINSICS.TYPE = "%Type%";
INTRINSICS.TYPEPROTOTYPE = "%TypePrototype%";
INTRINSICS.ARRAYPROTO_VALUES = "%ArrayProto_values%";
INTRINSICS.SETLANGUAGE = "%SetLanguage%";
INTRINSICS.VM = "%VM%";
INTRINSICS.DOMWRAPPER = "%DOMWrapper%";
Object.freeze(INTRINSICS);

/**
 * Created by root on 31.03.14.
 */

// ===========================================================================================================
// floor, ceil, abs, min, max
// ===========================================================================================================

var floor = Math.floor;
var ceil = Math.ceil;
var abs = Math.abs;
var min = Math.min;
var max = Math.max;

function _floor(x) {
    return x - (x % 1);
}

function _ceil(x) {
    return x - (x % 1) + 1;
}

function _abs(x) {
    return x < 0 ? -x : x;
}

function sign(x) {
    return x < 0 ? -1 : 1;
}

function _min() {
    var min = Infinity;
    var n;
    for (var i = 0, j = arguments.length; i < j; i++)
        if ((n = arguments[i]) < min) min = n;
    return min;
}

function _max() {
    var max = -Infinity;
    var n;
    for (var i = 0, j = arguments.length; i < j; i++)
        if ((n = arguments[i]) > max) max = n;
    return max;
}





/**
 * Created by root on 31.03.14.
 */

// ===========================================================================================================
// Assert
// ===========================================================================================================

function Assert(act, message) {
    var cx, node;
    if (!act) {
        if (cx = getContext()) {
            node = cx.state.node;
        }
        if (node) {
            var loc = node.loc;
            if (loc) {
                var line = loc.start.line;
                var col = loc.start.column;
            }
        }
        throw new Error("Assertion failed: " + message + " (at: line " + line + ", column " + col + ")");
    }
}

function GetGlobalObject() {
    var realm = getRealm();
    var globalThis = realm.globalThis;
    return globalThis;
}


function createPublicCodeRealm () {
    var realm = CreateRealm();
    return {
        eval: function toValue() {
            return realm.eval.apply(realm, arguments);
        },
        evalFile: function fileToValue() {
            return realm.evalFile.apply(realm, arguments);
        },
        evalAsync: function evalAsync() {
            return realm.evalAsync.apply(realm, arguments);
        },
        evalByteCode: function () {
            return realm.evalByteCode.apply(realm, arguments);
        }
    };
}

function CodeRealm(intrinsics, gthis, genv, ldr) {
    "use strict";
    return {
        __proto__: CodeRealm.prototype,
        intrinsics: intrinsics,
        globalThis: gthis,
        globalEnv: genv,
        directEvalTranslate: undefined,
        directEvalFallback: undefined,
        indirectEval: undefined,
        Function:undefined,
        loader: ldr,
        stack: [],
        eventQueue:[]
    };
}
CodeRealm.prototype.toString = CodeRealm_toString;
CodeRealm.prototype.constructor = CodeRealm;

CodeRealm.prototype.fileToValue =
    CodeRealm.prototype.evalFile = function (filename) {
        var rf = require("filesystem").readFileSync;
        if (typeof rf === "function") {
            var code = rf(filename);
            return this.eval(code);
        } else {
            throw new TypeError("can not read file "+filename+" with filesystem module");
        }
    };


CodeRealm.prototype.eval =
    CodeRealm.prototype.toValue = function (code) {
        // overhead save realm
        saveCodeRealm();
        setCodeRealm(this);
        if (typeof code === "string") code = parse(code);
        var result = exports.Evaluate(code);
        result = GetValue(result);
        if (isAbrupt(result=ifAbrupt(result))) {
            var error = result.value;
            var ex = new Error(Get(error, "message"));
            ex.name = Get(error, "name");
            ex.stack = Get(error,"stack");
            throw ex;
        }
        var PromiseTasks = getTasks(getRealm(), "PromiseTasks")
        var taskResults = NextTask(undefined, PromiseTasks);

        restoreCodeRealm();
        return result;
    };

CodeRealm.prototype.evalAsync =
    function (code) {
        var realm = this;
        return makePromise(function (resolve, reject) {
            try {
                var result = realm.eval(code);
                resolve(result);
            } catch (ex) {
                reject(ex);
            }
        });
    };

    CodeRealm.prototype.evalFileAsync = function (file) {
        var realm = this;
        return require("filesystem").readFileP(name).then(function (code) {
            return realm.eval(code);
        }, function (err) {
            throw err;
        });
    };

    CodeRealm.prototype.evalByteCode = function (code) {
        saveCodeRealm();
        setCodeRealm(this);
        var result = require("vm").CompileAndRun(this, code);
        result = GetValue(result);
        if (isAbrupt(result=ifAbrupt(result))) {
            var error = result.value;
            var ex = new Error(Get(error, "message"));
            ex.name = Get(error, "name");
            ex.stack = Get(error,"stack");
            throw ex;
        }
        var PromiseTasks = getTasks(getRealm(), "PromiseTasks");
        var taskResults = NextTask(undefined, PromiseTasks);
        restoreCodeRealm();
        return result;
    };

function CodeRealm_toString() {
    return "[object CodeRealm]";
}


function IndirectEval(realm, source) {
    saveCodeRealm();
    setCodeRealm(realm);
    if (typeof source === "string") {
        var code = parse(source);
    } else code = source;
    var result = exports.Evaluate(code);
    restoreCodeRealm();
    return result;
    //return realm.toValue(source);
}

exports.IndirectEval = IndirectEval;
exports.CreateRealm = CreateRealm;
exports.createPublicCodeRealm = createPublicCodeRealm;

function CreateRealm () {

    saveCodeRealm();

    var realmRec = CodeRealm();
    setCodeRealm(realmRec);
    // i have to have a stack, realm, intriniscs
    // and to remove the dependency
    //var context = newContext(null);

    var context = ExecutionContext(null);
    context.realm = realmRec;
    realmRec.stack.push(context);


    var intrinsics = createIntrinsics(realmRec);

    var loader = OrdinaryConstruct(getIntrinsic(INTRINSICS.LOADER), []);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;

    realmRec.loader = loader;
    var newGlobal = createGlobalThis(realmRec, ObjectCreate(null), intrinsics);
    var newGlobalEnv = GlobalEnvironment(newGlobal);

    // i think this is a bug and no execution context should be required
    context.VarEnv = newGlobalEnv;
    context.LexEnv = newGlobalEnv;


    realmRec.globalThis = newGlobal;
    realmRec.globalEnv = newGlobalEnv;
    realmRec.directEvalTranslate = undefined;
    realmRec.directEvalFallback = undefined;
    realmRec.indirectEval = undefined;
    realmRec.Function = undefined;
    realmRec.GlobalSymbolRegistry = Object.create(null);
    makeTaskQueues(realmRec);
    restoreCodeRealm();
    return realmRec;
}


var realms = [];
function saveCodeRealm() {
    realms.push(realm);
}
function restoreCodeRealm() {
    setCodeRealm(realms.pop());
}
function setCodeRealm(r) {  // CREATE REALM (API)
    if (r) {
        realm = r;
        stack = realm.stack;
        intrinsics = realm.intrinsics;
        globalEnv = realm.globalEnv;
        globalThis = realm.globalThis;
    }
    require("runtime").setCodeRealm(r);
}

function ExecutionContext(outerCtx, realm, state, generator) {
    "use strict";
    var VarEnv = NewDeclarativeEnvironment((outerCtx && outerCtx.LexEnv)||null);
    return {
        __proto__: ExecutionContext.prototype,
        state: [], // depr.
        stack: [],
        pc: 0,              //
        operandStack: [],   // or use local variables and saveRegs() (nothing without a push to save)
        sp: -1,
        realm: realm,
        outer: outerCtx||null,
        VarEnv: VarEnv,
        LexEnv: VarEnv,
        generator: generator
    };
}
ExecutionContext.prototype.toString = ExecutionContext_toString;
ExecutionContext.prototype.constructor = ExecutionContext;
function ExecutionContext_toString() {
    return "[object ExecutionContext]";
}

/*

    // completion re-use



var completion = newCompletionRecord();

function newCompletionRecord(type, value, target) {
    "use strict";
    return {
        __proto__:CompletionRecord.prototype,
        type: type,
        value: value,
        target: target
    };
}

function cloneCompletion(completion) {
    // pending exceptions would get lost, so we got to clone the completion
    return newCompletionRecord(completion.type, completion.value, completion.target);
}

function CompletionRecord(type, value, target) {
    "use strict";
    completion.type = type;
    completion.value = value;
    completion.target = target;
    return completion;
}

*/

function CompletionRecord(type, value, target) {
    "use strict";
    return {
        __proto__:CompletionRecord.prototype,
        type: type,
        value: value,
        target: target
    };
}


CompletionRecord.prototype.toString = CompletionRecord_toString;
CompletionRecord.prototype.constructor = CompletionRecord;

function CompletionRecord_toString() {
    return "[object CompletionRecord]";
}

function NormalCompletion(argument, label) {
    var completion;
    if (argument instanceof CompletionRecord) {
        completion = argument;
    } else {
        completion = CompletionRecord();
        completion.value = argument;
        completion.type = "normal";
        completion.target = label;
    }
    return completion;
}

function Completion(type, argument, target) {
    var completion;
    if (argument instanceof CompletionRecord) {
        completion = argument;
    } else {
        // if (type == "normal")
        completion = CompletionRecord();
        // else completion = newCompletionRecord();
        completion.value = argument;
    }
    completion.type = type || "normal";
    completion.target = target;
    return completion;
}

function unwrap(arg) {
    if (arg instanceof CompletionRecord) return arg.value;
    return arg;
}

function ifAbrupt(argument) {
    if (!(argument instanceof CompletionRecord) || argument.type !== "normal") return argument;
    return argument.value;
}

function isAbrupt(completion) {
    return (completion instanceof CompletionRecord && completion.type !== "normal");
}

function newReferenceError(message) {
    return Completion("throw", OrdinaryConstruct(getIntrinsic(INTRINSICS.REFERENCEERROR), [message]));
}

function newRangeError(message) {
    return Completion("throw", OrdinaryConstruct(getIntrinsic(INTRINSICS.RANGEERROR), [message]));
}

function newSyntaxError(message) {
    return Completion("throw", OrdinaryConstruct(getIntrinsic(INTRINSICS.SYNTAXERROR), [message]));
}

function newTypeError(message) {
    return Completion("throw", OrdinaryConstruct(getIntrinsic(INTRINSICS.TYPEERROR), [message]));
}

function newURIError(message) {
    return Completion("throw", OrdinaryConstruct(getIntrinsic(INTRINSICS.URIERROR), [message]));
}

function newEvalError(message) {
    return Completion("throw", OrdinaryConstruct(getIntrinsic(INTRINSICS.EVALERROR), [message]));
}



function Reference(N, V, S, T) {
    return {
        __proto__: Reference.prototype,
        name: N,
        base: V,
        strict: S,
        thisValue: T
    };
}

Reference.prototype = {
    constructor: Reference,
    toString: function () {
        return "[object Reference]";
    } /*,
     GetValue: function () {
     return GetValue(this);
     },
     PutValue: function (W) {
     return PutValue(this, W);
     },
     IsPropertyReference: function () {
     return IsPropertyReference(this);
     },
     IsSuperReference: function () {
     return IsSuperReference(this);
     },
     IsStrictReference: function () {
     return IsStrictReference(this);
     },
     IsUnresolvableReference: function () {
     return IsUnresolvableReference(this);
     },
     GetReferencedName: function () {
     return GetReferencedName(this);
     },
     GetReferencedKey: function () {
     return GetReferencedKey(this);
     },
     GetBase: function () {
     return GetBase(this);
     },
     HasPrimitiveBase: function () {
     return HasPrimitiveBase(this);
     },
     GetThisValue: function () {
     return GetThisValue(this);
     }*/

};


function GetValue(V) {

    if (isAbrupt(V = ifAbrupt(V))) return V;
    if (Type(V) !== REFERENCE) return V;

    var base = V.base;

    if (IsUnresolvableReference(V)) return newReferenceError( format("REFERENCE_S_UNRESOLVABLE", V.name));

    if (IsPropertyReference(V)) {

        if (HasPrimitiveBase(V)) {
            Assert(base !== null && base !== undefined, trans("BASE_NEVER_NULL"));
            base = ToObject(base);
        }

        // object
        return callInternalSlot(SLOTS.GET, base, V.name, GetThisValue(V));
    } else {
        // environment record
        return base.GetBindingValue(V.name, V.strict);
    }

}

function PutValue(V, W) {
    if (isAbrupt(V = ifAbrupt(V))) return V;
    if (isAbrupt(W = ifAbrupt(W))) return W;
    if (Type(V) !== REFERENCE) return newReferenceError(trans("NOT_A_REFERENCE"));
    var base = V.base;

    if (IsUnresolvableReference(V)) {

        //console.log("unresolvable "+V.name);
        if (V.strict) return newReferenceError( trans("UNRESOLVABLE_REFERENCE"));
        var globalObj = GetGlobalObject();
        return Put(globalObj, V.name, W, false);

    } else if (IsPropertyReference(V)) {

        if (HasPrimitiveBase(V)) {
            Assert(base !== null && base !== undefined, "PutValue: base is never null nor undefined");
            base = ToObject(base);
            var succeeded = callInternalSlot(SLOTS.SET, base, V.name, W, GetThisValue(V));
            if (isAbrupt(succeeded = ifAbrupt(succeeded))) return succeeded;
            if (succeeded === false && V.strict) return newTypeError(format("SET_FAILED_IN_STRICTMODE"));
            return NormalCompletion();
        }

    } else {
        return base.SetMutableBinding(V.name, W, V.strict);
    }

}

function IsPropertyReference(V) {
    var base = GetBase(V);
    return Type(base) === OBJECT || HasPrimitiveBase(V);

}

function IsSuperReference(V) {
    return V.thisValue;

}

function IsUnresolvableReference(V) {
    return V.base === undefined;

}

function IsStrictReference(V) {
    return V.strict === true;
}

function GetReferencedName(V) {
    return V.name;
}

function GetBase(V) {
    return V.base;
}

function HasPrimitiveBase(V) {
    var type = Type(GetBase(V));
    switch(type) {
        case STRING:
        case BOOLEAN:
        case NUMBER:
        case SYMBOL:
            return true;
        default:
            return false;
    }
}

function GetThisValue(V) {
    if (isAbrupt(V = ifAbrupt(V))) return V;
    if (Type(V) !== REFERENCE) return V;
    if (IsUnresolvableReference(V)) return newReferenceError( "GetThisValue: unresolvable reference");
    if (IsSuperReference(V)) return V.thisValue;
    return GetBase(V);
}

/**
 * Created by root on 30.03.14.
 */
    // ===========================================================================================================
    // Ordinary Object
    // ===========================================================================================================

function OrdinaryObject(prototype) {
    var O = Object.create(OrdinaryObject.prototype);
    prototype = prototype === undefined ? getIntrinsic(INTRINSICS.OBJECTPROTOTYPE) || null : prototype;
    setInternalSlot(O,SLOTS.BINDINGS,Object.create(null));
    setInternalSlot(O,SLOTS.SYMBOLS,Object.create(null));
    setInternalSlot(O,SLOTS.PROTOTYPE,prototype || null);
    setInternalSlot(O,SLOTS.EXTENSIBLE, true);
    return O;
}
OrdinaryObject.prototype = {
    constructor: OrdinaryObject,
    type: "object",
    toString: function () {
        return "[object OrdinaryObject]";
    },
    Get: function (P, R) {
        return OrdinaryObjectGet(this, P, R);
    },
    Set: function (P, V, R) {
        return Set(this, P, V, R);
    },
    Invoke: function (P, A, R) {
        return OrdinaryObjectInvoke(this, P, A, R);
    },
    Delete: function (P) {
        return Delete(this, P);
    },
    DefineOwnProperty: function (P, D) {
        return DefineOwnProperty(this, P, D);
    },
    GetOwnProperty: function (P) {
        return GetOwnProperty(this, P);
    },
    OwnPropertyKeys: function () {
        return OwnPropertyKeys(this);
    },
    Enumerate: function () {
        return Enumerate(this);
    },
    HasProperty: function (P) {
        return HasProperty(this, P);
    },
    HasOwnProperty: function (P) {
        if (IsPropertyKey(P)) {
            //P = unwrap(P);
            if (IsSymbol(P)) {
                if (this.Symbols[P.es5id] !== undefined) return true;
            } else {
                P = ToString(P);
                if (this.Bindings[P]) return true;
            }
        }
        return false;

    },
    GetPrototypeOf: function () {
        // return GetPrototypeOf(this);
        return this.Prototype;
    },
    SetPrototypeOf: function (P) {
        //    return SetPrototypeOf(this, P);
        this.Prototype = unwrap(P);
    },
    IsExtensible: function () {
        return IsExtensible(this);
    },
    PreventExtensions: function () {
        return PreventExtensions(this);
    }
};


function ObjectCreate(proto, internalDataList) {
    if (proto === undefined) proto = Get(getIntrinsics(), INTRINSICS.OBJECTPROTOTYPE);
    var O = OrdinaryObject(proto);
    /*
        new
     */
    if (internalDataList && Array.isArray(internalDataList)) {
        for (var i = 0, j = internalDataList.length; i < j; i++) {
            O[internalDataList[i]] = undefined;
        }
    }else
    /*
        legacy
     */
    if (internalDataList && typeof internalDataList === "object") {
        for (var k in internalDataList) {
            if (Object.hasOwnProperty.call(internalDataList, k)) {
                O[k] = internalDataList[k];
            }
        }
    }
    return O;
}


function ObjectDefineProperty(O, P, Desc) {
    if (IsDataDescriptor(Desc)) {
        callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O,P, Desc);
    } else if (IsAccessorDescriptor(Desc)) {
        callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O,P, Desc);
    }
    return O;
}

function ObjectDefineProperties(O, Properties) {
    var pendingException;
    if (Type(O) !== OBJECT) return newTypeError( "first argument is not an object");
    var props = ToObject(Properties);
    var names = OwnPropertyKeysAsList(props);
    var P, descriptors = [];
    var descObj, desc;
    for (P in names) {
        descObj = Get(props, names[P]);
        if (isAbrupt(descObj = ifAbrupt(descObj))) return descObj;
        desc = ToPropertyDescriptor(descObj);
        if (isAbrupt(desc = ifAbrupt(desc))) return desc;
        descriptors.push({
            P: names[P],
            desc: desc
        });
    }
    var pair, status;
    for (var i in descriptors) {
        pair = descriptors[i];
        P = pair.P;
        desc = pair.desc;
        status = DefineOwnPropertyOrThrow(O, P, desc);
        if (isAbrupt(status)) pendingException = status;
    }
    if (isAbrupt(pendingException)) return pendingException;
    return O;
}



function DeclarativeEnvironment(outer) {
    var de = Object.create(DeclarativeEnvironment.prototype);
    de.Bindings = Object.create(null);
    de.outer = outer || null;
    return de;
}
DeclarativeEnvironment.prototype = {
    constructor: DeclarativeEnvironment,
    toString: function () {
        return "[object DeclarativeEnvironment]";
    },
    HasBinding: function HasBinding(N) {
        return (N in this.Bindings);
    },
    CreateMutableBinding: function CreateMutableBinding(N, D) {
        var envRec = this.Bindings;
        var configValue = !!(D === true || D === undefined);
        if (N in envRec) return newReferenceError("CreateMutableBinding: "+ N + " is already declared");
        else createIdentifierBinding(envRec, N, undefined, configValue);
        return NormalCompletion();
    },
    CreateImmutableBinding: function CreateImmutableBinding(N) {
        var envRec = this.Bindings;
        var configValue = false;
        if (N in envRec) return newReferenceError( "CreateMutableBinding: " +N + " is already declared");
        else createIdentifierBinding(envRec, N, undefined, configValue, false);
        return NormalCompletion();
    },
    InitializeBinding: function (N, V) {
        var b, outerEnv;
        if (this.HasBinding(N)) {
            b = this.Bindings[N];
            if (!b.initialized) {
                b.value = V;
                b.initialized = true;
                return true;
            }
            return false;
        } else if (outerEnv = this.outer) return outerEnv.InitializeBinding(N, V);
        return false;
    },
    SetMutableBinding: function (N, V, S) {
        var b, o;
        if (this.HasBinding(N)) {
            b = this.Bindings[N];
            if (b.writable || !b.initialized) {
                b.value = V;
                if (!b.initialized) b.initialized = true;
            }
            return NormalCompletion(b.value);
        } else if (o = this.outer) return o.SetMutableBinding(N, V, S);
    },
    GetBindingValue: function (N, S) {
        var b;
        if (this.HasBinding(N)) {
            b = this.Bindings[N];
            if (!b.initialized) return NormalCompletion(undefined);
            //return newReferenceError( "unitialized binding '" + N+ "'");
            return NormalCompletion(b.value);
        } else if (this.outer) return this.outer.GetBindingValue(N, S);
        return newReferenceError( "GetBindingValue: Can not find " + N);
    },
    DeleteBinding: function (N) {
        if (this.HasBinding[N]) {
            this.Bindings[N] = undefined;
            delete this.Bindings[N];
        } else if (this.outer) return this.outer.DeleteBinding(N);
    },
    HasThisBinding: function () {
        return false;
    },
    HasSuperBinding: function () {
        return false;
    },
    WithBaseObject: function () {
        return undefined;
    }
};

function NewDeclarativeEnvironment(E) {
    return DeclarativeEnvironment(E);
}

/**
 * Created by root on 31.03.14.
 */

function IdentifierBinding(N, V, D, W) {
    var ib = Object.create(null);
    ib.name = N;
    ib.value = V;
    ib.writable = W === undefined ? true : W;
    ib.initialized = false;
    ib.configurable = !!D;
    return ib;
}

function createIdentifierBinding(envRec, N, V, D, W) {
    return (envRec[N] = IdentifierBinding(N, V, D, W));
}

function GetIdentifierReference(lex, name, strict) {
    if (lex === null) {
        // unresolvable ref.
        return Reference(name, undefined, strict);
    }
    var exists = lex.HasBinding(name);
    var outer;
    if (exists) {
        return Reference(name, lex, strict);
    } else {
        outer = lex.outer;
        return GetIdentifierReference(outer, name, strict);
    }

}


function GetThisEnvironment () {
    var env = getLexEnv();
    do {
        if (env.HasThisBinding()) return env;
    } while (env = env.outer);
}

function ThisResolution () {
    var env = GetThisEnvironment();
    return env.GetThisBinding();
}

function GetGlobalObject () {
    var realm = getRealm();
    return realm.globalThis;
}

function FunctionEnvironment(F, T) {
    var fe = Object.create(FunctionEnvironment.prototype);
    fe.BoundFunction = F;
    fe.thisValue = T;
    fe.Bindings = Object.create(null);
    fe.outer = getInternalSlot(F,SLOTS.ENVIRONMENT);
    return fe;
}
FunctionEnvironment.prototype = assign(FunctionEnvironment.prototype, {
    HasThisBinding: function () {
        return true;
    },
    GetThisBinding: function () {
        return this.thisValue;
    },
    HasSuperBinding: function () {
        return !!this.BoundFunction.HomeObject;
    },
    GetSuperBase: function () {
        return this.BoundFunction.HomeObject;
    },
    GetMethodName: function () {
        return this.BoundFunction.MethodName;
    },
    WithBaseObject: function () {
        debug("FunctionEnv: WithBaseObject");
        return undefined;
    },
    toString: function () {
        return "[object FunctionEnvironment]";
    },
    constructor: FunctionEnvironment
});
addMissingProperties(FunctionEnvironment.prototype, DeclarativeEnvironment.prototype);

function NewFunctionEnvironment(F, T) {
    Assert(getInternalSlot(F, SLOTS.THISMODE) !== "lexical", "thisMode === 'lexical'?");
    var env = FunctionEnvironment(F, T);
    env.thisValue = T;
    if (getInternalSlot(F, SLOTS.NEEDSSUPER) === true) {
        var home = getInternalSlot(F, SLOTS.HOMEOBJECT);
        if (home === undefined) return newReferenceError(format("S_IS_UNDEFINED", "[[HomeObject]]"));
        env.HomeObject = home;
        env.MethodName = getInternalSlot(F, SLOTS.METHODNAME);
    } else {
        env.HomeObject = undefined;
    }
    env.outer = getInternalSlot(F, SLOTS.ENVIRONMENT);
    return env;
}


function ObjectEnvironment(O, E) {
    var oe = Object.create(ObjectEnvironment.prototype);
    oe.Unscopables = Object.create(null);
    oe.BoundObject = O;
    oe.outer = E;
    return oe;
}
ObjectEnvironment.prototype = {
    constructor: ObjectEnvironment,
    toString: function () {
        return "[object ObjectEnvironment]";
    },
    HasBinding: function (N) {
        var bindings = this.BoundObject;
        if (this.Unscopables[N]) return false;
        if (this.withEnvironment) {
            var unscopables = callInternalSlot(SLOTS.GET, bindings, $$unscopables, bindings);
            if (isAbrupt(unscopables = ifAbrupt(unscopables))) return unscopables;
            if (Type(unscopables) === OBJECT) {
                var found = HasOwnProperty(unscopables, N);
                if (isAbrupt(found = ifAbrupt(found))) return found;
                if (found === true) return false;
            }
        }
        return HasProperty(bindings, N);
    },
    CreateMutableBinding: function (N, D) {
        var O = this.BoundObject;
        var configValue = D === true;
        return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O,N, {
            value: undefined,
            writable: true,
            enumerable: false,
            configurable: configValue
        });
    },
    CreateImmutableBinding: function (N) {
        var O = this.BoundObject;
        return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O,N, {
            value: undefined,
            writable: false,
            enumerable: false,
            configurable: false
        });
    },
    GetBindingValue: function (N) {
        var O = this.BoundObject;
        Assert(Type(O) === OBJECT, "ObjectEnvironment: BoundObject has to be of Type Object");
        return O.Get(N, O);
    },

    InitializeBinding: function (N, V) {
        var O = this.BoundObject;
        return O.Set(N, V, O);
    },
    SetMutableBinding: function (N, V) {
        var O = this.BoundObject;
        return O.Set(N, V, O);
    },
    DeleteBinding: function (N) {
        var O = this.BoundObject;
        return O.Delete(N);
    },

    HasThisBinding: function () {
        return true;
    },

    HasSuperBinding: function () {
        return !!this.HomeObject;
    },
    GetSuperBase: function () {
        return this.HomeObject;
    },

    WithBaseObject: function () {
        var O = this.BoundObject;
        return O;
    },
    GetThisBinding: function () {
        var O = this.BoundObject;
        return O;
    }
};

function NewObjectEnvironment(O, E) {
    return ObjectEnvironment(O, E);
}




function GlobalEnvironment(globalThis, intrinsics) {
    var ge = Object.create(GlobalEnvironment.prototype);
    ge.outer = null;
    ge.objEnv = NewObjectEnvironment(globalThis, ge.outer);
    ge.objEnv.toString = function () {
        return "[object GlobalVariableEnvironment]";
    };
    ge.LexEnv = DeclarativeEnvironment(ge.objEnv);
    ge.LexEnv.toString = function () {
        return "[object GlobalLexicalEnvironment]";
    };
    var varNames = ge.VarNames = Object.create(null);
    for (var k in globalThis.Bindings) {
        if (HasOwnProperty(globalThis, k)) varNames[k] = true;
    }
    return ge;
}
GlobalEnvironment.prototype = {
    constructor: GlobalEnvironment,
    toString: function () {
        return "[object GlobalEnvironment]";
    },
    HasBinding: function (N) {
        if (this.LexEnv.HasBinding(N)) return true;
        return this.objEnv.HasBinding(N);
    },
    CreateMutableBinding: function (N, D) {
        return this.LexEnv.CreateMutableBinding(N, D);
    },
    CreateImmutableBinding: function (N) {
        return this.LexEnv.CreateImmutableBinding(N);
    },
    GetBindingValue: function (N, S) {
        if (this.LexEnv.HasBinding(N)) return this.LexEnv.GetBindingValue(N, S);
        else if (this.objEnv.HasBinding(N)) return this.objEnv.GetBindingValue(N, S);
    },
    InitializeBinding: function (N, V, S) {
        if (this.LexEnv.HasBinding(N)) return this.LexEnv.InitializeBinding(N, V, S);
        else if (this.objEnv.HasBinding(N)) return this.objEnv.InitializeBinding(N, V, S);
        return false;
    },
    SetMutableBinding: function (N, V, S) {
        if (this.LexEnv.HasBinding(N)) return this.LexEnv.SetMutableBinding(N, V, S);
        else if (this.objEnv.HasBinding(N)) return this.objEnv.SetMutableBinding(N, V, S);
        return false;
    },
    DeleteBinding: function (N) {
        if (this.LexEnv.HasBinding(N)) {
            return this.LexEnv.DeleteBinding(N);
        } else if (this.objEnv.HasBinding(N)) {
            var status = this.objEnv.DeleteBinding(N);
            if (status === true) {
                this.VarNames[N] = undefined;
            }
            return status;
        }
        return false;
    },
    HasThisBinding: function () {
        return true;
    },
    HasSuperBinding: function () {
        return false;
    },
    WithBaseObject: function () {
        return this.objEnv;
    },
    GetThisBinding: function () {
        return this.objEnv.GetThisBinding();
    },
    HasVarDeclaration: function (N) {
        return this.VarNames[N];

    },
    HasLexicalDeclaration: function (N) {
        return this.LexEnv.HasBinding(N);

    },
    CanDeclareGlobalVar: function (N) {
        if (this.objEnv.HasBinding(N)) return true;
        return this.objEnv.BoundObject.IsExtensible();
    },
    CanDeclareGlobalFunction: function (N) {
        var objRec = this.objEnv;
        var globalObject = objRec.BoundObject;
        var extensible = globalObject.IsExtensible();
        if (isAbrupt(extensible = ifAbrupt(extensible))) return extensible;
        if (objRec.HasBinding(N) === false) return extensible;
        var existingProp = globalObject.GetOwnProperty(N);
        if (!existingProp) return extensible;
        if (IsDataDescriptor(existingProp) && existingProp.writable && existingProp.enumerable) return true;
        return false;
    },
    CreateGlobalVarBinding: function (N, D) {
        var cpl = this.objEnv.CreateMutableBinding(N, D);
        if (isAbrupt(cpl = ifAbrupt(cpl))) return cpl;
        cpl = this.objEnv.InitializeBinding(N, undefined);
        if (isAbrupt(cpl = ifAbrupt(cpl))) return cpl;
        this.VarNames[N] = true;
    },
    CreateGlobalFunctionBinding: function (N, V, D) {
        var cpl = this.objEnv.CreateMutableBinding(N, D);
        if (isAbrupt(cpl = ifAbrupt(cpl))) return cpl;
        cpl = this.objEnv.InitializeBinding(N, V);
        if (isAbrupt(cpl = ifAbrupt(cpl))) return cpl;
        this.VarNames[N] = true;
    }
};

function NewGlobalEnvironment(global) {
    return GlobalEnvironment(global);
}

var OBJECT = 1, // "object"
    NUMBER = 2, // "number"
    STRING = 3, // "string",
    SYMBOL = 4, // "symbol",
    BOOLEAN = 5, // "boolean",
    REFERENCE = 6, // "reference",
    ENVIRONMENT = 7, // "environment",
    COMPLETION = 8, //"completion",
    UNDEFINED = 9, // "undefined",
    NULL = 10; // "null";

var object_tostring_to_type_table = {
    __proto__: null,
    "[object SymbolPrimitiveType]": SYMBOL,
    "[object Reference]": REFERENCE,
    "[object CompletionRecord]": COMPLETION,
    "[object GlobalEnvironment]": ENVIRONMENT,
    "[object GlobalVariableEnvironment]": ENVIRONMENT,
    "[object GlobalLexicalEnvironment]": ENVIRONMENT,
    "[object ObjectEnvironment]": ENVIRONMENT,
    "[object FunctionEnvironment]": ENVIRONMENT,
    "[object DeclarativeEnvironment]": ENVIRONMENT,
    "[object OrdinaryObject]": OBJECT,
    "[object OrdinaryFunction]": OBJECT,
    "[object ProxyExoticObject]": OBJECT,
    "[object PromiseExoticObject]": OBJECT,
    "[object IntegerIndexedExoticObject]": OBJECT,
    "[object StringExoticObject]": OBJECT,
    "[object ArrayExoticObject]": OBJECT,
    "[object ArgumentsExoticObject]": OBJECT,
    "[object TypeDescriptorExoticObject]": OBJECT,
    "[object TypeExoticObject]": OBJECT
};
var primitive_type_string_table = {
    __proto__:null,
    "[object SymbolPrimitiveType]": "symbol",
    "number": "number",
    "string": "string",
    "boolean": "boolean",
    "undefined": "undefined"
};

function Type(O) {
    var type = typeof O;
    if (type === "object") {
        if (O === null) return NULL;
        if (O instanceof CompletionRecord) return Type(O.value);
        return object_tostring_to_type_table[O.toString && O.toString()] || OBJECT;
    }
    switch(type) {
        case "number":
            return NUMBER;
        case "boolean":
            return BOOLEAN;
        case "string":
            return STRING;
        case "symbol":
            return SYMBOL;
        case "undefined":
            return UNDEFINED;
    }
}

var EnvironmentType = {
  "[object ObjectEnvironment]":true,
  "[object DeclarativeEnvironment]": true,
  "[object FunctionEnvironment]": true,
  "[object GlobalLexicalEnvironment]": true,
  "[object GlobalVariableEnvironment]":true,
  "[object GlobalEnvironment]": true
};
function ToPrimitive(V, prefType) {
    var type = typeof V;
    if (V === null) return V;
    if (V === undefined) return V;
    if (type === "object") {

        var s = V.toString();
        if (s === "[object CompletionRecord]") {
            return ToPrimitive(V.value, prefType);
        }
        /* else if (s === "[object OrdinaryObject]") {*/
        else if (hasInternalSlot(V, SLOTS.NUMBERDATA)) return thisNumberValue(V);
        else if (hasInternalSlot(V, SLOTS.STRINGDATA)) return thisStringValue(V);
        else if (hasInternalSlot(V, SLOTS.BOOLEANDATA)) return thisBooleanValue(V);
        else if (hasInternalSlot(V, SLOTS.SYMBOLDATA)) return thisSymbolValue(V);
        else if (s === "[object SymbolPrimitiveType]") {
            return V;
        } else if (EnvironmentType[s]) {
            return newTypeError("Can not convert an environment to a primitive");
        }
        var v = V.valueOf();
        if (v === false) return false;
        if (v === true) return true;
        if (typeof v === "string") return v;
        if (typeof v === "number") return v;
    } else {
        if (type === "boolean") return !!V;
        if (type === "string") return "" + V;
        if (type === "number") return +V;
    }
    if (Type(V) === SYMBOL) return V;
    var hint;
    var exoticToPrim;
    if (!prefType) hint = "default";
    if (prefType === "string") hint = "string";
    if (prefType === "number") hint = "number";
    exoticToPrim = Get(V, $$toPrimitive);
    if (isAbrupt(exoticToPrim = ifAbrupt(exoticToPrim))) return exoticToPrim;
    var result;
    if (exoticToPrim !== undefined) {
        if (!IsCallable(exoticToPrim)) return newTypeError( "exotic ToPrimitive of object is not a function");
        result = exoticToPrim.Call(V, [hint]);
        if (isAbrupt(result = ifAbrupt(result))) return result;
        if (result !== undefined && Type(result) !== OBJECT) return result;
        else return newTypeError( "Can not convert the object to a primitive with exotic ToPrimitive")
    }
    if (hint === "default") hint = "number";
    return OrdinaryToPrimitive(V, hint);
}

function OrdinaryToPrimitive(O, hint) {
    Assert(Type(O) === OBJECT, "o must be an object");
    Assert(Type(hint) === STRING && (hint === "string" || hint === "number"), "hint must be a string equal to the letters string or number");
    var tryFirst;
    var trySecond;
    var list = (hint === "string") ? ["toString", "valueOf"] : ["valueOf", "toString"];
    var func, result;
    for (var i = 0; i < 2; i++) {
        func = Get(O, list[i]);
        if (isAbrupt(func = ifAbrupt(func))) return func;
        if (IsCallable(func)) {
            result = func.Call(O, []);
            if (isAbrupt(result = ifAbrupt(result))) return result;
            if (result !== undefined && Type(result) !== OBJECT) return result;
            else return newTypeError( "Can not convert the object to a primitive with OrdinaryToPrimitive by calling " + list[i]);
        }
    }
    return newTypeError( "Can not convert object to primitive with OrdinaryToPrimitive (end)");
}
var ReturnZero = {
    "NaN": true,
    "Infinity": true,
    "-Infinity": true,
    "0": true
};
var ReturnNaN = {
    "NaN": true
};
var ReturnNum = {
    "Infinity": true,
    "-Infinity": true,
    "0": true
};

var toInt8View = new Int8Array(1);
var toUint8View = new Uint8Array(1);
var toUint8ClampView = new Uint8ClampedArray(1);

/*
    soon i know how to cast better ;-)
*/

function ToInt8(V) {
    var view = new Int8Array(1);
    return toInt8View[0] = V;
}
function ToUint8(V) {
    return toUint8View[0] = V;
}
function ToUint8Clamp(V) {
    return toUint8ClampView[0] = V;
}
function ToUint16(V) {
    var number = ToNumber(V);
    if (isAbrupt(number = ifAbrupt(number))) return number;
    if (ReturnZero[number]) return +0;
    var int = sign(number) * floor(abs(number));
    var int16bit = int % (Math.pow(2, 16));
    return int16Bit;
}
function ToInt32(V) {
    var number = ToNumber(V);
    if (isAbrupt(number = ifAbrupt(number))) return number;
    if (ReturnZero[number]) return +0;
    var int = sign(number) * floor(abs(number));
    var int32bit = int % (Math.pow(2, 32));
    if (int >= (Math.pow(2, 31))) return int32bit - (Math.pow(2, 32));
    return int32bit;
}
function ToUint32(V) {
    var number = ToNumber(V);
    if (isAbrupt(number = ifAbrupt(number))) return number;
    if (ReturnZero[number]) return +0;
    return number >>> 0;
    //var int = sign(number) * floor(abs(number));
    //var int32bit = int % (Math.pow(2, 32));
    //return int32bit;
}
function ToInteger(V) {
    var number = ToNumber(V);
    if (isAbrupt(number = ifAbrupt(number))) return number;
    if (ReturnNaN[number]) return +0;
    if (ReturnNum[number]) return number;
    // return sign(number) * floor(abs(number));
    return number|0;
}
function ToLength(V) {
    var len = ToInteger(V);
    if (isAbrupt(len = ifAbrupt(len))) return len;
    if (len <= 0) return Completion("normal", 0, "");
    return Completion("normal", min(len, (Math.pow(2, 53)) - 1), "");
}
function ToBoolean(V) {
    var type = Type(V);
    if (V instanceof CompletionRecord) return ToBoolean(V.value);
    if (V === undefined) return false;
    if (V === null) return false;
    if (type === BOOLEAN) V = thisBooleanValue(V);
    if (typeof V === "boolean") {
        return V;
    }
    if (type === NUMBER) V = thisNumberValue(V);
    if (typeof V === "number") {
        return !(V === +0 || V === -0 || V !== V);
    }

    if (type === STRING) V = thisStringValue(V);
    if (typeof V === "string") {
        return !(V === "" || V.length === 0);

    }
    if (V instanceof SymbolPrimitiveType) return true;
    return Type(V) === OBJECT;
}
function ToNumber(V) {
    var T;
    if (isAbrupt(V)) return V;
    if (V instanceof CompletionRecord) return ToNumber(V.value);
    if (V === undefined) return NaN;
    if (V === null) return +0;
    if (V === true) return 1;
    if (V === false) return 0;
    if ((T = Type(V)) === NUMBER) return V;
    if (T === STRING) return +V;
    if (T === STRING) {
        var primVal = ToPrimitive(V, "number");
        return ToNumber(primVal);
    }
    return +V;
}
function ToString(V) {
    var t;
    var n, k, s;
    if (V instanceof CompletionRecord) return ToString(V.value);
    if (V === null) return "null";
    if (V === false) return "false";
    if (V === true) return "true";
    if (V !== V) return "NaN";
    if ((t = Type(V)) === NUMBER || typeof v === "number") {
        if (V == 0) return "0";
        if (V < 0) return "-" + ToString(-V);
        if (V === Infinity) return "Infinity";
        return "" + V;
    }
    if (t === SYMBOL) {
        return newTypeError( "Can not convert symbol to string");
    }
    if (t === OBJECT) {
        if (hasInternalSlot(V, SLOTS.SYMBOLDATA)) return newTypeError( "Can not convert symbol to string");
        var primVal = ToPrimitive(V, "string");
        return ToString(primVal);
    }
    return "" + V;
}

function ToObject(V) {
    if (isAbrupt(V)) return V;
    if (V instanceof CompletionRecord) return ToObject(V.value);
    if (V === undefined) return newTypeError( "ToObject: can not convert undefined to object");
    if (V === null) return newTypeError( "ToObject: can not convert null to object");
    if (Type(V) === OBJECT) return V;
    if (V instanceof SymbolPrimitiveType) {
        var s = SymbolPrimitiveType();
        setInternalSlot(s, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.SYMBOLPROTOTYPE));
        setInternalSlot(s, SLOTS.SYMBOLDATA, V);
        return s;
    }
    if (typeof V === "number") {
        return OrdinaryConstruct(getIntrinsic(INTRINSICS.NUMBER), [V]);
    }
    if (typeof V === "string") {
        return OrdinaryConstruct(getIntrinsic(INTRINSICS.STRING), [V]);
    }
    if (typeof V === "boolean") {
        return OrdinaryConstruct(getIntrinsic(INTRINSICS.BOOLEAN), [V]);
    }
    // return V;
}
function CheckObjectCoercible(argument) {

    if (argument instanceof CompletionRecord) return CheckObjectCoercible(argument.value);
    else if (argument === undefined) return newTypeError(format("UNDEFINED_NOT_COERCIBLE"));

    else if (argument === null) return newTypeError(format("NULL_NOT_COERCIBLE"));

    var type = Type(argument);
    switch (type) {
        case BOOLEAN:
        case NUMBER:
        case STRING:
        case SYMBOL:
        case OBJECT:
            return argument;
            break;
        default:
            break;
    }
    return argument;
}

// 7.4.2014
function CanonicalNumericString (argument) {
    Assert(Type(argument) === STRING, "CanonicalNumericString: argument has to be a string");
    var n = ToNumber(argument);
    if (n === -0) return +0;
    if (SameValue(ToString(n), argument) === false) return undefined;
    return n;
}
/**
 * Created by root on 31.03.14.
 */


function SameValue(x, y) {
    if (isAbrupt(x = ifAbrupt(x))) return x;
    if (isAbrupt(y = ifAbrupt(y))) return y;
    if (Type(x) !== Type(y)) return false;
    if (Type(x) === NULL) return true;
    if (Type(x) === UNDEFINED) return true;
    if (Type(x) === NUMBER) {
        if (x === y) return true;
        if (x === "NaN" && y === "NaN") return true;
        if (x === +0 && y === -0) return false;
        if (x === -0 && y === +0) return false;
        return false;
    }
    if (Type(x) === STRING) {
        return (x.length === y.length) && x === y;

    }
    if (Type(x) === BOOLEAN) {
        return (x && y) || (!x && !y);

    }

    if (Type(x) === SYMBOL) {
        return x === y;
    }

    return x === y;

}

function SameValueZero(x, y) {
    if (isAbrupt(x = ifAbrupt(x))) return x;
    if (isAbrupt(y = ifAbrupt(y))) return y;
    if (Type(x) !== Type(y)) return false;

    if (IsTypeObject(x)) {
          // IsTypeObject(y)
         return SameValue(getInternalSlot(x, SLOTS.TYPEDESCRIPTOR), getInternalSlot(y, SLOTS.TYPEDESCRIPTOR))
             && SameValue(getInternalSlot(x, SLOTS.VIEWEDARRAYBUFFER), getInternalSlot(y, SLOTS.VIEWEDARRAYBUFFER))
             && SameValue(getInternalSlot(x, SLOTS.BYTEOFFSET), getInternalSlot(y, SLOTS.BYTEOFFSET))
             && SameValue(getInternalSlot(x, SLOTS.OPACITY), getInternalSlot(y, SLOTS.OPACITY));

    }

    if (Type(x) === NULL) return true;
    if (Type(x) === UNDEFINED) return true;
    if (Type(x) === NUMBER) {
        if (x === y) return true;
        if (x === "NaN" && y === "NaN") return true;
        if (x === +0 && y === -0) return true;
        return x === -0 && y === +0;

    }
    if (Type(x) === STRING) {
        return (x.length === y.length) && x === y;

    }
    if (Type(x) === BOOLEAN) {
        return (x && y) || (!x && !y);

    }

    if (Type(x) === SYMBOL) {
        return x === y;
    }

    return x === y;

}


/*

    the following three functions are not used,
    because of a native strict equal and abstract equal
    but will be completed somewhen

 */

function StrictEqualityComparison(x, y) {
    var tx = Type(x);
    var ty = Type(y);

    if (tx !== ty) return false;

    if (tx === UNDEFINED && ty === NULL) return false;
    if (ty === UNDEFINED && tx === NULL) return false;

}

function AbstractEqualityComparison(x, y) {
    var tx = Type(x);
    var ty = Type(y);

    if (tx === ty) return StrictEqualityComparison(x, y);

    if (tx === UNDEFINED && ty === NULL) return true;
    if (ty === UNDEFINED && tx === NULL) return true;

}

function AbstractRelationalComparison(x,y,leftFirst) {
    var tx = Type(x);
    var ty = Type(y);

}

exports.StrictEqualityComparison = StrictEqualityComparison;
exports.AbstractEqualityComparison = AbstractEqualityComparison;
exports.AbstractRelationalComparison = AbstractRelationalComparison;


function readPropertyDescriptor(object, name) {
    if (IsSymbol(name)) return object[SLOTS.SYMBOLS][name.es5id];
    return object[SLOTS.BINDINGS][name];
}

function writePropertyDescriptor(object, name, value) {
    if (IsSymbol(name))    return object[SLOTS.SYMBOLS][name.es5id] = value;
    return object[SLOTS.BINDINGS][name] = value;
}
exports.writePropertyDescriptor = writePropertyDescriptor;
exports.readPropertyDescriptor = readPropertyDescriptor;


function CreateOwnAccessorProperty(O, P, G, S) {
    Assert(Type(O) === OBJECT, "CreateAccessorProperty1");
    Assert(IsPropertyKey(P), "CreateAccessorProperty2");
    var D = Object.create(null);
    D.get = G;
    D.set = S;
    D.enumerable = true;
    D.configurable = true;
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, P, D);
}

function CreateDataProperty(O, P, V) {
    Assert(Type(O) === OBJECT, "CreateDataProperty1");
    Assert(IsPropertyKey(P), "CreateDataProperty2");
    var newDesc = Object.create(null);
    newDesc.value = V;
    newDesc.writable = true;
    newDesc.enumerable = true;
    newDesc.configurable = true;
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, P, newDesc);
}

function CreateDataPropertyOrThrow(O, P, V) {
    Assert(Type(O) === OBJECT, "CreateDataPropertyOrThrow1");
    Assert(IsPropertyKey(P), "CreateDataPropertyOrThrow2");
    var success = CreateDataProperty(O, P, V);
    if (isAbrupt(success = ifAbrupt(success))) return success;
    if (success === false) return newTypeError(format("CREATEDATAPROPERTYORTHROW_FAILED"));
    return success;
}

function IsPropertyKey(P) {
    if (typeof P === "string") return true;
    return P instanceof SymbolPrimitiveType;

}

function PropertyDescriptor(V, W, E, C) {
    var D = Object.create(null); //Object.create(null);
    D.value = V;
    D.writable = W !== undefined ? W : true;
    D.enumerable =  E !== undefined ? E : true;
    D.configurable =  C !== undefined ? C : true;
    return D;
}

function IsAccessorDescriptor(desc) {
    if (desc == null) return false;
    if (typeof desc !== "object") return false;
    return ("get" in desc) || ("set" in desc);

}

function IsDataDescriptor(desc) {
    if (desc == null) return false;
    if (typeof desc !== "object") return false;
    return ("value" in desc) || ("writable" in desc);

}

function IsGenericDescriptor(desc) {    // hat nur enum oder config props
    if (desc === null) return false;
    if (typeof desc !== "object") return false;
    return !IsAccessorDescriptor(desc) && !IsDataDescriptor(desc) &&
        (("configurable" in desc) || ("enumerable" in desc));

}

function FromPropertyDescriptor(desc) {
    if (desc == undefined) return undefined;
    if (desc.Origin) return desc.Origin;
    var obj = ObjectCreate();
    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj,"value",        PropertyDescriptor(desc.value, true, true, true));
    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj,"writable",     PropertyDescriptor(desc.writable, true, true, true));
    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj,"get",          PropertyDescriptor(desc.get, true, true, true));
    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj,"set",          PropertyDescriptor(desc.set, true, true, true));
    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj,"enumerable",   PropertyDescriptor(desc.enumerable, true, true, true));
    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj,"configurable", PropertyDescriptor(desc.configurable, true, true, true));
    return obj;
}

function ToPropertyDescriptor(O) {
    if (isAbrupt(O = ifAbrupt(O))) return O;
    if (Type(O) !== OBJECT) return newTypeError(format("S_NOT_OBJECT", "ToPropertyDescriptor: argument"));
    var desc = Object.create(null);

    if (HasProperty(O, "enumerable")) {
        var enume = Get(O, "enumerable");
        if (isAbrupt(enume = ifAbrupt(enume))) return enume;
        desc.enumerable = enume;
    }
    if (HasProperty(O, "writable")) {
        var write = Get(O, "writable");
        if (isAbrupt(write = ifAbrupt(write))) return write;
        desc.writable = write;
    }
    if (HasProperty(O, "configurable")) {
        var conf = Get(O, "configurable");
        if (isAbrupt(conf = ifAbrupt(conf))) return conf;
        desc.configurable = conf;
    }
    if (HasProperty(O, "value")) {
        var value = Get(O, "value");
        if (isAbrupt(value = ifAbrupt(value))) return value;
        desc.value = value;
    }

    if (HasProperty(O, "get")) {
        var get = Get(O, "get");
        if (isAbrupt(get = ifAbrupt(get))) return get;
        desc.get = get;
    }
    if (HasProperty(O, "set")) {
        var set = Get(O, "set");
        if (isAbrupt(set = ifAbrupt(set))) return set;
        desc.set = set;
    }
    desc.Origin = O;
    return desc;
}

function IsCompatiblePropertyDescriptor(extensible, Desc, current) {
    return ValidateAndApplyPropertyDescriptor(undefined, undefined, extensible, Desc, current);
}

function CompletePropertyDescriptor(Desc, LikeDesc) {
    Assert(typeof LikeDesc === "object" || LikeDesc === undefined, "LikeDesc has to be object or undefined");
    Assert(typeof Desc === "object");
    if (LikeDesc === undefined) LikeDesc = {
        value: undefined,
        writable: false,
        get: undefined,
        set: undefined,
        enumerable: false,
        configurable: false
    };
    if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
        if (typeof Desc.writable === "undefined") Desc.writable = LikeDesc.writable;
        if (typeof Desc.value === "undefined") Desc.value = LikeDesc.value;
    } else {
        if (typeof Desc.get === "undefined") Desc.get = LikeDesc.get;
        if (typeof Desc.set === "undefined") Desc.set = LikeDesc.set;
    }
    if (typeof Desc.enumerable === "undefined") Desc.enumerable = LikeDesc.enumerable;
    if (typeof Desc.configurable === "undefined") Desc.configurable = LikeDesc.configurable;
    return Desc;
}

function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
    var same = true, d;
    var isDataDesc = IsDataDescriptor(Desc);
    var isGenericDesc = IsGenericDescriptor(Desc);
    var isAccessorDesc = IsAccessorDescriptor(Desc);

    if (O) Assert(IsPropertyKey(P), "ValidateAndApplyPropertyDescriptor: expecting property key if object is present");

    Assert(typeof Desc === "object", "ValidateAndApplyPropertyDescriptor: Desc must be a descriptor object (btw. current is " + ( !! current) + ")");

    var changeType = "reconfigure"; // o.observe

    if (!current) {

        if (!extensible) return false;
        
        Assert(extensible, "object has to be extensible");

        if (isGenericDesc || isDataDesc || isAccessorDesc) {
            if (O !== undefined) {
                writePropertyDescriptor(O, P, Desc);
            }
        }
        //  var R = CreateChangeRecord("add", O, P, current, Desc);
        return true;

    } else if (current && Desc) {

        var isDataCurrent = IsDataDescriptor(current);
        var isGenericCurrent = IsGenericDescriptor(current);
        var isAccessorCurrent = IsAccessorDescriptor(current);

        if (Desc.get === undefined &&
            Desc.set === undefined &&
            Desc.writable === undefined &&
            Desc.enumerable === undefined &&
            Desc.configurable === undefined &&
            Desc.value === undefined) {
            return true;
        }

        for (d in Desc) {
            if (Object.hasOwnProperty.call(Desc, d))
                if (current[d] !== Desc[d]) same = false;
        }
        if (same) return true;

        if (current.configurable === false) {
            if (Desc.configurable === true) return false;
            if (Desc.enumerable === !current.enumerable) return false;
        }

        if (isDataCurrent && isDataDesc) {

            if (current.configurable === false) {
                if (!current.writable === Desc.writable) return false;
                if (!current.writable) {
                    if (("value" in Desc) && (current.value !== Desc.value)) return false;
                }
            }

            /*if (current.writable) {
             writePropertyDescriptor(O, P, Desc);
             return true;
             }*/

        } else if (isAccessorCurrent && isAccessorDesc) {

            if (current.configurable === false) {
                if (("set" in Desc) && (Desc.set !== current.set)) return false;
                if (("get" in Desc) && (Desc.get !== current.get)) return false;
            }

            /* else {
             if (Desc.set === undefined) Desc.set === current.set;
             if (Desc.get === undefined) Desc.get === current.get;
             writePropertyDescriptor(O, P, Desc);
             return true;
             }*/

        } else if (isGenericDesc) {
            if (current.configurable === false) return false;
            // convert to accessor
            if (isDataCurrent) {
                if (O !== undefined) {
                    writePropertyDescriptor(O, P, {
                        get: undefined,
                        set: undefined,
                        enumerable: current.enumerable,
                        configurable: current.configurable
                    });
                    return true;
                }
                // convert to data
            } else if (isAccessorCurrent) {
                if (O !== undefined) {
                    writePropertyDescriptor(O, P, {
                        value: undefined,
                        writable: false,
                        enumerable: current.enumerable,
                        configurable: current.configurable
                    });
                    return true;
                }
            }
        }

        if (O !== undefined) {
            if (isDataDesc && !current.writable) return false;
            for (d in Desc) {
                if (Object.hasOwnProperty.call(Desc, d)) {
                    current[d] = Desc[d];
                }
            }
            writePropertyDescriptor(O, P, current);
        }
        return true;
    }
}

/**
 * Created by root on 30.03.14.
 */


function Put(O, P, V, Throw) {
    Assert(Type(O) === OBJECT, "O != OBJECT");
    Assert(IsPropertyKey(P));
    Throw = !!Throw;
    var success = callInternalSlot(SLOTS.SET, O, P, V, O);
    if (isAbrupt(success = ifAbrupt(success))) return success;
    if (success === false && Throw === true) return newTypeError(format("PUT_FAILS_AT_S", P));
    return NormalCompletion(success);
}

function DefineOwnPropertyOrThrow(O, P, D) {
    Assert(Type(O) === OBJECT, "O != OBJECT");
    Assert(IsPropertyKey(P));
    var success = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, P, D);
    if (isAbrupt(success = ifAbrupt(success))) return success;
    if (success === false) return newTypeError(format("DEFPOT_FAILS_AT_S", P));
    return NormalCompletion(success);
}

function DeletePropertyOrThrow(O, P) {
    Assert(Type(O) === OBJECT, "object expected");
    Assert(IsPropertyKey(P));
    var success = Delete(O, P);
    if (isAbrupt(success = ifAbrupt(success))) return success;
    if (success === false) return newTypeError(format("DELPOT_FAILS_AT_S", P));
    return NormalCompleion(success);
}

function OrdinaryDefineOwnProperty(O, P, D) {
    var current = OrdinaryGetOwnProperty(O, P);
    var extensible = getInternalSlot(O, SLOTS.EXTENSIBLE);
    return ValidateAndApplyPropertyDescriptor(O, P, extensible, D, current);
}

/*
function GetOwnProperty(O, P) {
    return OrdinaryGetOwnProperty(O, P);
}
*/

function OrdinaryGetOwnProperty(O, P) {
    Assert(IsPropertyKey(P));
    var D = Object.create(null); // value: undefined, writable: true, enumerable: true, configurable: true };
    var X = readPropertyDescriptor(O, P);
    if (X === undefined) return;

    if (IsDataDescriptor(X)) {
        D.value = X.value;
        D.writable = X.writable;
    } else if (IsAccessorDescriptor(X)) {
        D.set = X.set;
        D.get = X.get;
    }

    D.configurable = X.configurable;
    D.enumerable = X.enumerable;
    return D;
}

function ToPropertyKey(P) {
    if ((P = ifAbrupt(P)) && (isAbrupt(P) || P instanceof SymbolPrimitiveType)) return P;
    return ToString(P);
}


function GetOwnPropertyKeys(O, type) {
    var obj = ToObject(O);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var keys;

    // differ from spec a little (i had to add a backref on desc coz there is only es5id as key)
    if (type === "symbol") {
        keys = OwnPropertySymbols(O);
    } else if (type === "string") {
        keys = OwnPropertyKeys(O);
    }

    if (isAbrupt(keys = ifAbrupt(keys))) return keys;
    var nameList = [];
    var gotAllNames = false;
    var next, nextKey;
    while (!gotAllNames) {
        next = IteratorStep(keys);
        if (isAbrupt(next = ifAbrupt(next))) {
    	    return next;
    	}
        if (!next) gotAllNames = true;
        else {
            nextKey = IteratorValue(next);
            if (isAbrupt(nextKey = ifAbrupt(nextKey))) return nextKey;

            // differs from spec if (Type(nextKey)==type) by if (type == "") above
        	nameList.push(nextKey);

        }
    }
    return CreateArrayFromList(nameList);
}


function OwnPropertyKeys(O, type) {
    var keys = [];
    var bindings = getInternalSlot(O,SLOTS.BINDINGS);
    var key;
    for (key in bindings) {
        keys.push(key);
    }
    return MakeListIterator(keys);
}

function OwnPropertyKeysAsList(O) {
    var keys = [];
    var bindings = getInternalSlot(O, SLOTS.BINDINGS);
    var key;
    for (key in bindings) {
        keys.push(key);
    }
    return keys;
}

/*
    trying to fix es5id and Object.getOwnPropertySymbols
    a) backref (a-)
    b) second global registry (of all symbols, no matter what the user says)
*/

function OwnPropertySymbols(O) {
    var keys = [];
    var symbols = getInternalSlot(O, SLOTS.SYMBOLS);
    var key, desc;
    for (key in symbols) {
        if (desc = symbols[key]) {
            Assert(desc.symbol.es5id === key, "symbol key and backref should be the same");
            keys.push(desc.symbol); // the backref desc.symbol is stuffed into in writePropertyDescriptor()
        }
    }
    return MakeListIterator(keys);
}


function GetMethod(O, P) {
    Assert(Type(O) === OBJECT && IsPropertyKey(P) === true, "o has to be object and p be a valid key");
    var method = callInternalSlot(SLOTS.GET, O, P, O);
    if (isAbrupt(method = ifAbrupt(method))) return method;
    if (IsCallable(method)) return method;
    else return newTypeError( "GetMethod: " + P + " can not be retrieved");
}

function SetIntegrityLevel(O, level) {
    Assert(Type(O) === OBJECT, "object expected");
    Assert(level === "sealed" || level === "frozen", "level must be sealed or frozen");
    var desc;
    
    if (level === "sealed" || level === "frozen") {
        var pendingException;
        var keys = OwnPropertyKeysAsList(O); // Array statt iterator
        var key;
        var status;
        if (level === "sealed") {
            for (var k in keys) {
                key = keys[k];
                desc = OrdinaryGetOwnProperty(O, key);
                if (desc && desc.configurable) {
                    desc.configurable = false;
                    status = DefineOwnPropertyOrThrow(O, key, desc);
                    if (isAbrupt(status)) {
                        if (!pendingException) pendingException = status;
                    }
                }
            }
        } else if (level === "frozen") {
            for (var k in keys) {
                key = keys[k];
                status = GetOwnProperty(O, k);
                if (isAbrupt(status)) {
                    if (!pendingException) pendingException = status;
                } else {
                    var currentDesc = unwrap(status);
                    if (currentDesc) {
                        if (IsAccessorDescriptor(currentDesc)) {
                            desc = Object.create(null);
                            desc.get = currentDesc.get;
                            desc.set = currentDesc.set;
                            desc.enumerable = currentDesc.enumerable;
                            desc.configurable = false;
                            status = DefineOwnPropertyOrThrow(O, key, desc);
                            if (isAbrupt(status)) {
                                if (!pendingException) pendingException = status;
                            }
                        } else {
                            desc = Object.create(null);
                            desc.value = currentDesc.value;
                            desc.writable = false;
                            desc.enumerable = currentDesc.enumerable;
                            desc.configurable = false;

                            status = DefineOwnPropertyOrThrow(O, key, desc);
                            if (isAbrupt(status)) {
                                if (!pendingException) pendingException = status;
                            }
                        }
                    }
                }
            }
        }
        if (pendingException) return pendingException;
        return PreventExtensions(O);
    }
}

function TestIntegrityLevel(O, level) {
    Assert(TyType(O) === OBJECT,"object expected");
    Assert(level === "sealed" || level === "frozen", "level must be sealed or frozen");
    var status = IsExtensible(O);
    if (isAbrupt(status = ifAbrupt(status))) return status;
    if (status === true) return false;
    var keys = OwnPropertyKeysAsList(O); // Array statt iterator
    if (isAbrupt(keys = ifAbrupt(keys))) return keys;
    var pendingException = undefined;
    var key;
    var configurable = false,
        writable = false;
    for (var k in keys) {
        key = keys[k];
        status = GetOwnProperty(O, key);
        if (isAbrupt(status = ifAbrupt(status))) {
            if (!pendingException) pendingException = status;
            configurable = true;
        } else {
            var currentDesc = unwrap(status);
            if (currentDesc !== undefined) {
                configurable = configurable && currentDesc.configurable;
                if (IsDataDescriptor(currentDesc)) {
                    writable = writable && currentDesc.writable;
                }
            }
        }
    }
    if (pendingException) return pendingException;
    if (level === "frozen" && writable) return false;
    if (configurable) return false;
}

function GetPrototypeOf(V) {
    if (Type(V) !== OBJECT) return newTypeError( "argument is not an object");
    return getInternalSlot(V, SLOTS.PROTOTYPE) || null;
}

function SetPrototypeOf(O, V) {
    if (Type(V) !== OBJECT && V !== null) return newTypeError( "Assertion: argument is either object or null, but it is not.");
    var extensible = getInternalSlot(O, SLOTS.EXTENSIBLE);
    var current = getInternalSlot(O, SLOTS.PROTOTYPE);
    if (SameValue(V, current)) return true;
    if (!extensible) return false;
    if (V !== null) {
        var p = V;
        while (p !== null) {
            if (SameValue(p, O)) return false;
            var nextp = GetPrototypeOf(p);
            if (isAbrupt(nextp = ifAbrupt(nextp))) return nextp;
            p = nextp;
        }
    }
    setInternalSlot(O, SLOTS.PROTOTYPE, V);
    return true;
}

function Delete(O, P) {
    var desc;
    if (IsSymbol(P)) desc = O.Symbols[P.es5id];
    else(desc = O.Bindings[P]);
    if (desc) {
        if (desc.configurable) {
            if (IsSymbol(P)) {
                O.Symbols[P.es5id] = undefined;
                delete O.Symbols[P.es5id];
            } else {
                O.Bindings[P] = undefined;
                delete O.Bindings[P];
            }
            return true;
        }
    }
    return false;
}

function Get(O, P) {
    Assert(Type(O) === OBJECT, "[[Get]] expecting object");
    Assert(IsPropertyKey(P), "[[Get]] expecting valid property key, got "+ P);
    return callInternalSlot(SLOTS.GET, O, P, O);
}

function OrdinaryObjectGet(O, P, R) {
    Assert(IsPropertyKey(P), "Get (object) expects a valid Property Key (got " + P + ")");
    var desc = callInternalSlot(SLOTS.GETOWNPROPERTY, O, P);
    if (isAbrupt(desc = ifAbrupt(desc))) return desc;
    if (desc === undefined) {
        var parent = GetPrototypeOf(O);
        if (isAbrupt(parent)) return parent;
        parent = ifAbrupt(parent);
        if (parent === null) return undefined;
        return callInternalSlot(SLOTS.GET, parent, P, R);
    }
    var getter;
    if (IsDataDescriptor(desc)) return desc.value;
    else if (IsAccessorDescriptor(desc)) {
        getter = desc.get;
        if (getter === undefined) return undefined;
        else return callInternalSlot(SLOTS.CALL, getter, R, []);
    }
    return undefined;
}

function Set(O, P, V, R) {
    var ownDesc, parent, setter;
    Assert(IsPropertyKey(P), "Set (object) expects a valid Property Key");
    ownDesc = callInternalSlot(SLOTS.GETOWNPROPERTY, O, P); // readPropertyDescriptor(O, P);
    if (isAbrupt(ownDesc = ifAbrupt(ownDesc))) return ownDesc;
    if (ownDesc === undefined) {
        parent = GetPrototypeOf(O);
        if (isAbrupt(parent = ifAbrupt(parent))) return parent;
        if (parent !== null) {
            return callInternalSlot(SLOTS.SET, parent,P, V, R);
        }
    }
    // von unter isdata hoch gehoben
    else if (IsAccessorDescriptor(ownDesc)) {
        var setter = ownDesc.set;
        if (setter === undefined) return false;
        var setterResult = callInternalSlot(SLOTS.CALL, setter, R, [V]);
        if (isAbrupt(setterResult)) return setterResult;
        return true;
    }
    ownDesc = {
        value: undefined,
        writable: true,
        configurable: true,
        enumerable: true
    };
    if (IsDataDescriptor(ownDesc)) {
        if (ownDesc.writable == false) return false;
        if (Type(R) !== OBJECT) return false;
        var existingDescriptor = callInternalSlot(SLOTS.GETOWNPROPERTY, R, P);
        if (isAbrupt(existingDescriptor = ifAbrupt(existingDescriptor))) return existingDescriptor;

        if (existingDescriptor !== undefined) {
            var valueDesc = {
                value: V
            };
            return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, R, P, valueDesc);
        } else {
            return CreateDataProperty(R, P, V);
        }

    }
    return false;
}

function Invoke(O, P, args) {
    var obj;
    Assert(IsPropertyKey(P), "Invoke: expecting property key");
    if (!Array.isArray(args)) args = [];
    obj = ToObject(O);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var func = callInternalSlot(SLOTS.GET, obj, P, O);
    if (!IsCallable(func)) return newTypeError( "Invoke: expected function is not callable");
    if (isAbrupt(func = ifAbrupt(func))) return func;
    return callInternalSlot(SLOTS.CALL, func, O, args);
}

function OrdinaryObjectInvoke(O, P, A, R) {
    Assert(IsPropertyKey(P), "expecting property key");
    Assert(Array.isArray(A), "expecting arguments list");
    var method = callInternalSlot(SLOTS.GET, O, P, R);
    if (isAbrupt(method = ifAbrupt(method))) return method;
    if (Type(method) !== OBJECT) return newTypeError( "Invoke: method " + P + " is not an object");
    if (!IsCallable(method)) return newTypeError( "Invoke: method " + P + " is not callable");
    return method.Call(R, A);
}


/*
function DefineOwnProperty(O, P, Desc) {
    return OrdinaryDefineOwnProperty(O, P, Desc);
}
*/

function HasOwnProperty(O, P) {
    Assert(Type(O) === OBJECT, "GetOwnProperty: first argument has to be an object");
    Assert(IsPropertyKey(P), "HasOwnProperty: second argument has to be a valid property key, got " + P);
    var desc = callInternalSlot(SLOTS.GETOWNPROPERTY, O, P);
    return desc !== undefined;

}

function HasProperty(O, P) {
    do {
        if (HasOwnProperty(O, P)) return true;
    } while (O = GetPrototypeOf(O));
    return false;
}

function Enumerate(O) {
    var name, proto, bindings, desc, index, denseList, isSparse;
    var duplicateMap = Object.create(null);
    var propList = [];
    var chain = [];
    proto = O;
    // add all prototypes to enumerate into one list
    while (proto != null) {
        chain.push(proto);
        proto = GetPrototypeOf(proto);
    }
    // read the list backwards, coz O is the index 0 in the list.
    for (var k = chain.length-1; k >= 0; k--) {
        var obj = chain[k];
        bindings = obj.Bindings;
        for (name in bindings) {
            if (Type(name) === STRING) {

                desc = OrdinaryGetOwnProperty(obj, name);
                if (desc.enumerable === true) {
                    // if i find a dupe from before, delete and let list be sparse
                    if ((index = duplicateMap[name]) !== undefined) {
                        propList[index] = undefined;
                        isSparse = true;
                    }
                    // add to the dupemap the name
                    duplicateMap[name] = propList.push(name) - 1;
                }
            }
        }
    }
    if (isSparse) { // 2*O(n) if it´s containing eliminated dupes (splice costs more)
        denseList = [];
        for (var i = 0, j = propList.length; i < j; i++) {
            if ((name = propList[i]) !== undefined) denseList.push(name);
        }
        return MakeListIterator(denseList);
    }
    
    return MakeListIterator(propList);
}

function IsExtensible(O) {
    if (Type(O) === OBJECT) return getInternalSlot(O, SLOTS.EXTENSIBLE);
    return false;
}

function PreventExtensions(O) {
    if (Type(O) === OBJECT) setInternalSlot(O, SLOTS.EXTENSIBLE, false);
}

/**
 * Created by root on 30.03.14.
 */
// ===========================================================================================================
    // Ordinary Function
    // ===========================================================================================================

function OrdinaryFunction() {
    var F = Object.create(OrdinaryFunction.prototype);
    setInternalSlot(F, SLOTS.BINDINGS, Object.create(null));
    setInternalSlot(F, SLOTS.SYMBOLS, Object.create(null));
    setInternalSlot(F, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.FUNCTIONPROTOTYPE));
    setInternalSlot(F, SLOTS.REALM, undefined);
    setInternalSlot(F, SLOTS.EXTENSIBLE, true);
    setInternalSlot(F, SLOTS.ENVIRONMENT, undefined);
    setInternalSlot(F, SLOTS.NEEDSSUPER, undefined);
    setInternalSlot(F, SLOTS.FORMALPARAMETERS, undefined);
    setInternalSlot(F, SLOTS.CODE, undefined);
    return F;
}

OrdinaryFunction.prototype = {
    constructor: OrdinaryFunction,
    type: "object",
    toString: function () {
        return "[object OrdinaryFunction]";
    },
    Get: function (P, R) {
        var v = OrdinaryObjectGet(this, P, R);
        if (P === "caller" && IsCallable(v) && getInternalSlot(v, SLOTS.STRICT)) return null;
        return v;
    },
    GetOwnProperty: function (P) {
        var d = GetOwnProperty(this, P);
        if (P === "caller" && IsCallable(v) && getInternalSlot(v, SLOTS.STRICT)) d.value = null;
        return d;
    },
    Call: function () {
        // MODULE INTERDEPENDENCY -> call is from "runtime"
        return exports.Call.apply(this, arguments);
    },
    Construct: function (argList) {
        return OrdinaryConstruct(this, argList);
    }
};
addMissingProperties(OrdinaryFunction.prototype, OrdinaryObject.prototype);


// ===========================================================================================================
// BoundFunctionCreate
// ===========================================================================================================

function BoundFunctionCreate(B, T, argList) {
    var F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.BOUNDTARGETFUNCTION, B);
    setInternalSlot(F, SLOTS.BOUNDTHIS, T);
    setInternalSlot(F, SLOTS.BOUNDARGUMENTS, argList.slice());
    setInternalSlot(F, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.FUNCTIONPROTOTYPE));
    setInternalSlot(F, SLOTS.EXTENSIBLE, true);
    setInternalSlot(F, SLOTS.CALL, function (thisArg, argList) {
        var B = getInternalSlot(F, SLOTS.BOUNDTARGETFUNCTION);
        var T = getInternalSlot(F, SLOTS.BOUNDTHIS);
        var A = getInternalSlot(F, SLOTS.BOUNDARGUMENTS).concat(argList);
        return callInternalSlot(SLOTS.CALL, B, T, A);
    });
    return F;
}



function IsCallable(O) {
    if (O instanceof CompletionRecord) return IsCallable(O.value);
    return Type(O) === OBJECT && O.Call;
}

function IsConstructor(F) {
    if (F instanceof CompletionRecord) return IsConstructor(F.value);
    return F && F.Construct;
}

function SetFunctionLength(F, L) {
    L = ToLength(L);
    // if (isAbrupt(L)) return L;
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, F, "length", {
        value: L,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

function SetFunctionName(F, name, prefix) {
    var success;
    var t = Type(name);
    Assert(t === STRING || t === SYMBOL, "SetFunctionName: name must be a symbol or a string ("+name+" is "+t+")");
    Assert(IsCallable(F), "SetFunctionName: F has to be an EcmaScript Function Object");
    Assert(!HasOwnProperty(F, "name"), "SetFunctionName: Function may not have a name property");
    if (t === SYMBOL) {
        var desc = getInternalSlot(name, SLOTS.DESCRIPTION);
        if (desc === undefined) name = "";
        else name = "[" + desc + "]";
    }
    if (name !== "" && prefix !== undefined) {
        name = prefix + " " + name;
    }
    success = DefineOwnProperty(F, "name", {
        value: name,
        writable: false,
        enumerable: false,
        configurable: false
    });
    if (isAbrupt(success = ifAbrupt(success))) return success;
    if (success === false) return newTypeError( "Sorry, can not set name property of a non function");
    return NormalCompletion(undefined);
}

function GeneratorFunctionCreate(kind, paramList, body, scope, strict, fProto, homeObject, methodName) {
    if (!fProto) fProto = Get(getIntrinsics(), INTRINSICS.GENERATOR);
    var F = FunctionAllocate(fProto, "generator");
    return FunctionInitialize(F, kind, paramList, body, scope, strict, homeObject, methodName);
}

function FunctionCreate(kind, paramList, body, scope, strict, fProto, homeObject, methodName) {
    if (!fProto) fProto = Get(getIntrinsics(), INTRINSICS.FUNCTIONPROTOTYPE);
    var F = FunctionAllocate(fProto);
    return FunctionInitialize(F, kind, paramList, body, scope, strict, homeObject, methodName);
}

function FunctionAllocate(fProto, kind) {
    var F;
    Assert(Type(fProto) === OBJECT, "fproto has to be an object");
    if (kind) {
        Assert((kind === "generator" || kind === "normal"), "kind must be generator or normal");
    } else {
        kind = "normal";
    }
    F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.FUNCTIONKIND, kind);
    setInternalSlot(F, SLOTS.PROTOTYPE, fProto);
    setInternalSlot(F, SLOTS.EXTENSIBLE, true);
    setInternalSlot(F, SLOTS.CONSTRUCT, undefined);
    setInternalSlot(F, SLOTS.REALM, getRealm());
    return F;
}

function FunctionInitialize(F, kind, paramList, body, scope, strict, homeObject, methodName) {
    setInternalSlot(F, SLOTS.FUNCTIONKIND, kind);
    setInternalSlot(F, SLOTS.FORMALPARAMETERS, paramList);
    setInternalSlot(F, SLOTS.CODE, body);
    setInternalSlot(F, SLOTS.ENVIRONMENT, scope);
    setInternalSlot(F, SLOTS.STRICT, strict);
    setInternalSlot(F, SLOTS.REALM, getRealm());
    if (homeObject) setInternalSlot(F, SLOTS.HOMEOBJECT, homeObject);
    if (methodName) setInternalSlot(F, SLOTS.METHODNAME, methodName);
    setInternalSlot(F, SLOTS.STRICT, strict);
    if (kind === "arrow") setInternalSlot(F, SLOTS.THISMODE, "lexical");
    else if (strict) setInternalSlot(F, SLOTS.THISMODE, "strict");
    else setInternalSlot(F, SLOTS.THISMODE, "global");
    return F;
}

function GetPrototypeFromConstructor(C, intrinsicDefaultProto) {
    var realm, intrinsics;
    Assert((typeof intrinsicDefaultProto === "string"), "intrinsicDefaultProto has to be a string");
    if (!IsConstructor(C)) return newTypeError( "GetPrototypeFromConstructor: C is no constructor");
    var proto = Get(C, "prototype");
    if (isAbrupt(proto = ifAbrupt(proto))) return proto;
    if (Type(proto) !== OBJECT) {
        var realm = getInternalSlot(C, SLOTS.REALM);
        if (realm) intrinsics = realm.intrinsics;
        else intrinsics = getIntrinsics();
        proto = Get(getIntrinsics(), intrinsicDefaultProto);
    }
    return proto;
}

function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto, internalDataList) {
    Assert(HasProperty(getIntrinsics(), intrinsicDefaultProto), "the chosen intrinsic default proto has to be defined in the intrinsic");
    var O, result;
    var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
    if (isAbrupt(proto = ifAbrupt(proto))) return proto;
    return ObjectCreate(proto, internalDataList);
}

// 20. Januar

function CreateFromConstructor(F) {
    var creator = Get(F, $$create);
    if (isAbrupt(creator = ifAbrupt(creator))) return creator;
    if (creator === undefined) return undefined;
    if (IsCallable(creator) === false) return newTypeError( "CreateFromConstructor: creator has to be callable");
    var obj = callInternalSlot(SLOTS.CALL, creator, F, []);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    if (Type(obj) !== OBJECT) return newTypeError( "CreateFromConstructor: obj has to be an object");
    return obj;
}

function Construct(F, argList) {
    Assert(Type(F) === OBJECT, "essential Construct: F is not an object");
    var obj = CreateFromConstructor(F);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    if (obj === undefined) {
        obj = OrdinaryCreateFromConstructor(F, INTRINSICS.OBJECTPROTOTYPE);
        if (isAbrupt(obj = ifAbrupt(obj))) return obj;
        if (Type(obj) !== OBJECT) return newTypeError( "essential Construct: obj is not an object");
    }
    var result = callInternalSlot(SLOTS.CALL, F, obj, argList);
    if (isAbrupt(result = ifAbrupt(result))) return result;
    if (Type(result) === OBJECT) return result;
    return obj;
}

// vorher
function OrdinaryConstruct(F, argList) {
    var creator = Get(F, $$create);
    var obj;
    if (creator) {
        if (!IsCallable(creator)) return newTypeError( "OrdinaryConstruct: creator is not callable");
        obj = callInternalSlot(SLOTS.CALL, creator, F, argList);
    } else {
        obj = OrdinaryCreateFromConstructor(F, INTRINSICS.OBJECTPROTOTYPE);
    }
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    if (Type(obj) !== OBJECT) return newTypeError( "OrdinaryConstruct: Type(obj) is not object");
    var result = callInternalSlot(SLOTS.CALL, F, obj, argList);
    if (isAbrupt(result = ifAbrupt(result))) return result;
    if (Type(result) === OBJECT) return result;
    return obj;
}

function MakeConstructor(F, writablePrototype, prototype) {
    var installNeeded = false;

    if (!prototype) {
        installNeeded = true;
        prototype = ObjectCreate();
    }
    if (writablePrototype === undefined) writablePrototype = true;
    setInternalSlot(F, SLOTS.CONSTRUCT, function Construct(argList) {
        return OrdinaryConstruct(this, argList);
    });
    if (installNeeded) callInternalSlot(SLOTS.DEFINEOWNPROPERTY, prototype, "constructor", {
        value: F,
        writable: writablePrototype,
        enumerable: false,
        configurable: writablePrototype
    });
    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, F, "prototype", {
        value: prototype,
        writable: writablePrototype,
        enumerable: false,
        configurable: writablePrototype
    });
    return F;
}

function OrdinaryHasInstance(C, O) {
    var BC, P;
    if (!IsCallable(C)) return false;
    if (BC = getInternalSlot(C, SLOTS.BOUNDTARGETFUNCTION)) {
        return OrdinaryHasInstance(BC, O);
    }
    if (Type(O) !== OBJECT) return false;
    P = Get(C, "prototype");
    if (isAbrupt(P = ifAbrupt(P))) return P;
    if (Type(P) !== OBJECT) return newTypeError( "OrdinaryHasInstance: P not object");
    while (O = GetPrototypeOf(O)) {
        if (isAbrupt(O = ifAbrupt(O))) return O;
        if (O === null) return false;
        if (SameValue(P, O) === true) return true;
    }
    return false;
}


// ===========================================================================================================
// AddRestricted FPs
// ===========================================================================================================

function AddRestrictedFunctionProperties(F) {
    var thrower = getIntrinsic(INTRINSICS.THROWTYPEERROR);
    var status = DefineOwnPropertyOrThrow(F, "caller", {
        get: thrower,
        set: thrower,
        enumerable: false,
        configurable: false
    });
    if (isAbrupt(status)) return status;
    return DefineOwnPropertyOrThrow(F, "arguments", {
        get: thrower,
        set: thrower,
        enumerable: false,
        configurable: false
    });
}

// ===========================================================================================================
// Create Builtin (Intrinsic Module)
// ===========================================================================================================

function CreateBuiltinFunction(realm, steps, len, name, internalSlots) {

    var tmp;
    var realm = getRealm();
    var F = OrdinaryFunction();

    // this is probably/oc unneccessary, coz all builtins have make no use of the environments anyways
    // because they are plain javascript functions
    function Call() {
        var result;
        var oldContext = getContext();
        var callContext = ExecutionContext(getContext(), realm);
        var stack = getStack();
        stack.push(callContext);
        result = steps.apply(this, arguments);
        Assert(callContext === stack.pop(), "CreateBuiltinFunction: Wrong Context popped from the Stack.");
        return result;
    }
    // the .steps reference is needed by function.prototype.toString to put out the right function
    Call.steps = steps;

    setInternalSlot(F, SLOTS.CALL, Call);
    setInternalSlot(F, SLOTS.CODE, undefined);
    setInternalSlot(F, SLOTS.CONSTRUCT, undefined);
    setInternalSlot(F, SLOTS.FORMALPARAMETERS, undefined);
    setInternalSlot(F, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.FUNCTIONPROTOTYPE));
    setInternalSlot(F, SLOTS.ENVIRONMENT, undefined);
    setInternalSlot(F, SLOTS.NEEDSSUPER, undefined);
    setInternalSlot(F, SLOTS.STRICT, true);
    setInternalSlot(F, SLOTS.REALM, realm);
    AddRestrictedFunctionProperties(F);
    if (typeof len === "string") {
        tmp = name;
        name = len;
        len = tmp;
    }
    if (typeof name !== "string") name = steps.name;
    if (name) SetFunctionName(F, name);
    if (typeof len !== "number") len = 0;
    SetFunctionLength(F, len);
    if (typeof internalSlots === "object" && internalSlots) {
	Object.keys(internalSlots).forEach(function (slot) {
	    setInternalSlot(F, slot, undefined);
	});
    }    
    return F;
}


/**
 * Created by root on 30.03.14.
 */

function MakeMethod (F, methodName, homeObject) {
    Assert(IsCallable(F), "MakeMethod: method is not a function");
    Assert(methodName === undefined || IsPropertyKey(methodName), "MakeMethod: methodName is neither undefined nor a valid property key");
    var homeObjectType = Type(homeObject);
    Assert(homeObjectType === UNDEFINED || homeObjectType === OBJECT, "MakeMethod: HomeObject is neither undefined nor object.");
    setInternalSlot(F, SLOTS.NEEDSSUPER, true);
    setInternalSlot(F, SLOTS.HOMEOBJECT, homeObject);
    setInternalSlot(F, SLOTS.METHODNAME, methodName);
    return NormalCompletion(undefined);
}

function MakeSuperReference(propertyKey, strict) {
    var env = GetThisEnvironment();
    if (!env.HasSuperBinding()) return newReferenceError(format("CAN_NOT_MAKE_SUPER_REF"));
    var actualThis = env.GetThisBinding();
    var baseValue = env.GetSuperBase();
    var bv = CheckObjectCoercible(baseValue);
    if (isAbrupt(bv = ifAbrupt(bv))) return bv;
    if (propertyKey === undefined) propertyKey = env.GetMethodName();
    return Reference(propertyKey, bv, strict, actualThis);
}

function GetSuperBinding(obj) {
    if (Type(obj) !== OBJECT) return undefined;
    if (getInternalSlot(obj, SLOTS.NEEDSSUPER) !== true) return undefined;
    if (!hasInternalSlot(obj, SLOTS.HOMEOBJECT)) return undefined;
    return getInternalSlot(obj, SLOTS.HOMEOBJECT);
}

function cloneFunction (func) {
    var newFunc = OrdinaryFunction();
    setInternalSlot(newFunc, SLOTS.ENVIRONMENT, getInternalSlot(func, SLOTS.ENVIRONMENT));
    setInternalSlot(newFunc, SLOTS.CODE, getInternalSlot(func, SLOTS.CODE));
    setInternalSlot(newFunc, SLOTS.FORMALPARAMETERS, getInternalSlot(func, SLOTS.FORMALPARAMETERS));
    setInternalSlot(newFunc, SLOTS.THISMODE, getInternalSlot(func, SLOTS.THISMODE));
    setInternalSlot(newFunc, SLOTS.FUNCTIONKIND, getInternalSlot(func, SLOTS.FUNCTIONKIND));
    setInternalSlot(newFunc, SLOTS.STRICT, getInternalSlot(func, SLOTS.STRICT));
    return newFunc;
}

function CloneMethod(func, newHome, newName) {
    Assert(IsCallable(func), "CloneMethod: function has to be callable");
    Assert(Type(newHome) === OBJECT, "CloneMethod: newHome has to be an object");
    Assert(Type(newName) === UNDEFINED || IsPropertyKey(newName), "CloneMethod: newName has to be undefined or object");
    var newFunc = cloneFunction(func);
    if (getInternalSlot(func, SLOTS.NEEDSSUPER) === true) {
        setInternalSlot(newFunc, SLOTS.HOMEOBJECT, newHome);
        if (newName !== undefined) setInternalSlot(newFunc, SLOTS.METHODNAME, newName);
        else setInternalSlot(newFunc, SLOTS.METHODNAME, getInternalSlot(func, SLOTS.METHODNAME));
    }
    if (getInternalSlot(newFunc, SLOTS.STRICT) === true) {
        var status = AddRestrictedFunctionProperties(newFunc);
        if (isAbrupt(status)) return status;
    }
    return newFunc;
}

function RebindSuper(func, newHome) {
    Assert(IsCallable(func) && func.HomeObject, "func got to be callable and have a homeobject");
    Assert(Type(newHome) === OBJECT, "newhome has to be an object");
    var nu = OrdinaryFunction();
    setInternalSlot(nu, SLOTS.FUNCTIONKIND, getInternalSlot(func, SLOTS.FUNCTIONKIND));
    setInternalSlot(nu, SLOTS.ENVIRONMENT, getInternalSlot(func, SLOTS.ENVIRONMENT));
    setInternalSlot(nu, SLOTS.CODE, getInternalSlot(func, SLOTS.CODE));
    setInternalSlot(nu, SLOTS.FORMALPARAMETERS, getInternalSlot(func, SLOTS.FORMALPARAMETERS));
    setInternalSlot(nu, SLOTS.STRICT, getInternalSlot(func, SLOTS.STRICT));
    setInternalSlot(nu, SLOTS.THISMODE, getInternalSlot(func, SLOTS.THISMODE));
    setInternalSlot(nu, SLOTS.METHODNAME, getInternalSlot(func, SLOTS.METHODNAME));
    setInternalSlot(nu, SLOTS.REALM, getInternalSlot(func, SLOTS.REALM));
    setInternalSlot(nu, SLOTS.HOMEOBJECT, newHome);
    return nu;
}



function ArgumentsExoticObject() {
    var O = Object.create(ArgumentsExoticObject.prototype);
    setInternalSlot(O, SLOTS.BINDINGS, Object.create(null));
    setInternalSlot(O, SLOTS.SYMBOLS, Object.create(null));
    setInternalSlot(O, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.ARRAYPROTOTYPE));
    var map = ObjectCreate();
    setInternalSlot(map, "toString", function () {
        return "[object ParameterMap]";
    });
    setInternalSlot(O, SLOTS.PARAMETERMAP, map);
    return O;
}
ArgumentsExoticObject.prototype = {
    toString: function () {
        return "[object ArgumentsExoticObject]";
    },
    Get: function (P) {
        var ao = this;
        var map = getInternalSlot(ao, SLOTS.PARAMETERMAP);
        var isMapped = map.GetOwnProperty(P);
        if (!isMapped) {
            var v = OrdinaryGetOwnProperty(ao, P);
            if (v !== undefined) v = v.value;
            if (P === "caller" && (Type(v) === OBJECT && (IsCallable(v) || IsConstructor(v))) && getInternalSlot(v, SLOTS.STRICT)) {
                return newTypeError( "Arguments.Get: Can not access 'caller' in strict mode");
            }
            return v;
        } else {
            return Get(map, P);
        }
    },
    GetOwnProperty: function (P) {
        var ao = this;
        var desc = readPropertyDescriptor(this, P);
        if (desc === undefined) return desc;
        var map = getInternalSlot(ao, SLOTS.PARAMETERMAP);
        var isMapped = callInternalSlot(SLOTS.GETOWNPROPERTY, map, P);
        if (isMapped) desc.value = Get(map, P);
        return desc;
    },
    DefineOwnProperty: function (P, Desc) {
        var ao = this;
        var map = getInternalSlot(ao, SLOTS.PARAMETERMAP);
        var isMapped = callInternalSlot(SLOTS.GETOWNPROPERTY, map, P);
        var allowed = OrdinaryDefineOwnProperty(ao, P, Desc);
        var putStatus;
        if (isAbrupt(allowed = ifAbrupt(allowed))) return allowed;
        if (!allowed) return allowed;
        if (isMapped) {
            if (IsAccessorDescriptor(Desc)) {
                callInternalSlot("Delete", map, P);
            } else {
                if (Desc["value"] !== undefined) putStatus = Put(map, P, Desc.value, false);
                Assert(putStatus === true, "Arguments::DefineOwnProperty: putStatus has to be true");
                if (Desc.writable === false) callInternalSlot("Delete", map, P);
            }
        }
        return true;
    },
    Delete: function (P) {
        var map = getInternalSlot(this, SLOTS.PARAMETERMAP);
        var isMapped = callInternalSlot(SLOTS.GETOWNPROPERTY, map, P);
        var result = Delete(this, P);
        if (isAbrupt(result = ifAbrupt(result))) return result;
        if (result && isMapped) callInternalSlot("Delete", map, P);

    },
    constructor: ArgumentsExoticObject
};

addMissingProperties(ArgumentsExoticObject.prototype, OrdinaryObject.prototype);

/**
 * Created by root on 31.03.14.
 */
function CreateArrayFromList(list) {
    var array = ArrayCreate(list.length);
    for (var i = 0, j = list.length; i < j; i++) {
        array.Set(ToString(i), list[i], array);
    }
    return array;
}
function CreateListFromArrayLike(arrayLike) {
    var list = [];
    for (var i = 0, j = arrayLike.length; i < j; i++) {
        list.push(arrayLike.Get(ToString(i), arrayLike))
    }
    return list;
}
function CreateArrayIterator(array, kind) {
    var O = ToObject(array);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var proto = getIntrinsic(INTRINSICS.ARRAYITERATORPROTOTYPE);
    var iterator = ObjectCreate(proto);
    setInternalSlot(iterator, SLOTS.ITERATEDOBJECT, O);
    setInternalSlot(iterator, SLOTS.ARRAYITERATIONNEXTINDEX, 0);
    setInternalSlot(iterator, SLOTS.ARRAYITERATIONKIND, kind);
    return iterator;
}
function ArrayExoticObject(proto) {
    var A = Object.create(ArrayExoticObject.prototype);
    setInternalSlot(A, SLOTS.BINDINGS,Object.create(null));
    setInternalSlot(A, SLOTS.SYMBOLS, Object.create(null));
    setInternalSlot(A, SLOTS.EXTENSIBLE, true);
    setInternalSlot(A, SLOTS.PROTOTYPE, proto? proto : ArrayPrototype);
    return A;
}

ArrayExoticObject.prototype = {
    constructor: ArrayExoticObject,
    type: "object",
    toString: function () {
        return "[object ArrayExoticObject]";
    },
    DefineOwnProperty: function (P, Desc) {
        if (IsPropertyKey(P)) {
            if (IsSymbol(P)) return OrdinaryDefineOwnProperty(this, P, Desc);
            if (P === "length") {
                return ArraySetLength(this, Desc);
            } else {
                var testP = P;
                if (ToString(ToInteger(testP)) === ToString(testP)) {
                    var oldLenDesc = GetOwnProperty(this, "length");
                    if (!oldLenDesc) oldLenDesc = Object.create(null);
                    var oldLen = oldLenDesc.value;
                    var index = ToUint32(P);
                    if (isAbrupt(index = ifAbrupt(index))) return index;
                    if (index >= oldLen && oldLenDesc.writable === false) return false;
                    var succeeded = OrdinaryDefineOwnProperty(this, P, Desc);
                    if (isAbrupt(succeeded = ifAbrupt(succeeded))) return succeeded;
                    if (succeeded === false) return false;
                    if (index >= oldLen) {
                        oldLenDesc.value = index + 1;
                        succeeded = this.DefineOwnProperty("length", oldLenDesc);
                        if (isAbrupt(succeeded = ifAbrupt(succeeded))) return succeeded;
                    }
                    return true;
                }
            }
            return OrdinaryDefineOwnProperty(this, P, Desc);
        }
        return false;
    }
};
addMissingProperties(ArrayExoticObject.prototype, OrdinaryObject.prototype);

function ArrayCreate(len, proto) {
    var p = proto || getIntrinsic(INTRINSICS.ARRAYPROTOTYPE);
    var array = ArrayExoticObject(p);
    setInternalSlot(array, SLOTS.EXTENSIBLE, true);
    if (len !== undefined) {
        setInternalSlot(array , SLOTS.ARRAYINITIALISATIONSTATE, true);
    } else {
        setInternalSlot(array , SLOTS.ARRAYINITIALISATIONSTATE,  false);
        len = 0;
    }
    OrdinaryDefineOwnProperty(array, "length", {
        value: len,
        writable: true,
        enumerable: false,
        configurable: false
    });
    return array;
}

function ArraySetLength(A, Desc) {
    if (Desc.value === undefined) {
        return OrdinaryDefineOwnProperty(A, "length", Desc);
    }
    var newLenDesc = assign(Object.create(null), Desc);
    var newLen = ToUint32(Desc.value);
    if (newLen != ToNumber(Desc.value)) return newRangeError( "Array length index out of range");
    if (isAbrupt(newLen=ifAbrupt(newLen))) return newLen;
    newLenDesc.value = newLen;
    var oldLenDesc = callInternalSlot(SLOTS.GETOWNPROPERTY, A, "length");
    if (!oldLenDesc) oldLenDesc = Object.create(null);
    var oldLen = Desc.value;
    if (newLen >= oldLen) return OrdinaryDefineOwnProperty(A, "length", newLenDesc);
    if (oldLenDesc.writable === false) return false;
    var newWritable;
    if (newLenDesc.writable === undefined || newLenDesc.writable === true) newWritable = true;
    else {
        newWritable = false;
        newLenDesc.writable = true;
    }
    var succeeded = OrdinaryDefineOwnProperty(A, "length", newLenDesc);
    if (isAbrupt(succeeded = ifAbrupt(succeeded))) return succeeded;
    if (succeeded === false) return false;
    while (newLen < oldLen) {
        oldLen = oldLen - 1;
        succeeded = callInternalSlot("Delete", A, (ToString(oldLen)));
        if (isAbrupt(succeeded = ifAbrupt(succeeded))) return succeeded;
        if (succeeded === false) {
            newLenDesc.value = oldLen + 1;
            if (newWritable === false) newLenDesc.writable = false;
            succeeded = OrdinaryDefineOwnProperty(A, "length", newLenDesc);
            if (isAbrupt(succeeded = ifAbrupt(succeeded))) return succeeded;
            return false;
        }
    }
    if (newWritable === false) {
        newLenDesc.writable = false;
        OrdinaryDefineOwnProperty(A, "length", {
            writable: false
        });
    }
    return true;
}



// ===========================================================================================================
// Encode, Decode Algorithms
// ===========================================================================================================

var HexDigits = require("tables").HexDigits; // CAUTION: require

var uriReserved = ";/?:@&=+$,";
var uriUnescaped = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~_.!\"*'()";

function Encode(string, unescapedSet) {
    var strLen = string.length;
    var R = "";
    var k = 0;
    var C, S, cu, V, kChar;
    while (k < strLen) {
        if (k === strLen) return NormalCompletion(R);
        C = string[k];
        if (unescapedSet.indexOf(C) > -1) {
            R += C;
        } else {
            cu = C.charCodeAt(0);
            if (!(cu < 0xDC00) && !(cu > 0xDFFF)) return newURIError("Encode: Code unit out of Range");
            else if (cu < 0xD800 || cu > 0xDBFF) {
                V = cu;
            } else {
                k = k + 1;
                if (k === strLen) return newURIError("Encode: k eq strLen");
                kChar = string.charCodeAt(k);
                if (kChar < 0xDC00 || kChar > 0xDFFF) return newURIError("kChar code unit is out of range");
                V = ((cu - 0xD800) * 0x400 + (kChar - 0xDC00) + 0x10000);
                /*
                 Achtung Oktett encodierung aus Tabelle 32 (rev 16)
                 */
            }
            var octets = UTF8Encode(V);
            var L = octets.length;
            var j = 0;
            var joctets;
            while (j < L) {
                joctets = octets[j];
                S = "%" + joctets.toString(16).toUpperCase();
                j = j + 1;
                R = R + S;
            }
        }
        k = k + 1;
    }
    return NormalCompletion(R);
}

function UTF8Encode(V) {
    return [V];
}

function Decode(string, reservedSet) {
    var strLen = string.length;
    var R = "";
    var k = 0;
    var S;
    for (;;) {
        if (k === strLen) return NormalCompletion(R);
        var C = string[k];
        if (C !== "%") {
            S = "" + C;
        } else {
            var start = k;
            if (k + 2 >= strLen) return newURIError("k+2>=strLen");
            if (!HexDigits[string[k + 1]] || !HexDigits[string[k + 2]]) return newURIError("%[k+1][k+2] are not hexadecimal letters");
            var hex = string[k + 1] + string[k + 2];
            var B = parseInt(hex, 16);
            k = k + 2;

        }
        R = R + S;
        k = k + 1;
    }
}


var msPerDay = 1000 * 60 * 60 * 24;
var msPerHour = 1000 * 60 * 60;
var msPerMinute = 1000 * 60;
var msPerSecond = 1000;
var minutesPerHour = 60;
var hoursPerDay = 24;
var secondsPerMinute = 60;
var msPerYear = msPerDay * 365;

function UTC() {

}

function thisTimeValue(value) {
    if (value instanceof CompletionRecord) return thisTimeValue(value);
    if (Type(value) === OBJECT && hasInternalSlot(value, SLOTS.DATEVALUE)) {
        var b = getInternalSlot(value, SLOTS.DATEVALUE);
        if (b !== undefined) return b;
    }
    return newTypeError( "thisTimeValue: value is not a Date");
}

function Day(t) {
    return Math.floor(t / msPerDay);
}

function TimeWithinDay(t) {
    return t % msPerDay;
}

function DaysInYear(y) {
    var a = y % 4;
    var b = y % 100;
    var c = y % 400;
    if (a !== 0) return 365;
    if (a === 0 && b !== 0) return 366;
    if (b === 0 && c !== 0) return 365;
    if (c === 0) return 366;
}

function DayFromYear(y) {
    return 365 * (y - 1970) + floor((y-1969/4)) - floor((y-1901)/100) + floor((y-1601)/400);
}

function YearFromTime(t) {
    var y = t / (60 * 60 * 24 * 365);
    return y;
}

function InLeapYear(t) {
    var diy = DaysInYear(YearFromTime(t));
    if (diy == 365) return 0;
    if (diy == 366) return 1;
}

var Months = {
    __proto__: null,
    0: "January",
    1: "February",
    2: "March",
    3: "April",
    4: "May",
    5: "June",
    6: "July",
    7: "August",
    8: "September",
    9: "October",
    10: "November",
    11: "December"
};

function MonthFromTime(t) {
    var il = InLeapYear(t);
    var dwy = DayWithinYear(t);
    if (0 <= dwy && dwy < 31) return 0;
    else if (31 <= dwy && dwy < 59 + il) return 1;
    else if (59 + il <= dwy && dwy < 90 + il) return 2;
    else if (90 + il <= dwy && dwy < 120 + il) return 3;
    else if (120 + il <= dwy && dwy < 151 + il) return 4;
    else if (151 + il <= dwy && dwy < 181 + il) return 5;
    else if (181 + il <= dwy && dwy < 212 + il) return 6;
    else if (212 + il <= dwy && dwy < 243 + il) return 7;
    else if (243 + il <= dwy && dwy < 273 + il) return 8;
    else if (273 + il <= dwy && dwy < 304 + il) return 9;
    else if (304 + il <= dwy && dwy < 334 + il) return 10;
    else if (334 + il <= dwy && dwy < 365 + il) return 11;
}

function DayWithinYear(t) {
    return Day(t) - DayFromYear(YearFromTime(t));
}

function HourFromTime(t) {
    return Math.floor(t / msPerHour) % hoursPerDay;
}

function MinFromTime(t) {
    return Math.floor(t / msPerMinute) % minutesPerHour;
}

function SecFromTime(t) {
    return Math.floor(t / msPerSecond) % secondsPerMinute;
}

function msFromTime(t) {
    return t % msPerSecond;
}

function MakeTime(hour, min, sec, ms) {
    if (isFinite(hour) === false) return NaN;
    var h = ToInteger(hour);
    var m = ToInteger(min);
    var sec = ToInteger(sec);
    var milli = ToInteger(ms);
    var t = h * msPerHour + m * msPerMinute + s * msPerSecond + milli;
    return t;
}

function MakeDay(year, month, date) {
    if (!isFinite(time)) return NaN;
    var y = ToInteger(year);
    var m = ToInteger(month);
    var dt = ToInteger(date);
    var ym = Math.floor(m / 12);
    var mn = m % 12;
    var t;
    return Day(t) + dt - 1;
}

function MakeDate(day, time) {
    if (!isFinite(day)) return NaN;
    return day * msPerDay + time;
}

function TimeClip(time) {
    if (!isFinite(time)) return NaN;
    if (Math.abs(time) > (8.64 * Math.pow(10, 15))) return NaN;
    return ToInteger(time) + (+0);
}

function WeekDay (t) {
    return ((Day(t) + 4) % 7);
}

function BetterComplicatedResumableEvaluationAlgorithmForASTVisitorsWithoutStack(generator, body) {
    /*
	Here is Space to handle all relevant nodes
	to reenter, where to restore pointer, what
	to pop of the code eval stack getContext().state    
    */
    
    return exports.Evaluate(body);
}


function printCodeEvaluationState() {

    var stack = getContext().state;
    var state = state[state.length-1];
    var node = state[0];
    var instructionIndex = state[1];
    var parent = state[2];
    var str = "["+(node&&node.type)+" === "+instructionIndex+"] of ["+(parent&&parent.type)+"]";
    if (hasConsole) console.log(str);
}

function Steps_GeneratorStart(generator, body) {
    var result = BetterComplicatedResumableEvaluationAlgorithmForASTVisitorsWithoutStack(generator, body);
    
    if (isAbrupt(result = ifAbrupt(result))) return result;
    if (isAbrupt(result = ifAbrupt(result)) && result.type === "return") {
        setInternalSlot(generator, SLOTS.GENERATORSTATE, "completed");
        if (isAbrupt(result = ifAbrupt(result))) return result;
        getContext().resumeGenerator = undefined;
        return CreateItrResultObject(result, true);
    }    
    return NormalCompletion(result);
}

function GeneratorStart(generator, body) {
    if (hasConsole) console.log("##GeneratorStart()##");
    Assert(getInternalSlot(generator, SLOTS.GENERATORSTATE) === undefined, "GeneratorStart: GeneratorState has to be undefined");
    var cx = getContext();
    cx.generator = generator;
    cx.resumeGenerator = function () {
        return Steps_GeneratorStart(generator, body);
    };
    setInternalSlot(generator, SLOTS.GENERATORCONTEXT, cx);
    setInternalSlot(generator, SLOTS.GENERATORSTATE, "suspendedStart");
    return generator;
}

function GeneratorResume(generator, value) {
    if (hasConsole) console.log("##GeneratorResume()##");

    if (Type(generator) !== OBJECT) return newTypeError( "resume: Generator is not an object");
    if (!hasInternalSlot(generator, SLOTS.GENERATORSTATE)) return newTypeError( "resume: Generator has no GeneratorState property");
    var state = getInternalSlot(generator, SLOTS.GENERATORSTATE);
    if (state !== "suspendedStart" && state !== "suspendedYield") return newTypeError( "Generator is neither in suspendedStart nor suspendedYield state");
    var genContext = getInternalSlot(generator, SLOTS.GENERATORCONTEXT);

    var methodContext = getContext();
    getStack().push(genContext);
    setInternalSlot(generator, SLOTS.GENERATORSTATE, "executing");
    var resumeGenerator = genContext.resumeGenerator;
   
    var result = resumeGenerator(NormalCompletion(value));
    setInternalSlot(generator, SLOTS.GENERATORSTATE, "suspendedYield");
    var x = getContext();
    if (x !== methodContext) {
        if (hasConsole) console.log("GENERATOR ACHTUNG 2: CONTEXT MISMATCH TEST NICHT BESTANDEN - resume");
    }
    return result;
}

function GeneratorYield(itrNextObj) {
    if (hasConsole) console.log("##GeneratorYield()##");
    Assert(HasOwnProperty(itrNextObj, "value") && HasOwnProperty(itrNextObj, "done"), "expecting itrNextObj to have value and done properties");

    var genContext = getContext();
    var generator = genContext.generator;
    setInternalSlot(generator, SLOTS.GENERATORSTATE, "suspendedYield");

    var x = getStack().pop();
    if (x !== genContext) {
        if (hasConsole) console.log("GENERATOR ACHTUNG 1: CONTEXT MISMATCH TEST NICHT BESTANDEN - yield");
    }
    // compl = yield smth;
    genContext.resumeGenerator = function (compl) {        
        return compl;
    };

    return NormalCompletion(itrNextObj);
}
function GetIterable (obj) {
    if (Type(obj) !== OBJECT) return undefined;
    var iteratorGetter = Get(obj, $$iterator);
    if (isAbrupt(iteratorGetter=ifAbrupt(iteratorGetter))) return iteratorGetter;
    return iteratorGetter;
}

function IsIterable(obj) {
    return HasProperty(obj, $$iterator);
}

function CreateItrResultObject(value, done) {
    Assert(Type(done) === BOOLEAN, "the second argument to CreateItrResultObject has to be a boolean value");
    var R = ObjectCreate();
    CreateDataProperty(R, "value", value);
    CreateDataProperty(R, "done", done);
    return R;
}

function GetIterator(obj) {
    var iterator = Invoke(obj, $$iterator, []);
    if (isAbrupt(iterator = ifAbrupt(iterator))) return iterator;
    if (Type(iterator) !== OBJECT) return newTypeError( "iterator is not an object");
    return iterator;
}

function IteratorNext(itr, val) {
    var result;
    if (arguments.length === 1) result = Invoke(itr, "next", []);
    else result = Invoke(itr, "next", [val]);
    if (isAbrupt(result = ifAbrupt(result))) return result;
    if (Type(result) !== OBJECT) return newTypeError( "IteratorNext: result is not an object");
    return result;
}

function IteratorComplete(itrResult) {
    Assert(Type(itrResult) === OBJECT);
    var done = Get(itrResult, "done");
    return ToBoolean(done);
}

function IteratorValue(itrResult) {
    Assert(Type(itrResult) === OBJECT);
    return Get(itrResult, "value");
}

function CreateEmptyIterator() {
    var emptyNextMethod = OrdinaryFunction();
    setInternalSlot(emptyNextMethod, SLOTS.CALL, function (thisArg, argList) {
        return CreateItrResultObject(undefined, true);
    });
    var obj = ObjectCreate();
    CreateDataProperty(obj, "next", emptyNextMethod);
    return obj;
}

function IteratorStep(iterator, value) {
    var result = IteratorNext(iterator, value);
    if (isAbrupt(result = ifAbrupt(result))) return result;
    var done = Get(result, "done");
    if (isAbrupt(done = ifAbrupt(done))) return done;
    if (done === true) return false;
    return result;
}


function MakeListIterator(list) {
    var nextPos = 0;
    var len = list.length;
    var obj = ObjectCreate();

    var listIteratorNext = CreateBuiltinFunction(getRealm(),function (thisArg, argList) {
	var list = getInternalSlot(obj, "IteratedList");
        var value, done;
        if (nextPos < len) {
            value = list[nextPos];
            nextPos = nextPos + 1;
            // leaving line for correction: hint: use CreateListIterator from spec :) and fix then if it´s wrong
            //done = (nextPos === len);
            return CreateItrResultObject(value, false);
        }
        return CreateItrResultObject(undefined, true);
    });
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    setInternalSlot(obj, "IteratedList", list);
    CreateDataProperty(obj, "next", listIteratorNext);
    return obj;
}

var ListIterator_next = function(thisArg, argList) {
    var O = thisArg;
    if (!hasInternalSlot(O, "IteratedList") || !hasInternalSlot(O, "IteratedListIndex")) {
        return newTypeError( "this value is missing the [[IteratedList]] properties");
    }
    var list = getInternalSlot(O, "IteratedList");
    var index = getInternalSlot(O, "IteratedListIndex");
    var len = list.length;
    if (index >= len) {
        return CreateItrResultObject(undefined, true);
    }
    var result = CreateItrResultObject(list[index], false);
    if (isAbrupt(result=ifAbrupt(result)))
    setInternalSlot(O, "IteratedListIndex", index + 1);
    return NormalCompletion(result);
};

function CreateListIterator(list) {
    var iterator = ObjectCreate(getIntrinsic(INTRINSICS.OBJECTPROTOTYPE), { IteratedList: undefined, ListIteratorNextIndex: undefined });
    setInternalSlot(iterator, "IteratedList", list);
    setInternalSlot(iterator, "IteratedListIndex", 0);
    LazyDefineProperty(iterator, "next", ListIterator_next);
    return iterator;
}



function CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) {
    for (var i = fromIndex, j = fromIndex + count, k = toIndex; i < j; i++, k++) toBlock[k] = fromBlock[i];
}

function CreateByteArrayBlock(bytes) {
    var dataBlock = new ArrayBuffer(bytes);
    return { block: dataBlock, dv: new DataView(dataBlock) }
}

function SetArrayBufferData(arrayBuffer, bytes) {
    Assert(hasInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERDATA), "[[ArrayBufferData]]");
    Assert(bytes > 0, "bytes != positive int");
    var block = CreateByteArrayBlock(bytes); // hehe
    setInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERDATA, block);
    setInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERBYTELENGTH, bytes);
    return arrayBuffer;
}
function AllocateArrayBuffer(F) {
    var obj = OrdinaryCreateFromConstructor(F, INTRINSICS.ARRAYBUFFERPROTOTYPE,
        [
            SLOTS.ARRAYBUFFERDATA,
            SLOTS.ARRAYBUFFERBYTELENGTH
        ]
    );
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    setInternalSlot(obj, SLOTS.ARRAYBUFFERBYTELENGTH, 0);
    return obj;
}
function GetValueFromBuffer(arrayBuffer, byteIndex, type, isLittleEndian) {
    var length = getInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERBYTELENGTH); 
    var block = getInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERDATA);
    if (block === undefined || block === null) return newTypeError(format("SLOT_NOT_AVAILABLE_S", "[[ArrayBufferData]]"));
    var elementSize = arrayType2elementSize[type];
    var rawValue, intValue;
    rawValue = block.dv["get"+type](byteIndex, isLittleEndian);
    return NormalCompletion(rawValue);
}

function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isLittleEndian) {
    //var length = getInternalSlot(arrayBuffer, SLOTS.BYTELENGTH);
    var block = getInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERDATA);
    if (block === undefined || block === null) return newTypeError(format("SLOT_NOT_AVAILABLE_S", "[[ArrayBufferData]]"));
    //var elementSize = arrayType2elementSize[type];
    var numValue = +value;
    if (isAbrupt(numValue = ifAbrupt(numValue))) return numValue;
    block.dv["set"+type](byteIndex, numValue, isLittleEndian);
    return NormalCompletion(undefined);
}

function SetViewValue(view, requestIndex, isLittleEndian, type, value) {
    var v = ToObject(view);
    if (isAbrupt(v = ifAbrupt(v))) return v;
    if (!hasInternalSlot(v, SLOTS.DATAVIEW)) return newTypeError(format("HAS_NO_SLOT_S", "[[ArrayBufferData]]"));
    var buffer = getInternalSlot(v, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError(format("S_IS_UNDEFINED", "buffer"));
    var numberIndex = ToNumber(requestIndex);
    var getIndex = ToInteger(numberIndex);
    if (isAbrupt(getIndex = ifAbrupt(getIndex))) return getIndex;
    if ((numberIndex !== getIndex) || (getIndex < 0)) return newRangeError(format("S_OUT_OF_RANGE", "index"));
    var littleEndian = ToBoolean(isLittleEndian);
    if (isAbrupt(littleEndian = ifAbrupt(littleEndian))) return littleEndian;
    var viewOffset = getInternalSlot(v, SLOTS.BYTEOFFSET);
    var viewSize = getInternalSlot(v, SLOTS.BYTELENGTH);
    var elementSize = typedArrayElementSize[type];
    if (getIndex + elementSize > viewSize) return newRangeError(format("S_OUT_OF_RANGE", "viewsize"));
    var bufferIndex = getIndex + viewOffset;
    return SetValueInBuffer(buffer, bufferIndex, type, value, littleEndian);
}

function GetViewValue(view, requestIndex, isLittleEndian, type) {
    var v = ToObject(view);
    if (isAbrupt(v = ifAbrupt(v))) return v;
    if (!hasInternalSlot(v, SLOTS.DATAVIEW)) return newTypeError(format("SLOT_CONTAINS_NO_S", "[[ArrayBufferData]]"));
    var buffer = getInternalSlot(v, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError(format("S_IS_UNDEFINED", "buffer"));
    var numberIndex = ToNumber(requestIndex);
    var getIndex = ToInteger(numberIndex);
    if (isAbrupt(getIndex = ifAbrupt(getIndex))) return getIndex;
    if ((numberIndex !== getIndex) || (getIndex < 0)) return newRangeError(format("S_OUT_OF_RANGE", "index"));
    var littleEndian = ToBoolean(isLittleEndian);
    if (isAbrupt(littleEndian = ifAbrupt(littleEndian))) return littleEndian;
    var viewOffset = getInternalSlot(v, SLOTS.BYTEOFFSET);
    var viewSize = getInternalSlot(v, SLOTS.BYTELENGTH);
    var elementSize = typedArrayElementSize[type];
    if (getIndex + elementSize > viewSize) return newRangeError(format("S_OUT_OF_RANGE", "viewsize"));
    var bufferIndex = getIndex + viewOffset;
    return GetValueFromBuffer(buffer, bufferIndex, type, littleEndian);
}


var arrayType2elementSize = {
    "Float64": 8,
    "Float32": 4,
    "Int32": 4,
    "Uint32": 4,
    "Int16": 2,
    "Uint16": 2,
    "Int8": 1,
    "Uint8": 1,
    "Uint8Clamped": 1
};

var typedConstructors = {
    "Float64": Float64Array,
    "Float32": Float32Array,
    "Int32": Int32Array,
    "Uint32": Uint32Array,
    "Int16": Int16Array,
    "Uint16": Uint16Array,
    "Int8": Int8Array,
    "Uint8": Uint8Array,
    "Uint8Clamped": Uint8ClampedArray
};

var typedConstructorNames = {
    "Float64": INTRINSICS.FLOAT64ARRAYPROTOTYPE,
    "Float32": INTRINSICS.FLOAT32ARRAYPROTOTYPE,
    "Int32": INTRINSICS.INT32ARRAYPROTOTYPE,
    "Uint32": INTRINSICS.UINT32ARRAYPROTOTYPE,
    "Int16": INTRINSICS.INT16ARRAYPROTOTYPE,
    "Uint16": INTRINSICS.UINT16ARRAYPROTOTYPE,
    "Int8": INTRINSICS.INT8ARRAYPROTOTYPE,
    "Uint8": INTRINSICS.UINT8ARRAYPROTOTYPE,
    "Uint8Clamped": INTRINSICS.UINT8CLAMPEDARRAYPROTOTYPE
};

/**
 * Created by root on 30.03.14.
 */
// ===========================================================================================================
// Integer Indexed Exotic Object
// ===========================================================================================================

function IntegerIndexedExoticObject() {
    var O = Object.create(IntegerIndexedExoticObject.prototype);
    setInternalSlot(O, SLOTS.ARRAYBUFFERDATA, undefined);
    setInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER, undefined);
    setInternalSlot(O, SLOTS.ARRAYLENGTH, undefined);
    setInternalSlot(O, SLOTS.BYTEOFFSET, undefined);
    setInternalSlot(O, SLOTS.TYPEDARRAYNAME, undefined);
    return O;
}
IntegerIndexedExoticObject.prototype = assign(IntegerIndexedExoticObject.prototype, {
    DefineOwnProperty: function (P, Desc) {
        var O = this;
        Assert(IsPropertyKey(P), trans("P_HAS_TO_BE_A_VALID_PROPERTY_KEY"));
        Assert(getInternalSlot(O,SLOTS.ARRAYBUFFERDATA) !== undefined, "[[ArrayBufferData]] must not be undefined");
        if (Type(P) === STRING) {
            var intIndex = ToInteger(P);
            if (isAbrupt(intIndex = ifAbrupt(intIndex))) return intIndex;
            if (SameValue(ToString(intIndex), P)) {
                if (intIndex < 0) return false;
                var len = getInternalSlot(O,SLOTS.ARRAYLENGTH);
                if (len === undefined) return newTypeError( "integerindexed: length is undefined");
                if (intIndex >= len) return false;
                if (IsAccessorDescriptor(Desc)) return false;
                if (Desc.configurable) return false;
                if (Desc.enumerable === false) return false;
                var writable = true; // oder nicht... korrigiere hier
                var makeReadOnly = false;
                if (Desc.writable !== undefined) {
                    if (Desc.writable && !writable) return false;
                    if (!Desc.writable && writable) makeReadOnly = true;
                }
                if (Desc.value !== undefined) {
                    if (!writable) {
                        var oldValue = IntegerIndexedElementGet(O, intIndex);
                        if (isAbrupt(oldValue = ifAbrupt(oldValue))) return oldValue;
                        if (value === undefined) return false;
                        if (!SameValue(value, oldValue)) return false;
                    }
                }
                var status = IntegerIndexedElementSet(O, intIndex, value);
                if (isAbrupt(status = ifAbrupt(status))) return status;
                if (makeReadOnly) {
                    // mark as non-writable
                }
                return true;
            }
        }
        // ordinarygetownproperty im draft, maybe fehler
        return OrdinaryDefineOwnProperty(O, P);
    },
    Get: function (P, R) {
        var O = this;
        Assert(IsPropertyKey(P), trans("P_HAS_TO_BE_A_VALID_PROPERTY_KEY"));
        if ((Type(P) === STRING) && SameValue(O, R)) {
            var intIndex = ToInteger(P);
            if (isAbrupt(intIndex = ifAbrupt(intIndex))) return intIndex;
            if (SameValue(ToString(intIndex), P)) return IntegerIndexedElementGet(O, intIndex);
        }
        return Get(O, P, R);
    },
    Set: function (P, V, R) {
        var O = this;
        Assert(IsPropertyKey(P), trans("P_HAS_TO_BE_A_VALID_PROPERTY_KEY"));
        if ((Type(P) === STRING) && SameValue(O, R)) {
            var intIndex = ToInteger(P);
            if (isAbrupt(intIndex = ifAbrupt(intIndex))) return intIndex;
            if (SameValue(ToString(intIndex), P)) return ToBoolean(IntegerIndexedElementSet(O, intIndex, V));
        }
        return Set(O, P, V, R);

    },
    GetOwnProperty: function (P) {
        var O = this;
        Assert(IsPropertyKey(P), trans("P_HAS_TO_BE_A_VALID_PROPERTY_KEY"));
        Assert(getInternalSlot(O,SLOTS.ARRAYBUFFERDATA) !== undefined, "[[ArrayBufferData]] must not be undefined");
        if (Type(P) === STRING) {
            var intIndex = ToInteger(P);
            if (isAbrupt(intIndex = ifAbrupt(intIndex))) return intIndex;
            if (SameValue(ToString(intIndex), P)) {
                var value = IntegerIndexedElementGet(O, intIndex);
                if (isAbrupt(value = ifAbrupt(value))) return value;
                if (value === undefined) return undefined;
                var writable = true;
                // setze falsch, falls sie es nciht sind, die props vom integerindexed
                return {
                    value: value,
                    enumerable: true,
                    writable: writable,
                    configurable: false
                };
            }
        }
        return OrdinaryGetOwnProperty(O, P);
    },
    HasOwnProperty: function (P) {
        var O = this;
        Assert(IsPropertyKey(P), trans("P_HAS_TO_BE_A_VALID_PROPERTY_KEY"));
        Assert(O.ArrayBufferData !== undefined, "arraybufferdata must not be undefined");
        if (Type(P) === STRING) {
            var intIndex = ToInteger(P);
            if (isAbrupt(intIndex = ifAbrupt(intIndex))) return intIndex;
            if (SameValue(ToString(intIndex), P)) {
                if (intIndex < 0) return false;
                var len = O.ArrayLength;
                if (len === undefined) return newTypeError( "integerindexed: length is undefined");
                if (intIndex >= len) return false;
            }
        }
        return HasOwnProperty(O, P);
    },
    Enumerate: function () {
        return Enumerate(this);
    },
    OwnPropertyKeys: function () {
        return OwnPropertyKeys(this);
    },
    constructor: IntegerIndexedExoticObject,
    toString: function () {
        return "[object IntegerIndexedExoticObject]";
    },
    type: "object"
});
addMissingProperties(IntegerIndexedExoticObject.prototype, OrdinaryObject.prototype);

function IntegerIndexedElementGet(O, index) {
    Assert(Type(index) === NUMBER, "index type has to be number");
    Assert(index === ToInteger(index), "index has to be tointeger of index");
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    var length = getInternalSlot(O, SLOTS.ARRAYLENGTH);
    if (index < 0 || index >= length) return undefined;
    var offset = getInternalSlot(O,SLOTS.BYTEOFFSET);
    var arrayTypeName = getInternalSlot(O,SLOTS.TYPEDARRAYNAME);
    var elementSize = ToNumber(typedArrayElementSize[arrayTypeName]);
    var indexedPosition = (index * elementSize) + offset;
    var elementType = TypedArrayElementType[arrayTypeName];
    return GetValueFromBuffer(buffer, indexedPosition, elementType);
}

function IntegerIndexedElementSet(O, index, value) {
    Assert(Type(index) === NUMBER, "index type has to be number");
    Assert(index === ToInteger(index), "index has to be tointeger of index");
    var O = ToObject(ThisResolution());
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (!buffer) return newTypeError( "object is not a viewed array buffer");
    var length = getInternalSlot(O, SLOTS.ARRAYLENGTH);
    var numValue = ToNumber(value);
    if (isAbrupt(numValue = ifAbrupt(numValue))) return numValue;
    if (index < 0 || index >= length) return numValue;
    var offset = getInternalSlot(O,SLOTS.BYTEOFFSET);
    var arrayTypeName = getInternalSlot(O,SLOTS.TYPEDARRAYNAME);
    var elementSize = ToNumber(typedArrayElementSize[arrayTypeName]);
    var indexedPosition = (index * elementSize) + offset;
    var elementType = TypedArrayElementType[arrayTypeName];
    var status = SetValueInBuffer(buffer, indexedPosition, elementType, numValue);
    if (isAbrupt(status = ifAbrupt(status))) return status;
    return numValue;
}

var typedArrayElementSize = {
    "Float64Array": 8,
    "Float32Array": 4,
    "Int32Array": 4,
    "Uint32Array": 4,
    "Int16Array": 2,
    "Uint16Array": 2,
    "Int8Array": 1,
    "Uint8Array": 1,
    "Uint8ClampedArray": 1
};

var TypedArrayElementType = {
    "Float64Array": "Float64",
    "Float32Array": "Float32",
    "Int32Array": "Int32",
    "Uint32Array": "Uint32",
    "Int16Array": "Int16",
    "Uint16Array": "Uint16",
    "Int8Array": "Int8",
    "Uint8Array": "Uint8",
    "Uint8ClampedArray": "Uint8C"
};

function IntegerIndexedObjectCreate(prototype) {
    var O = IntegerIndexedExoticObject();
    setInternalSlot(O, SLOTS.EXTENSIBLE, true);
    setInternalSlot(O, SLOTS.PROTOTYPE, prototype);
    return O;
}

/**
 * Created by root on 07.05.14.
 */

function TypedArrayFrom(constructor, target, items, mapfn, thisArg) {
    /*

        already defined in intrinics/typedarray.js in var ***_from

        need to copy
     */
}
/**
 * Created by root on 30.03.14.
 */

function NativeJSObjectWrapper(object) {
    if (object instanceof NativeJSObjectWrapper || object instanceof NativeJSFunctionWrapper) return object;
    var O = Object.create(NativeJSObjectWrapper.prototype);
    setInternalSlot(O, "Wrapped", object);
    setInternalSlot(O, SLOTS.BINDINGS, Object.create(null));
    setInternalSlot(O, SLOTS.SYMBOLS, Object.create(null));
    setInternalSlot(O, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.OBJECTPROTOTYPE));
    setInternalSlot(O, SLOTS.EXTENSIBLE, true);
    return O;
}
NativeJSObjectWrapper.prototype = {
    constructor: NativeJSObjectWrapper,
    type: "object",
    toString: function () {
        return "[object EddiesDOMObjectWrapper]";
    },
    Get: function (P) {
        var o = this.Wrapped;
        var p = o[P];
        if (typeof p === "object" && p) {
            return NativeJSObjectWrapper(p);
        } else if (typeof p === "function") {
            return NativeJSFunctionWrapper(p, o);
        }
        return p;
    },
    Set: function (P, V, R) {
        var o = this.Wrapped;
        return o[P] = V;
    },
    Invoke: function (P, argList, Rcv) {
        var f;
        var o = this.Wrapped;
        Rcv = Rcv || this;

        if ((f = this.Get(P)) && (typeof f === "function")) {
            var result = f.apply(o, argList);

            if (typeof result === "object" && result) {
                result = NativeJSObjectWrapper(result);
            } else if (typeof result === "function") {
                result = NativeJSFunctionWrapper(result, o);
            }
            return result;
        } else if (IsCallable(f)) {
            return callInternalSlot(SLOTS.CALL, f, Rcv, argList);
        }
    },
    Delete: function (P) {
        var o = this.Wrapped;
        return (delete o[P]);
    },
    DefineOwnProperty: function (P, D) {
        return Object.defineProperty(this.Wrapped, P, D);
    },
    GetOwnProperty: function (P) {
        return Object.getOwnPropertyDescriptor(this.Wrapped, P);
    },
    HasProperty: function (P) {
        return !!(P in this.Wrapped);
    },
    HasOwnProperty: function (P) {
        var o = this.Wrapped;
        return Object.hasOwnProperty.call(o, P);
    },
    GetPrototypeOf: function () {
        var o = this.Wrapped;
        return Object.getPrototypeOf(o);
    },
    SetPrototypeOf: function (P) {
        var o = this.Wrapped;
        return (o.__proto__ = P);
    },
    IsExtensible: function () {
        var o = this.Wrapped;
        return Object.isExtensible(o);
    }
};

function NativeJSFunctionWrapper(func, that) {
    var F = Object.create(NativeJSFunctionWrapper.prototype);
    setInternalSlot(F, "Wrapped", func);
    setInternalSlot(F, "NativeThis", that);
    setInternalSlot(F, SLOTS.BINDINGS, Object.create(null));
    setInternalSlot(F, SLOTS.SYMBOLS, Object.create(null));
    setInternalSlot(F, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.FUNCTIONPROTOTYPE));
    setInternalSlot(F, SLOTS.EXTENSIBLE, true);
    return F;
}
NativeJSFunctionWrapper.prototype = {
    constructor: NativeJSFunctionWrapper,

    toString: function () {
        return "[object EddiesDOMFunctionWrapper]";
    },
    Call: function (thisArg, argList) {

        var f = this.Wrapped;
        var that = this.NativeThis;
        console.log("arglist");
        console.dir(argList);
        var result = f.apply(that, argList);
        
        
        if (typeof result === "object" && result) {
            result = NativeJSObjectWrapper(result);
        } else if (typeof result === "function") {
            result = NativeJSFunctionWrapper(result, that);
        }
        return NormalCompletion(result);
    }
};
addMissingProperties(NativeJSFunctionWrapper.prototype, NativeJSObjectWrapper.prototype);

/**
 * Created by root on 30.03.14.
 */


function IsSymbol(P) {
    return P instanceof SymbolPrimitiveType;
}

var es5id = Math.floor(Math.random() * (1 << 16));

function SymbolPrimitiveType(id, desc) {
    var O = Object.create(SymbolPrimitiveType.prototype);
    setInternalSlot(O, SLOTS.DESCRIPTION, desc);
    setInternalSlot(O, SLOTS.PROTOTYPE, null);
    setInternalSlot(O, SLOTS.EXTENSIBLE, false);
    setInternalSlot(O, SLOTS.INTEGRITY, "frozen");
    setInternalSlot(O, SLOTS.ES5ID, id || (++es5id + Math.random()));
    return O;
}

SymbolPrimitiveType.prototype = {
    constructor: SymbolPrimitiveType,
    type: "symbol",
    GetPrototypeOf: function () {
        return false;
    },
    SetPrototypeOf: function (P) {
        return false;
    },
    Get: function (P) {
        return false;
    },
    Set: function (P, V) {
        return false;
    },
    Invoke: function (P, Rcv) {
        return false;
    },
    Delete: function (P) {
        return false;
    },
    DefineOwnProperty: function (P, D) {
        return false;
    },
    GetOwnProperty: function (P) {
        return false;
    },
    HasProperty: function (P) {
        return false;
    },
    HasOwnProperty: function (P) {
        return false;
    },
    IsExtensible: function () {
        return false;
    },
    toString: function () {
        return "[object SymbolPrimitiveType]";
    }
};

var $$unscopables        = SymbolPrimitiveType("@@unscopables",         "Symbol.unscopables");
var $$create             = SymbolPrimitiveType("@@create",              "Symbol.create");
var $$toPrimitive        = SymbolPrimitiveType("@@toPrimitive",         "Symbol.toPrimitive");
var $$toStringTag        = SymbolPrimitiveType("@@toStringTag",         "Symbol.toStringTag");
var $$hasInstance        = SymbolPrimitiveType("@@hasInstance",         "Symbol.hasInstance");
var $$iterator           = SymbolPrimitiveType("@@iterator",            "Symbol.iterator");
var $$isRegExp           = SymbolPrimitiveType("@@isRegExp",            "Symbol.isRegExp");
var $$isConcatSpreadable = SymbolPrimitiveType("@@isConcatSpreadable",  "Symbol.isConcatSpreadable");

var $$geti = SymbolPrimitiveType("@@geti",  "Symbol.geti");
var $$seti = SymbolPrimitiveType("@@seti",  "Symbol.seti");

var $$add  = SymbolPrimitiveType("@@ADD",  "Symbol.add");
var $$addr = SymbolPrimitiveType("@@ADDR",  "Symbol.addR");

exports.$$geti = $$geti;
exports.$$seti = $$seti;
exports.$$add = $$add;
exports.$$addr = $$addr;

function thisSymbolValue(value) {
    if (value instanceof CompletionRecord) return thisSymbolValue(value.value);
    if (Type(value) === SYMBOL) return value;
    if (Type(value) === OBJECT && hasInternalSlot(value, SLOTS.SYMBOLDATA)) {
        var b = getInternalSlot(value, SLOTS.SYMBOLDATA);
        if (Type(b) === SYMBOL) return b;
    }
    return newTypeError( "thisSymbolValue: value is not a Symbol");
}



// ===========================================================================================================
// String Exotic Object
// ===========================================================================================================

function StringExoticObject() {
    var S = Object.create(StringExoticObject.prototype);
    setInternalSlot(S, SLOTS.BINDINGS, Object.create(null));
    setInternalSlot(S, SLOTS.SYMBOLS, Object.create(null));
    setInternalSlot(S, SLOTS.EXTENSIBLE, true);
    return S;
}

StringExoticObject.prototype = assign(StringExoticObject.prototype, {
    HasOwnProperty: function (P) {
        Assert(IsPropertyKey(P), trans("P_HAS_TO_BE_A_VALID_PROPERTY_KEY"));
        var has = HasOwnProperty(O, P);
        if (isAbrupt(has = ifAbrupt(has))) return has;
        if (has) return has;
        if (Type(P) !== STRING) return false;
        var index = ToInteger(P);
        if (isAbrupt(index = ifAbrupt(index))) return index;
        var absIndex = ToString(abs(index));
        if (SameValue(absIndex, P) === false) return false;
        var str = this.StringData;
        var len = str.length;
        return len > index;

    },
    GetOwnProperty: function (P) {
        Assert(IsPropertyKey(P), trans("P_HAS_TO_BE_A_VALID_PROPERTY_KEY"));
        var desc = OrdinaryGetOwnProperty(this, P);
        if (isAbrupt(desc = ifAbrupt(desc))) return desc;
        if (desc !== undefined) return desc;
        if (Type(P) !== STRING) return undefined;
        var index = ToInteger(P);
        if (isAbrupt(index = ifAbrupt(index))) return index;
        var absIndex = ToString(abs(index));
        if (SameValue(absIndex, P) === false) return undefined;
        var str = getInternalSlot(this, SLOTS.STRINGDATA);
        var len = str.length;
        if (len <= index) return undefined;
        var resultStr = str[index];
        return {
            value: resultStr,
            enumerable: true,
            writable: false,
            configurable: false
        };
    },
    DefineOwnProperty: function (P, D) {
        var O = this;
        var current = callInternalSlot(SLOTS.GETOWNPROPERTY, O, P);
        var extensible = IsExtensible(this);
        return ValidateAndApplyPropertyDescriptor(O, P, extensible, D, current);
    },
    Enumerate: function () {
	var keys = [];
	var O = this;
	var str = getInternalSlot(O, SLOTS.STRINGDATA);
	var len = str.length;
	for (var i = 0; i < len; i++) keys.push(ToString(i));
        var iterator = Enumerate(this);
        var list = getInternalSlot(iterator, "IteratedList");
        list = keys.concat(list);
        setInternalSlot(iterator, "IteratedList", list);
        return NormalCompletion(list);
    },
    OwnPropertyKeys: function () {
	// just a thrown up
	var keys = [];
	var O = this;
	var str = getInternalSlot(O, SLOTS.STRINGDATA);
	var len = str.length;
	for (var i = 0; i < len; i++) keys.push(ToString(i));
	var bindings = getInternalSlot(O, SLOTS.BINDINGS);
	for (var p in bindings) {
	    var P = +p;
	    if (ToInteger(P) >= len) keys.push(P);
	}
	for (p in bindings) {
	    P = +p;
	    if (P != P)
	    keys.push(p);	
	}
	var symbols = getInternalSlot(O, SLOTS.SYMBOLS)
	for (p in symbols) {
	    var s = symbols[p];
	    if (s && s.symbol) {	// have to add and
		keys.push(s.symbol);	// repair
	    }				// a ES5KEY-SYMBOL-REGISTRY
					// to remove .symbol backref from desc
					// (couldnt get from es5id the sym back w/o reggi)
	}
        return CreateArrayFromList(keys);
    },
    toString: function () {
        return "[object StringExoticObject]";
    },
    type: "object"
});
addMissingProperties(StringExoticObject.prototype, OrdinaryObject.prototype);


function StringCreate(StringData) {
    return OrdinaryConstruct(StringConstructor, [StringData]);
}


function thisStringValue(value) {
    if (value instanceof CompletionRecord) return thisStringValue(value.value);
    if (typeof value === "string") return value;
    if (Type(value) === STRING) return value;
    if (Type(value) === OBJECT && hasInternalSlot(value, SLOTS.STRINGDATA)) {
        var b = getInternalSlot(value, SLOTS.STRINGDATA);
        if (typeof b === "string") return b;
    }
    return newTypeError( "thisStringValue: value is not a String");
}

/**
 * Created by root on 31.03.14.
 */
function thisNumberValue(value) {
    if (value instanceof CompletionRecord) return thisNumberValue(value.value);
    if (typeof value === "number") return value;
    if (Type(value) === NUMBER) return value;
    if (Type(value) === OBJECT && hasInternalSlot(value, SLOTS.NUMBERDATA)) {
        var b = getInternalSlot(value, SLOTS.NUMBERDATA);
        if (typeof b === "number") return b;
    }
    return newTypeError("thisNumberValue: value is not a Number");
}

/**
 * Created by root on 31.03.14.
 */
function thisBooleanValue(value) {
    if (value instanceof CompletionRecord) return thisBooleanValue(value.value);
    if (typeof value === "boolean") return value;
    if (Type(value) === BOOLEAN) return value;
    if (Type(value) === OBJECT && hasInternalSlot(value, SLOTS.BOOLEANDATA)) {
        var b = getInternalSlot(value, SLOTS.BOOLEANDATA);
        if (typeof b === "boolean") return b;
    }
    return newTypeError( "thisBooleanValue: value is not a Boolean");
}



    
function ProxyExoticObject(handler, target) {
    var P = Object.create(ProxyExoticObject.prototype);
    setInternalSlot(P, SLOTS.PROTOTYPE, getIntrinsic(INTRINSICS.PROXYPROTOTYPE));
    setInternalSlot(P, SLOTS.EXTENSIBLE, true);
    setInternalSlot(P, SLOTS.PROXYHANDLER, handler);
    setInternalSlot(P, SLOTS.PROXYTARGET, target);
    return P;
}

ProxyExoticObject.prototype = {
    constructor: ProxyExoticObject,
    type: "object",
    toString: function () {
        return "[object ProxyExoticObject]";
    },
    GetPrototypeOf: function () {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "getPrototypeOf");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return GetPrototypeOf(T);
        var handlerProto = callInternalSlot(SLOTS.CALL, trap, handler, [T]);
        if (isAbrupt(handlerProto = ifAbrupt(handlerProto))) return handlerProto;
        var targetProto = GetPrototypeOf(T);
        if (isAbrupt(targetProto = ifAbrupt(targetProto))) return targetProto;
        if (!SameValue(handlerProto, targetProto)) return newTypeError( "handler and target protos differ");
        return handlerProto;
    },

    SetPrototypeOf: function (V) {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "setPrototypeOf");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return SetPrototypeOf(T, V);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T, V]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        trapResult = ToBoolean(trapResult);
        var extensibleTarget = IsExtensible(T);
        if (isAbrupt(extensibleTarget = ifAbrupt(extensibleTarget))) return extensibleTarget;
        if (extensibleTarget === true) return trapResult;
        var targetProto = GetPrototypeOf(T);
        if (isAbrupt(targetProto = ifAbrupt(targetProto))) return targetProto;
        if (!SameValue(V, targetProto)) return newTypeError( "prototype argument and targetProto differ");
        return trapResult;
    },

    IsExtensible: function () {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "isExtensible");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return IsExtensible(T);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        trapResult = ToBoolean(trapResult);
        var booleanTrapResult = ToBoolean(trapResult);
        if (isAbrupt(booleanTrapResult = ifAbrupt(booleanTrapResult))) return booleanTrapResult;
        var targetResult = IsExtensible(T);
        if (isAbrupt(targetResult = ifAbrupt(targetResult))) return targetResult;
        if (!SameValue(booleanTrapResult, targetResult)) return newTypeError( "trap and target boolean results differ");
        return booleanTrapResult;
    },

    PreventExtensions: function () {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "preventExtensions");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return PreventExtensions(T);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        var booleanTrapResult = ToBoolean(trapResult);
        if (isAbrupt(booleanTrapResult = ifAbrupt(booleanTrapResult))) return booleanTrapResult;
        var targetIsExtensible = IsExtensible(T);
        if (isAbrupt(targetIsExtensible = ifAbrupt(targetIsExtensible))) return targetIsExtensible;
        if (booleanTrapResult === true && targetIsExtensible === true) return newTypeError( "target still extensible");
        return targetIsExtensible;
    },

    HasOwnProperty: function (P) {
        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "hasOwn");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return HasOwnProperty(T, P);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T, P]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        var success = ToBoolean(trapResult);
        var extensibleTarget;
        var targetDesc;
        if (!success) {
            targetDesc = GetOwnProperty(T, P);
            if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
            if (targetDesc) {
                if (targetDesc.configurable === false) return newTypeError( "targetDesc.configurable is false");
                extensibleTarget = IsExtensible(T);
                if (isAbrupt(extensibleTarget = ifAbrupt(extensibleTarget))) return extensibleTarget;
                if (ToBoolean(extensibleTarget) === false) return newTypeError( "target is not extensible");
            }
        } else {
            extensibleTarget = IsExtensible(T);
            if (isAbrupt(extensibleTarget = ifAbrupt(extensibleTarget))) return extensibleTarget;
            if (ToBoolean(extensibleTarget) === true) return success;
            targetDesc = GetOwnProperty(T, P);
            if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
            if (targetDesc === undefined) return newTypeError( "target descriptor is undefined");
        }
        return success;
    },

    GetOwnProperty: function (P) {
        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "getOwnPropertyDescriptor");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return GetOwnProperty(T, P);
        var trapResultObj = callInternalSlot(SLOTS.CALL, trap, H, [T, P]);
        if (isAbrupt(trapResultObj = ifAbrupt(trapResultObj))) return trapResultObj;
        if (Type(trapResultObj) !== OBJECT && Type(trapResultObj) !== UNDEFINED) return newTypeError( "getown - neither object nor undefined");
        var targetDesc = GetOwnProperty(T, P);
        if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
        var extensibleTarget;
        if (Type(trapResultObj) === UNDEFINED) {
            if (targetDesc === undefined) return undefined;
            if (targetDesc.configurable === false) return newTypeError( "inconfigurable target problem");
            extensibleTarget = IsExtensible(T);
            if (isAbrupt(extensibleTarget = ifAbrupt(extensibleTarget))) return extensibleTarget;
            if ((extensibleTarget = ToBoolean(extensibleTarget)) === false) return newTypeError( "target is not extensible");
            return undefined;
        }
        extensibleTarget = IsExtensible(T);
        if (isAbrupt(extensibleTarget = ifAbrupt(extensibleTarget))) return extensibleTarget;
        extensibleTarget = ToBoolean(extensibleTarget);
        var resultDesc = ToPropertyDescriptor(trapResultObj);
        CompletePropertyDescriptor(resultDesc, targetDesc);
        var valid = IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc);
        if (!valid) return newTypeError( "invalid property descriptor");
        if (resultDesc.configurable === false) {
            if (targetDesc === undefined || targetDesc.configurable === true) return newTypeError( "descriptor configurability mismatch");
        }
        return resultDesc;
    },

    DefineOwnProperty: function (P, D) {
        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "defineProperty");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return DefineOwnProperty(T, P, D);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T, P, D]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        var targetDesc = GetOwnProperty(T, P);
        if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
        var extensibleTarget = ToBoolean(extensibleTarget);
        var settingConfigFalse;
        settingConfigFalse = D.configurable !== undefined && !D.configurable;
        if (targetDesc === undefined) {
            if (!extensibleTarget) return newTypeError( "target not extensible");
            if (settingConfigFalse) return newTypeError( "not configurable descriptor or undefined and no target descriptor?!");
        } else {
            if (!IsCompatiblePropertyDescriptor(extensibleTarget, D, targetDesc)) return newTypeError( "incompatible descriptors");
            if (settingConfigFalse && targetDesc.configurable) return newTypeError( "configurability incomptatiblity");
        }
        return true;
    },

    HasProperty: function (P) {
        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "has");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return HasProperty(T, P);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T, P]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        var success = ToBoolean(trapResult);
        if (!success) {
            var targetDesc = GetOwnProperty(T, P);
            if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
            if (targetDesc) {
                if (targetDesc.configurable === false) return newTypeError( "targetDesc.configurable is false");
                extensibleTarget = IsExtensible(T);
                if (isAbrupt(extensibleTarget = ifAbrupt(extensibleTarget))) return extensibleTarget;
                if (ToBoolean(extensibleTarget) === false) return newTypeError( "target is not extensible");
            }
        }
        return success;
    },

    Get: function (P) {
        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "get");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return Get(T, P);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T, P]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;

        var targetDesc = GetOwnProperty(T, P);
        if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
        if (targetDesc) {
            if (IsDataDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {
                if (!SameValue(trapResult, targetDesc.value)) return newTypeError( "trap and target values differ");
            } else if (IsAccessorDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.get === undefined) {
                if (trapResult) return newTypeError( "Getter problem, undefined and not configurable");
            }
        }
        return trapResult;
    },
    Set: function (P, V, R) {
        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "set");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return Set(T, P, V, R);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T, P, V, R]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        if (ToBoolean(trapResult) === false) return newTypeError( "cant set value with trap");
        var targetDesc = GetOwnProperty(T, P);
        if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
        if (targetDesc) {
            if (IsDataDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {
                if (!SameValue(trapResult, targetDesc.value)) return newTypeError( "trap and target values differ");
            } else if (IsAccessorDescriptor(targetDesc) && targetDesc.configurable === false) {
                if (targetDesc.set === undefined) return newTypeError( "Getter problem, undefined and not configurable");
            }
        }
        return true;
    },
    Invoke: function (P, A, R) {
        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "invoke");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return Invoke(T, P, A, R);
        var argArray = CreateArrayFromList(A);
        return callInternalSlot(SLOTS.CALL, trap, H, [T, P, argArray, R]);
    },
    Delete: function (P) {

        Assert(IsPropertyKey(P) === true);
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "deleteProperty");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return Delete(T, P);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T, P]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;

        if (ToBoolean(trapResult) === false) return false;
        var targetDesc = GetOwnProperty(T, P);
        if (isAbrupt(targetDesc = ifAbrupt(targetDesc))) return targetDesc;
        if (targetDesc === undefined) return true;
        if (targetDesc.configurable === false) return newTypeError( "property is not configurable");
        return true;

    },

    Enumerate: function () {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "enumerate");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return Enumerate(T);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        if (Type(trapResult) !== OBJECT) return newTypeError( "trapResult is not an object");
        return trapResult;
    },
    OwnPropertyKeys: function () {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "ownKeys");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return OwnPropertyKeys(T);
        var trapResult = callInternalSlot(SLOTS.CALL, trap, H, [T]);
        if (isAbrupt(trapResult = ifAbrupt(trapResult))) return trapResult;
        if (Type(trapResult) !== OBJECT) return newTypeError( "trapResult is not an object");
        return trapResult;
    },

    Call: function (thisArg, argList) {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "apply");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return callInternalSlot(SLOTS.CALL,T, thisArg, argList);
        var argArray = CreateArrayFromList(argList);
        return callInternalSlot(SLOTS.CALL, trap, H, [T, thisArg, argArray]);
    },

    Construct: function (argList) {
        var T = getInternalSlot(this, SLOTS.PROXYTARGET);
        var H = getInternalSlot(this, SLOTS.PROXYHANDLER);
        var trap = GetMethod(H, "construct");
        if (isAbrupt(trap = ifAbrupt(trap))) return trap;
        if (trap === undefined) return callInternalSlot(SLOTS.CONSTRUCT, T, argList);
        var argArray = CreateArrayFromList(argList);
        var newObj = callInternalSlot(SLOTS.CALL, trap, H, [T, argArray]);
        if (isAbrupt(newObj = ifAbrupt(newObj))) return newObj;
        if (Type(newObj) !== OBJECT) return newTypeError( "returned value is not an object");
        return newObj;
    }
};
/**
 * Created by root on 31.03.14.
 */


    // ===========================================================================================================
    // 8.4 Tasks and Task Queues
    // ===========================================================================================================

function PendingTaskRecord_toString () {
    return "[object PendingTaskRecord]";
}

function PendingTaskRecord (task, args, realm) {
    var pendingTaskRecord = Object.create(PendingTaskRecord.prototype);
    pendingTaskRecord.Task = task;
    pendingTaskRecord.Arguments = args;
    pendingTaskRecord.Realm = realm;
    return pendingTaskRecord;
}
PendingTaskRecord.prototype = Object.create(null);
PendingTaskRecord.prototype.constructor = PendingTaskRecord;
PendingTaskRecord.prototype.toString = PendingTaskRecord_toString;

function TaskQueue() {
    return [];
}

function makeTaskQueues(realm) {
    realm.LoadingTasks = TaskQueue();
    realm.PromiseTasks = TaskQueue();
    realm.ScriptEvaluationTasks = TaskQueue();
    realm.TimerTasks = TaskQueue();
}

function getTasks(realm, name) {
    if (realm) return realm[name];
}

var queueNames = {
    __proto__:null,
    "LoadingTasks": true,
    "PromiseTasks": true,
    "TimerTasks": true      // added for setTimeout
};

function EnqueueTask(queueName, task, args) {
    Assert(Type(queueName) === STRING && queueNames[queueName], "EnqueueTask: queueName has to be valid");
    Assert(Array.isArray(args), "arguments have to be a list and to be equal in the number of arguments of task");

    var callerRealm = getRealm();
    var pending = PendingTaskRecord(task, args, callerRealm);

    switch(queueName) {
        case "PromiseTasks": callerRealm.PromiseTasks.push(pending);
            break;
        case "LoadingTasks": callerRealm.LoadingTasks.push(pending);
            break;
        case "TimerTasks": callerRealm.TimerTasks.push(pending);
            break;
    }
    return NormalCompletion(empty);
}

function NextTask (result, nextQueue) {
    if (!nextQueue || !nextQueue.length) return;
    if (isAbrupt(result = ifAbrupt(result))) {
        // performing implementation defined unhandled exception processing
        console.log("NextTask: Got exception - which will remain unhandled - for debugging, i print them out." );
        printException(result);
    }

//  Assert(getStack().length === 0, "NextTask: The execution context stack has to be empty");
    var nextPending = nextQueue.shift();
    if (!nextPending) return;
    var newContext = ExecutionContext(null, getRealm());
    newContext.realm = nextPending.Realm;
    getStack().push(newContext);
    var result = callInternalSlot(SLOTS.CALL, nextPending.Task, undefined, nextPending.Arguments);
    if (isAbrupt(result=ifAbrupt(result))) {
        if (hasConsole) {
            var ex = exports.makeNativeException(ex);
            console.log("NextTask got abruptly completed on [[Call]] of nextPending.Task");
            if (typeof ex == "object") {
                console.log(ex.name);
                console.log(ex.message);
                console.log(ex.stack);
            }
        }
    }
    getStack().pop();
    return NextTask(result, nextQueue);
}



function ScriptEvaluationTask (source) {
    Assert(typeof source === "string", "ScriptEvaluationTask: Source has to be a string");
    var status = NormalCompletion(undefined);
    try {
	var script = parse(source);
    } catch (ex) {
	return newSyntaxError( ex.message);
    }
    var realm = getRealm();
    status = ScriptEvaluation(script, realm, false); // evaluation.Program(ast)
    return NextTask(status)
}

/**
 * Created by root on 31.03.14.
 */

var standard_properties = {
    __proto__: null,
    "Array": true,
    "Error": true,
    "Function": true,
    "Object": true,
    "Symbol": true
};

function DefineBuiltinProperties(O) {
    var globalThis = getGlobalThis();
    for (var name in standard_properties) {
        if (standard_properties[name] === true) {
            var desc = callInternalSlot(SLOTS.GETOWNPROPERTY, globalThis, name);
            var status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, O, name, desc);
            if (isAbrupt(status)) return status;
        }
    }
    return O;
}


/**
 * Created by root on 31.03.14.
 */

function NewModuleEnvironment(global) {
    return DeclarativeEnvironment(global);
}

/**
 * Created by root on 07.04.14.
 */

function ModuleExoticObject (environment, exports) {
    var m = Object.create(ModuleExoticObject.prototype);
    setInternalSlot(m, "ModuleEnvironment", environment);
    setInternalSlot(m, "Exports", exports);
    return m;
}

ModuleExoticObject.prototype = {
    constructor: "ModuleExoticObject",
    toString: function () { return "[ModuleExoticObject]"; },
    Get: function (P, R) {
        var O = this;
        Assert(IsPropertyKey(P), "[[Delete]] expecting P to be a valid property key");  
        var exports = getInternalSlot(O, "Exports");
        if (exports.indexOf(P) > -1) return undefined;
        var env = getInternalSlot(O, "ModuleEnvironment");
        return env.GetBindingValue(P, true);
    },
    Set: function () {
        return false;
    },
    Delete: function (P) {
        Assert(IsPropertyKey(P), "[[Delete]] expecting P to be a valid property key");
        var exports = getInternalSlot(O, "Exports");
        return exports.indexOf(P) <= -1;

    },
    Enumerate: function () {
        var O = this;
        var exports = getInternalSlot(O, "Exports");
        return CreateListIterator(exports);
    },
    OwnPropertyKeys: function () {
        var O = this;
        var exports = getInternalSlot(O, "Exports");
        return CreateArrayFromList(exports);
    },
    HasProperty: function (P) {
        var O = this;
        var exports = getInternalSlot(O, "Exports");
        return exports.indexOf(P) > -1;

    },
    GetOwnProperty: function () {
        return newTypeError( "The [[GetOwnProperty]] of ModuleExoticObjects is supposed to throw a TypeError.")
    },
    DefineOwnProperty: function () {
        return false;
    },
    GetPrototypeOf: function () {
        return null;
    },
    SetPrototypeOf: function (O) {
        Assert(Type(O) === OBJECT || Type(O) === NULL, "Module.SetPrototypeOf: Expecting object or null before returning false anyways");
        return false;
    },
    IsExtensible: function () {
        return false;
    }
};
addMissingProperties(ModuleExoticObject.prototype, OrdinaryObject.prototype);

function ModuleObjectCreate(environment, exports) {
    Assert(environment.Bindings, "environment has to be a declarative record");
    Assert(Array.isArray(exports), "exports has to be a list of string values");
    // in a typed mem there will the pointers to the methods be set coz there is no
    // prototype. we can point to native hashes, too, by just knowing the meaning of
    // the pointer.
    var m = ModuleExoticObject(environment, exports);
    return m;
}

exports.ModuleObjectCreate = ModuleObjectCreate;
exports.ModuleExoticObject = ModuleExoticObject;
exports.NewModuleEnvironment = NewModuleEnvironment;


function List() {
    var list = Object.create(List.prototype);
    var sentinel = { next: undefined, prev: undefined, value: undefined };
    sentinel.next = sentinel;
    sentinel.prev = sentinel;
    list.sentinel = sentinel;
    list.size = 0;
    return list;
}
List.prototype.insertFirst = function (item) {
    var rec = {
        next: this.sentinel,
        prev: this.sentinel.prev,
        value: item
    };
    this.sentinel.prev.next = rec;
    this.sentinel.prev = rec;
    this.size += 1;
    return this;
};
List.prototype.insertLast = function (item) {
    var rec = {
        next: this.sentinel,
        prev: this.sentinel.next,
        value: item
    };
    this.sentinel.next.prev = rec;
    this.sentinel.next = rec;
    this.size += 1;
    return this;
};
List.prototype.iterate = function (f) {
    var rec = this.sentinel.next;
    while (rec !== this.sentinel) {
        f(rec.value);
        rec = rec.next;
    }
    return this;
};
List.prototype.reverse = function (f) {
    var rec = this.sentinel.prev;
    while (rec !== this.sentinel) {
        f(rec.value);
        rec = rec.prev;
    }
};
List.prototype.nth = function (n) {
    var rec, i;
    if (n > this.size - 1 || n < 0) return null;
    if (n < this.size / 2) {
        i = 0;
        rec = this.sentinel;
        do {
            rec = rec.next;
            if (i === n) return rec.value;
            i += 1;
        } while (i <= n);
    } else {
        i = this.size - 1;
        rec = this.sentinel;
        do {
            rec = rec.prev;
            if (i === n) return rec.value;
            i -= 1;
        } while (i >= n);
    }
    return null;
};
List.prototype.removeFirst = function () {
    var rec = this.sentinel.next;
    if (rec != this.sentinel) {
        this.sentinel.next = rec.next;
        this.sentinel.next.prev = this.sentinel;
        rec.next = null;
        rec.prev = null;
        this.size -= 1;
        return rec.value;
    }
    return null;
};
List.prototype.removeLast = function () {
    var rec = this.sentinel.prev;
    if (rec != this.sentinel) {
        this.sentinel.prev = rec.prev;
        this.sentinel.prev.next = this.sentinel;
        rec.next = null;
        rec.prev = null;
        this.size -= 1;
        return rec.value;
    }
    return null;
};
List.prototype.push = List.prototype.insertLast;
List.prototype.pop = List.prototype.removeLast;
List.prototype.shift = List.prototype.removeFirst;
List.prototype.unshift = List.prototype.insertFirst;


var tables = require("tables");
var LineTerminators = tables.LineTerminators;

exports.RegExpCreate = RegExpCreate;

function RegExpCreate(P, F) {
    var obj = RegExpAllocate(getIntrinsic(INTRINSICS.REGEXP));
    if (isAbrupt(obj=ifAbrupt(obj))) return obj;
    return RegExpInitialize(obj, P, F);
}

function EscapeRegExpPattern(P, F) {
    var S = "";
    for (var i = 0, j = P.length; i < j; i++) {
        var codePoint = P[i];
        if (codePoint === "/" && P[i-1] != "\\" || P[i-2]=="\\") {
            S += "\\/";
        } else S += codePoint;
    }
    return S;
}

function RegExpInitialize(obj, pattern, flags) {

    var P, F, BMP;
    if (pattern === undefined) P = "";
    else P = ToString(pattern);
    if (isAbrupt(P=ifAbrupt(P))) return P;
    if (flags === undefined) F = "";
    else F = ToString(flags);
    BMP = F.indexOf("u") === -1;

    var parse = require("regexp-parser").parse;
    var patternCharacters = parse(P);

    setInternalSlot(obj, SLOTS.ORIGINALFLAGS, F);
    setInternalSlot(obj, SLOTS.ORIGINALSOURCE, P);
    setInternalSlot(obj, SLOTS.REGEXPMATCHER, createRegExpMatcher(patternCharacters));

    var putStatus = Put(obj, "lastIndex", 0, true);
    if (isAbrupt(putStatus=ifAbrupt(putStatus))) return putStatus;
    return NormalCompletion(obj);
}

function RegExpAllocate(constructor) {

    var obj = OrdinaryCreateFromConstructor(constructor, INTRINSICS.REGEXPPROTOTYPE,[
        SLOTS.REGEXPMATCHER,
        SLOTS.ORIGINALSOURCE,
        SLOTS.ORIGINALFLAGS
    ]);
    var status = DefineOwnPropertyOrThrow(obj, "lastIndex", {
        writable: true,
        configurable: false,
        enumerable: false,
        value: undefined

    });
    if (isAbrupt(status = ifAbrupt(status))) return status;
    return NormalCompletion(obj);
}

function RegExpExec (R, S, ignore) {
    Assert(getInternalSlot(R, SLOTS.REGEXPMATCHER) != undefined, "RegExpExec: R must be a initialized RegExp instance");
    Assert(Type(S) === STRING);
    Assert(ignore !== undefined ? Type(ignore) === BOOLEAN : true, "ignore has to be a bool if ignore is provided");
    var length = S.length;
    var global, sticky, matcher, flags, matchSucceeded, e, fullUnicode, putStatus, eUTF;
    if (ignore === undefined) ignore = false;
    if (ignore) global = false;
    else {
        var lastIndex = Get(R, "lastIndex");
        var i = ToInteger(lastIndex);
        if (isAbrupt(i = ifAbrupt(i))) return i;
        var global = ToBoolean(Get(R, "global"));
        if (isAbrupt(global = ifAbrupt(global))) return global;
    }
    sticky = ToBoolean(Get(R, "sticky"));
    if (isAbrupt(sticky = ifAbrupt(sticky))) return sticky;
    matcher = getInternalSlot(R, SLOTS.REGEXPMATCHER);
    flags = getInternalSlot(R, SLOTS.ORIGINALFLAGS);
    fullUnicode = flags.indexOf("u") > -1;
    matchSucceeded = false;
    while (!matchSucceeded) {
        if (i < 0 || i > length) {
            if (ignore) {
                putStatus = Put(R, "lastIndex", 0, true);
                if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
                return NormalCompletion(null);
            }
        }
        var r = matcher(S, i);
        if (r === FAILURE) {
            if (sticky) {
                if (ignore) {
                    putStatus = Put(R, "lastIndex", 0, true);
                    if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
                }
            	return NormalCompletion(null);
            }
            i = i + 1;
        } else {
    	    if (!(r && r.endIndex && r.captures)) return newTypeError( "RegExpExec: r has to be a state instance. Assertion failed.");
            Assert(r && r.endIndex && r.captures, "RegExpExec: r has to be a state instance");
            matchSucceeded = true;
        }
    }
    e = r.endIndex;
    if (fullUnicode) {
            // index
    }
    if (global) {
        putStatus = Put(R, "lastIndex", e, true);
        if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
    }
    var n = matcher.evaluator.NCapturingParens;
    var A = ArrayCreate(n + 1);
    var matchIndex = i;
    var status;
    status = CreateDataProperty(A, "index", matchindex);
    if (isAbrupt(status)) return status;
    status = CreateDataProperty(A, "input", S);
    if (isAbrupt(status)) return status;
    status = CreateDataProperty(A, "length", n + 1);
    if (isAbrupt(status)) return status;
    var matchedSubstr = S.substr(i, e);
    status = CreateDataProperty(A, "0", matchedSubstr);
    var captureString;
    for (i = 1; i <= n; i++) {
        var captureI = r.captures[i];
        if (fullUnicode) {
            captureString = captureI;
        } else {
            captureString = captureI;
        }
        status = CreateDataProperty(A, ToString(i), captureString);
        if (isAbrupt(status)) return status;
    }
    return NormalCompletion(A);
}

/*



*/

var FAILURE = {};

function createRegExpMatcher(pattern) {
    var patternMatcher; // Evaluate(Pattern::Disjunction) returns the [[RegExpMatcher]](x,c) i guess
    var evaluator = function() {
        return patternMatcher.apply(evaluator, arguments);
    };
    // variables
    evaluator.flags = undefined;
    evaluator.Input = undefined;	// will be pattern characters or the STR
    evaluator.inputLength = 0;
    evaluator.NCapturingParens = 0;
    evaluator.ignoreCase = false;
    evaluator.Multiline = false;
    evaluator.Unicode = false;
    // interpreter
    evaluator.Pattern = Pattern;
    evaluator.Disjunction = Disjunction;
    evaluator.Alternative = Alternative;
    evaluator.Term = Term;
    evaluator.Assertion = Assertion;
    evaluator.isFailure = function (r) {
        return r === FAILURE;
    };
    evaluator.Continuation = function (steps) {
        return steps;
    };
    evaluator.State = function (endIndex, captures) {
        return { endIndex: endIndex, captures: captures };
    };
    evaluator.evaluate = function (node) {
	if (node === undefined) return FAILURE;
        var f = this[node.type];4;
        if (f) return f.call(evaluator, node);
    };
    patternMatcher = evaluator.evaluate.call(evaluator, pattern);
    evaluator.patternMatcher = patternMatcher;
    return evaluator;
}

function Pattern (node) {
    // start at Pattern :: Disjunction
    var disjunction = node.disjunction;
    var m = this.evaluate(disjunction);
    // i guess here the compiled stuff can land.
    // and the closure just works on bytestreams anyways

    return function matcher (str, index) {
        this.Input = new String(str);
        var listIndex = this.Input.indexOf(str[index]);
        this.InputLength = this.Input.length;
        var c = this.Continuation(function (state) { return state; });
        var cap = new Array((this.NCapturingParens|0) + 1); // indexed 1 bis
        var x = this.State(listIndex, cap);

        if (m != FAILURE) return m.call(this, x,c);
        // temp disabled
    };
}

function Disjunction (node) {
    var alternative = node.alternative;
    var disjunction = node.disjunction;
    if (!disjunction && alternative) {			// gates
        var a = this.evaluate(alternative);
        if (!a) return FAILURE;
        return a;
    } else if (disjunction && alternative) {		// power on
        var m1 = this.evaluate(alternative);
        if (!m1) return FAILURE;
        var m2 = this.evaluate(disjunction);
        if (!m2) return FAILURE;
        return function m(x, c) {
            var r;

            r = m1.call(this, x, c);
            if (!this.isFailure(r)) return r;

            return m2.call(this, x, c);
        };
    }
    return FAILURE;
}

function Alternative(node) {
    if (!node) return FAILURE;
    var alternative = node.atom;
    var term = node.term;
    // abc ist alternative alternative term.. oder [x,y,]
    if (!atom) return FAILURE;
}

function Term (node) {
    if (!node) return FAILURE;
    if (node.assertion) {
        return this.evaluate(node.assertion);
    }
    return FAILURE;
}

function Assertion(node) {
    return function m (x, c) {
        if (node == "^") {
            return function assertion_tester_caret (x) {
                var e = x.endIndex;
                if (e === 0) return true;
                if (this.Multiline === false) return false;
                return LineTerminators[this.Input[e-1]];
            }
        }

        var r = !!t.call(this, c);
        if (!r) return null;
        return c.call(this, x);
    };
}


    // Structured Clone Algorithms
    // strawman for es7
    // https://github.com/dslomov-chromium/ecmascript-structured-clone
function StructuredClone (input, transferList, targetRealm) {
    var memory = []; //mapping
    for (var i = 0, j = transferList.length; i< j; i++) {
        var transferable = transferList[i];
        if (!hasInternalSlot(transferable, "Transfer")) {
            return newRangeError( "DataCloneError: transferable has no [[Transfer]] slot");
        }
        var Transfer = getInternalSlot(transferable, "Transfer");
        var transferResult = callInternalSlot(SLOTS.CALL, Transfer, transferable, [targetRealm]);
        if (isAbrupt(transferResult = ifAbrupt(transferResult))) return transferResult;
        memory.push({ input: transferable, output: transferResult });
    }
    var clone = InternalStructuredClone(input, memory, targetRealm);
    if (isAbrupt(clone = ifAbrupt(clone))) return clone;
    for (var i = 0, j = transferList.length; i < j; i++) {
        var mapping = memory[i];
        transferResult = mapping.output;
        transferable = mapping.input;
        var OnSuccessTransfer = getInternalSlot(transferable, "OnSuccessTransfer");
        callInternalSlot(SLOTS.CALL, OnSuccessTransfer, transferable, [transferResult, targetRealm]);
    }
    return NormalCompletion(clone);
}

function InternalStructuredClone (input, memory, targetRealm) {
    var output;
    for (var i = 0, j = memory.length; i < j; i++) {
        if (memory[i].transferable === input) return NormalCompletion(memory[i].output);
    }
    if (getInternalSlot(input, "Transfer") === "neutered") return newRangeError( "DataCloneError: inputs [[Transfer]] is neutered.");
    var value;
    if ((value = getInternalSlot(input, SLOTS.BOOLEANDATA)) !== undefined) {
        output = OrdinaryConstruct(getIntrinsic(INTRINSICS.BOOLEAN, targetRealm), [value]);
    }
    else if ((value = getInternalSlot(input, SLOTS.NUMBERDATA)) !== undefined) {
        output = OrdinaryConstruct(getIntrinsic(INTRINSICS.NUMBER, targetRealm), [value]);
    }
    else if ((value = getInternalSlot(input, SLOTS.STRINGDATA)) !== undefined) {
        output = OrdinaryConstruct(getIntrinsic(INTRINSICS.STRING, targetRealm), [value]);
    }
    else if ((value = getInternalSlot(input, SLOTS.REGEXPMATCHER)) !== undefined) {
        output = OrdinaryConstruct(getIntrinsic(INTRINSICS.REGEXP, targetRealm), []);
        setInternalSlot(output, SLOTS.REGEXPMATCHER, value);
        setInternalSlot(output, SLOTS.ORIGINALSOURCE, getInternalSlot(input, SLOTS.ORIGINALSOURCE));
        setInternalSlot(output, SLOTS.ORIGINALFLAGS, getInternalSlot(input, SLOTS.ORIGINALFLAGS));
    } else if ((value = getInternalSlot(input, SLOTS.ARRAYBUFFERDATA)) !== undefined) {
        output = CopyArrayBufferToRealm(input, targetRealm);
        if (isAbrupt(output = ifAbrupt(output))) return output;
    } else if ((value = getInternalSlot(input, SLOTS.VIEWEDARRAYBUFFER)) !== undefined) {
        var arrayBuffer = value;
        //if (OrdinaryHasInstance(getIntrinsic(INTRINSICS.DATAVIEW)), input) { // assumes i´m in source realm
        if (!hasInternalSlot(input, SLOTS.TYPEDARRAYCONSTRUCTOR)) {
            output = OrdinaryConstruct(getIntrinsicFromRealm(INTRINSICS.DATAVIEW, targetRealm), []);
            setInternalSlot(output, SLOTS.VIEWEDARRAYBUFFER, getInternalSlot(input, SLOTS.VIEWEDARRAYBUFFER));
            setInternalSlot(output, SLOTS.BYTEOFFSET, getInternalSlot(input, SLOTS.BYTEOFFSET));
            setInternalSlot(output, SLOTS.BYTELENGTH, getInternalSlot(input, SLOTS.BYTELENGTH));
        } else {
            output = OrdinaryConstruct(getIntrinsicFromRealm("%"+getInternalSlot(input, SLOTS.TYPEDARRAYCONSTRUCTOR)+"%", targetRealm), []);
            setInternalSlot(output, SLOTS.VIEWEDARRAYBUFFER, getInternalSlot(input, SLOTS.VIEWEDARRAYBUFFER));
            setInternalSlot(output, SLOTS.BYTEOFFSET, getInternalSlot(input, SLOTS.BYTEOFFSET));
            setInternalSlot(output, SLOTS.BYTELENGTH, getInternalSlot(input, SLOTS.BYTELENGTH));
        }
    } else if (hasInternalSlot(input, SLOTS.MAPDATA)) {
        // hmmm missing
        // structured clone of values or what is the problem?
    } else if (hasInternalSlot(input, SLOTS.SETDATA)) {
        // hmm missing
        // this can be quite hard to have copy all values, but it would be correct to create them again.
    } else if (IsArray(input)) {
        // i need to know when i am in which realm, first. The functions will not work like they are supposed to now.
        output = ArrayCreate(0); // how do i create them in targetRealm?
        // shall i switch with setRealm(targetRealm), setRealm(sourceRealm) for demo? it has no effect in memory anyways for me yet.
        var len = Get(input, "length", input);
        Set(output, "length", len, output);

    } else if (IsCallable(input)) {
        return newRangeError( "DataCloneError: Can not clone a function.");
    } else if (hasInternalSlot(input, SLOTS.ERRORDATA)) {
        return newRangeError( "DataCloneError: Can not clone error object.");
    } else if (Type(input) === OBJECT && input.toString() !== "[object OrdinaryObject]") {
        return newRangeError( "DataCloneError: Can only copy ordinary objects, no exotic objects");
    } else {
        // setRealm() img.
        output = ObjectCreate();
        // unsetRealm() img.
        var deepClone = true;
    }
    memory.push({ input: input, output: output });
    if (deepClone) {
        var keys = OwnPropertyKeysAsList(output);
        var outputKey;
        for (var i = 0, j = keys.length; i < j; i++) {
            if (Type(key) === STRING) outputKey = key;
            // if (Type(key) === SYMBOL) outputKey = key;
            var sourceValue = Get(input, key);
            if (isAbrupt(sourceValue = ifAbrupt(sourceValue))) return sourceValue;
            var clonedValue = InternalStructuredClone(sourceValue, memory);
            if (isAbrupt(clonedValue = ifAbrupt(clonedValue))) return clonedValue;
            var outputSet = Set(output, outputKey, clonedValue, output);
            if (isAbrupt(outputSet)) return outputSet;
        }
    }
    return NormalCompletion(output);
}

// object.[[Transfer]](targetRealm)
var Transfer_Call = function (thisArg, argList) {
    var targetRealm = argList[0];
    var object = thisArg;
    if (hasInternalSlot(object, SLOTS.ARRAYBUFFERDATA))
        return CopyArrayBufferToRealm(object, targetRealm);
};

function CopyArrayBufferToRealm(arrayBuffer, targetRealm) {
    var ArrayBufferConstructor = getIntrinsicFromRealm(INTRINSICS.ARRAYBUFFER, targetRealm);
    var length = getInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERBYTELENGTH);
    var srcBlock = getInternalSlot(arrayBuffer, SLOTS.ARRAYBUFFERDATA);
    var result = OrdinaryConstruct(ArrayBufferConstructor, []);
    var setStatus = SetArrayBufferData(result, length);
    if (isAbrupt(setStatus)) return setStatus;
    var copyStatus = CopyDataBlockBytes(targetBlock, 0, srcBlock, 0, length);
    if (isAbrupt(copyStatus)) return copyStatus;
    return NormalCompletion(result);
}

// object.[[OnSuccessfulTransfer]](transferResult, targetRealm);
var OnSuccessfulTransfer_Call = function (thisArg, argList) {
    var transferResult = argList[0];
    var targetRealm = argList[1];
    var object = thisArg;
    if (hasInternalProperty(object, SLOTS.ARRAYBUFFERDATA)) {
        var neuteringResult = SetArrayBufferData(object, 0);
        if (isAbrupt(neuteringResult = ifAbrupt(neuteringResult))) return neuteringResult;
        setInternalSlot(object, "Transfer", "neutered");
    }
};


/* Missing: MessagePort and postMessage and open und close */

/*
 DataCloneError error object
 Indicates failure of the structured clone algorithm.
 {Rationale: typically, ECMAScript operations throw RangeError for similar failures, but we need to preserve DOM compatibnility}
 */

/**
 * Created by root on 04.04.14.
 */
/*
 Specification:
 https://github.com/dslomov-chromium/typed-objects-es7
 still have to read it
 */

var Nil = null;

    function TypeDescriptorExoticObject() {
        var obj = Object.create(TypeDescriptorExoticObject.prototype);
        setInternalSlot(obj, SLOTS.STRUCTURE, undefined); // structure value
        setInternalSlot(obj, SLOTS.RANK, undefined);    // int
        setInternalSlot(obj, SLOTS.OPACITY, undefined); // bool
        setInternalSlot(obj, SLOTS.ARRAYDESCRIPTOR, undefined); /// undef or typedesc
        setInternalSlot(obj, SLOTS.OPAQUEDESCRIPTOR, undefined); // undef or typedesc
        return obj;
    }

    TypeDescriptorExoticObject.prototype = {
        constructor: TypeDescriptorExoticObject,
        toString: function () { return "[object TypeDescriptorExoticObject]" }
    };
    addMissingProperties(TypeDescriptorExoticObject.prototype, OrdinaryObject.prototype);


    function TypeExoticObject() {
        var obj = Object.create(TypeExoticObject.prototype);
        setInternalSlot(obj, SLOTS.TYPEDESCRIPTOR, undefined);
        setInternalSlot(obj, SLOTS.DIMENSIONS, undefined);
        // assert len(dim) == rank of typedesc
        return obj;
    }

    TypeExoticObject.prototype = {
        constructor: TypeDescriptorExoticObject,
        toString: function () { return "[object TypeExoticObject]"; },

        Call: function (thisArg, argList) {
            var typeObject = thisArg;
            if (argList.length === 0) {
                if (isGroundType(typeObject)) {
                    var typeDescriptor = getInternalSlot(typeObject, SLOTS.TYPEDESCRIPTOR);
                    return Default(typeDescriptor);
                }
                return CreateTypedObject(typeObject);
            }
            var arg0 = argList[0];
            if (getInternalSlot(arg0, SLOTS.ARRAYBUFFERDATA)) {
                 var length = argList[1];
                 length = length || buffer.length;
                 if (isGroundType(typeObject)) return newTypeError( "object is a ground object");
                 return CreateTypedObjectFromBuffer(typedObject, buffer, length);

            } else if (arg0 != undefined) {
                 if (isGroundObject(typeObject)) return Coerce(typeObject, value);
                 else {
                     var o = CreateTypedObject(typeObject);
                     typeDescriptor =getInternalSlot(typeObject, SLOTS.TYPEDESCRIPTOR);
                     var dimensions = getInternalSlot(typeObject, SLOTS.DIMENSIONS);
                     var buffer = getInternalSlot(typeObject, SLOTS.VIEWEDARRAYBUFFER);
                     var offset = getInternalSlot(o, SLOTS.BYTEOFFSET);
                     ConvertAndCopyTo(typeDescriptor, dimensions, buffer, offset, value);
                 }
            }
        },

        GetOwnProperty: function (P) {
           var typeDescriptor = getInternalSlot(O, SLOTS.TYPEDESCRIPTOR);
           var dimensions = getInternalSlot(O, SLOTS.DIMENSIONS);
           var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
           var offset = getInternalSlot(O, SLOTS.BYTEOFFSET);
           if (dimensions === Nil) {
               var value = getInternalSlot(typeDescriptor, SLOTS.STRUCTURE);
               var r = FieldRecord(P);

           } else {

               Assert(dimensions === Cons(length, remainingDimensions), "dimensions has to be Cons(doms, remainingDimensions)");
               var isInteger;
               if (!IsAbrupt(ToInteger(P))) isInteger = true;
               if (!isInteger) return NormalCompletion(undefined);
               var i = ToInteger(P);
               var o = s * i + offset;
               var value = Reify(typeDescriptor, remainingDimensions, buffer,o);

           }
        },
        GetPrototypeOf: function () {
            var O = this;
            var typeDescriptor = getInternalSlot(O, SLOTS.TYPEDESCRIPTOR);
            return typeDescriptor;
        },
        IsExtensible: function () {
            return false;
        },
        Structure: function (O) {
            var typeDescriptor = getInternalSlot(O, SLOTS.TYPEDESCRIPTOR);
            return getInternalSlot(typeDescriptor, SLOTS.STRUCTURE);
        }

    };
    addMissingProperties(TypeExoticObject.prototype, OrdinaryObject.prototype);

/*
 Possibly subject of wrong impl.
 */

var int8 = "int8",
    uint8 = "uint8",
    int16 = "int16",
    uint16 = "uint16",
    uint32 = "uint32",
    int32 = "int32",
    float32 = "float32",
    float64 = "float64",
    any = "any",
    string = "string",
    object = "object";

var GroundStructures = {
        __proto__:null,
        "uint8": { "Structure": uint8, "Opacity": false },
        "int8": { "Structure": int8, "Opacity": false},
        "uint16": { "Structure": uint16, "Opacity": false},
        "int16": { "Structure": int16, "Opacity": false},
        "uint32": { "Structure": uint32, "Opacity": false},
        "int32": { "Structure": int32, "Opacity": false},
        "float32": { "Structure": float32, "Opacity": false},
        "float64": { "Structure": float64, "Opacity": false},
        "any": { "Structure": any, "Opacity": true},
        "string": { "Structure": string, "Opacity": true},
        "object": { "Structure": object, "Opacity": true}
    };


var groundTypes = Object.create(null);
groundTypes.int8 = int8;
groundTypes.uint8 = uint8;
groundTypes.int16 = int16;
groundTypes.uint16 = uint16;
groundTypes.int32 = int32;
groundTypes.uint32 = uint32;
groundTypes.float32 = float32;
groundTypes.float64 = float64;

function AlignTo(value, alignment) {
    var r = (value % alignment);
    if (r != 0) return value + alignment - r;
    return value;
}
function IsTypeObject(O) {
    if (Type(O) !== OBJECT) return false;
    if (!hasInternalSlot(O, SLOTS.TYPEDESCRIPTOR)) return false;
    return hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);

}

function isGroundStructure(S) {
    switch(S) {
        case int8:
        case int16:
        case uint8:
        case uint16:
        case uint32:
        case float32:
        case float64:
        return true;
        default:
        return false;
    }

}

function FieldRecord(fieldName, byteOffset, currentOffset, fieldType) {
    if (arguments.length === 2) {
        return { name: fieldName, type: byteOffset };
    } else {

    }
}

function Alignment(typeDescriptor) {
   var S = getInternalSlot(typeDescriptor, SLOTS.STRUCTURE);
   if (isGroundStructure(S)) return Size(S);
   else {

   }
   //fieldType values for each
    //Alignment(TypeDescriptor(t))

}
function Size(structure, dimensions) {
    if (arguments.length === 1) {
        //Size(structure)
        if (isGroundStructure(structure)) {

        }
    }
}
function OffsetOf(fieldRecords, name) {

}
function CreateStructTypeDescriptor(structure) {

}
function CreateArrayTypeDescriptor(typeDescriptor) {

}
function GetOrCreateArrayTypeDescriptor(typeDescriptor) {

}
function GetOrCreateOpaqueTypeDescriptor(typeDescriptor) {

}
function CreateTypedObjectFromBuffer(arrayBuffer, byteOffset, typeObject) {

}
function CreateTypedObject(typeObject) {
}
function Default(typeDescriptor) {
}
function Coerce(typeDescriptor, value) {

}
function Initialize(typeDescriptor, dimensions, buffer, offset) {

}
function ConvertAndCopyTo(typeDescriptor, dimensions, buffer, offset, value) {

}

function Reify(typeDescriptor, dimensions, buffer, offset, opacity) {

}

function Cons(car, cdr) {
   // wiki says from lisp: (cons 42 (cons 69 (cons 613 nil)))
}

function SameDimensions(d1, d2) {
    if (d1 === Nil && d2 === Nil) return true;
    // if (d1 = Cons(1, remainingDimensions1)
    // if (d2 = Cons(1, remainingDimensions2)
    // SameDimensions(remainingDimensions1, remainingDimensions2)
}



exports.Nil = Nil;
exports.TypeDescriptorExoticObject = TypeDescriptorExoticObject;
exports.TypeExoticObject = TypeExoticObject;
exports.IsTypeObject = IsTypeObject;
exports.FieldRecord = FieldRecord;
exports.Alignment = Alignment;
exports.Size = Size;
exports.OffsetOf = OffsetOf;
exports.CreateStructTypeDescriptor = CreateStructTypeDescriptor;
exports.CreateArrayTypeDescriptor = CreateArrayTypeDescriptor;
exports.GetOrCreateArrayTypeDescriptor = GetOrCreateArrayTypeDescriptor;
exports.GetOrCreateOpaqueTypeDescriptor = GetOrCreateOpaqueTypeDescriptor;
exports.CreateTypedObjectFromBuffer = CreateTypedObjectFromBuffer;
exports.CreateTypedObject = CreateTypedObject;
exports.Default = Default;
exports.Coerce = Coerce;
exports.Initialize = Initialize;
exports.ConvertAndCopyTo = ConvertAndCopyTo;
exports.Reify = Reify;
exports.Cons = Cons;
exports.SameDimensions = SameDimensions;
exports.GroundStructures = GroundStructures;
exports.isGroundStructure = isGroundStructure;
exports.groundTypes = groundTypes;
exports.int8 = int8;
exports.uint8 = uint8;
exports.int16 = int16;
exports.uint16 = uint16;
exports.int32 = int32;
exports.uint32 = uint32;
exports.float32 = float32;
exports.float64 = float64;



    var createGlobalThis, createIntrinsics;

    function define_intrinsic(intrinsics, intrinsicName, value) {
        var descriptor = {
            configurable: true,
            enumerable: true,
            value: value,
            writable: true
        };
        callInternalSlot(SLOTS.DEFINEOWNPROPERTY, intrinsics, intrinsicName, descriptor);
    }
    function createIntrinsicConstructor (intrinsics, name, len, intrinsicName) {
        var constructor = OrdinaryFunction();
        define_intrinsic(intrinsics, intrinsicName, constructor);
        SetFunctionName(constructor, name);
        SetFunctionLength(constructor, len);
        return constructor;
    }
    function createIntrinsicFunction (intrinsics, name, len, intrinsicName) {
        var func = OrdinaryFunction();
        define_intrinsic(intrinsics, intrinsicName, func);
        SetFunctionName(func, name);
        SetFunctionLength(func, len);
        setInternalSlot(func, SLOTS.CONSTRUCT, undefined);
        return func;
    }
    function createIntrinsicPrototype (intrinsics, intrinsicName) {
        var prototype = OrdinaryObject();
        define_intrinsic(intrinsics, intrinsicName, prototype);
        return prototype;
    }

    function createIntrinsicObject (intrinsics, intrinsicName) {
        var object = OrdinaryObject();
        define_intrinsic(intrinsics, intrinsicName, object);
        return object;
    }

    /*
     Here goes the big wrapping closure for createIntrinsics();    (tmp)
     */
    createIntrinsics = function createIntrinsics(realm) {

        var intrinsics = OrdinaryObject(null);
        realm.intrinsics = intrinsics;
        var ObjectPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.OBJECTPROTOTYPE);
        setInternalSlot(ObjectPrototype, SLOTS.PROTOTYPE, null);
        var FunctionPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.FUNCTIONPROTOTYPE);
        setInternalSlot(FunctionPrototype, SLOTS.PROTOTYPE, ObjectPrototype);
        var FunctionConstructor = createIntrinsicConstructor(intrinsics, "Function", 1, INTRINSICS.FUNCTION);

        setInternalSlot(FunctionConstructor, SLOTS.PROTOTYPE, FunctionPrototype);
        var ObjectConstructor = createIntrinsicConstructor(intrinsics, "Object", 0, INTRINSICS.OBJECT);

        Assert(getInternalSlot(ObjectConstructor, SLOTS.PROTOTYPE) === FunctionPrototype, "ObjectConstructor and FunctionPrototype have to have a link");

        var EncodeURIFunction = createIntrinsicFunction(intrinsics, "encodeURI", 1, INTRINSICS.ENCODEURI);
        var DecodeURIFunction = createIntrinsicFunction(intrinsics, "ecodeURI", 1, INTRINSICS.DECODEURI);
        var EncodeURIComponentFunction = createIntrinsicFunction(intrinsics, "encodeURIComponent", 1, INTRINSICS.ENCODEURICOMPONENT);
        var DecodeURIComponentFunction = createIntrinsicFunction(intrinsics, "decodeURIComponent", 1, INTRINSICS.DECODEURICOMPONENT);
        var SetTimeoutFunction = createIntrinsicFunction(intrinsics, "setTimeout", 2, INTRINSICS.SETTIMEOUT);
        var SetImmediateFunction = createIntrinsicFunction(intrinsics, "setImmediate", 1, INTRINSICS.SETIMMEDIATE);
        var IsNaNFunction = createIntrinsicFunction(intrinsics, "isNaN", 1, INTRINSICS.ISNAN);
        var IsFiniteFunction = createIntrinsicFunction(intrinsics, "isFinite", 1, INTRINSICS.ISFINITE);
        var ParseFloatFunction = createIntrinsicFunction(intrinsics, "parseFloat", 1, INTRINSICS.PARSEFLOAT);
        var ParseIntFunction = createIntrinsicFunction(intrinsics, "parseInt", 1, INTRINSICS.PARSEINT);
        var EscapeFunction = createIntrinsicFunction(intrinsics, "escape", 1, INTRINSICS.ESCAPE);
        var UnescapeFunction = createIntrinsicFunction(intrinsics, "unescape", 1, INTRINSICS.UNESCAPE);
        var EvalFunction = createIntrinsicFunction(intrinsics, "eval", 1, INTRINSICS.EVAL);
        var GeneratorFunction = createIntrinsicFunction(intrinsics, "Generator", 0, INTRINSICS.GENERATORFUNCTION);
        var LoadFunction = createIntrinsicFunction(intrinsics, "load", 1, INTRINSICS.LOAD);
        var RequestFunction = createIntrinsicFunction(intrinsics, "request", 0, INTRINSICS.REQUEST);
        var ModuleFunction = createIntrinsicFunction(intrinsics, "Module", 0, INTRINSICS.MODULE);
        var SymbolFunction = createIntrinsicFunction(intrinsics, "Symbol", 0, INTRINSICS.SYMBOL);
        var RegExpConstructor = createIntrinsicConstructor(intrinsics, "RegExp", 0, INTRINSICS.REGEXP);
        var RegExpPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.REGEXPPROTOTYPE);
        var ProxyConstructor = createIntrinsicConstructor(intrinsics, "Proxy", 0, INTRINSICS.PROXY);
        var ProxyPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.PROXYPROTOTYPE);
        var BooleanConstructor = createIntrinsicConstructor(intrinsics, "Boolean", 0, INTRINSICS.BOOLEAN);
        var BooleanPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.BOOLEANPROTOTYPE);
        var NumberConstructor = createIntrinsicConstructor(intrinsics, "Number", 0, INTRINSICS.NUMBER);
        var NumberPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.NUMBERPROTOTYPE);
        var StringConstructor = createIntrinsicConstructor(intrinsics, "String", 0, INTRINSICS.STRING);
        var StringPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.STRINGPROTOTYPE);
        var StringIteratorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.STRINGITERATORPROTOTYPE);
        var DateConstructor = createIntrinsicConstructor(intrinsics, "Date", 0, INTRINSICS.DATE);
        var DatePrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.DATEPROTOTYPE);
        var ErrorConstructor = createIntrinsicConstructor(intrinsics, "Error", 0, INTRINSICS.ERROR);
        var ErrorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.ERRORPROTOTYPE);
        var ArrayConstructor = createIntrinsicConstructor(intrinsics, "Array", 0, INTRINSICS.ARRAY);
        var ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.ARRAYPROTOTYPE);
        var ArrayIteratorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.ARRAYITERATORPROTOTYPE);

        var GeneratorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.GENERATORPROTOTYPE);
        var GeneratorObject = createIntrinsicObject(intrinsics, INTRINSICS.GENERATOR);
        var ReflectObject = createIntrinsicObject(intrinsics, INTRINSICS.REFLECT);
        var SymbolPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.SYMBOLPROTOTYPE);
        var TypeErrorConstructor = createIntrinsicConstructor(intrinsics, "TypeError", 0, INTRINSICS.TYPEERROR);
        var TypeErrorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.TYPEERRORPROTOTYPE);
        var ReferenceErrorConstructor = createIntrinsicConstructor(intrinsics, "ReferenceError", 0, INTRINSICS.REFERENCEERROR);
        var ReferenceErrorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.REFERENCEERRORPROTOTYPE);
        var SyntaxErrorConstructor = createIntrinsicConstructor(intrinsics, "SyntaxError", 0, INTRINSICS.SYNTAXERROR);
        var SyntaxErrorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.SYNTAXERRORPROTOTYPE);
        var RangeErrorConstructor = createIntrinsicConstructor(intrinsics, "RangeError", 0, INTRINSICS.RANGEERROR);
        var RangeErrorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.RANGEERRORPROTOTYPE);
        var EvalErrorConstructor = createIntrinsicConstructor(intrinsics, "EvalError", 0, INTRINSICS.EVALERROR);
        var EvalErrorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.EVALERRORPROTOTYPE);
        var URIErrorConstructor = createIntrinsicConstructor(intrinsics, "URIError", 0, INTRINSICS.URIERROR);
        var URIErrorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.URIERRORPROTOTYPE);
        var PromiseConstructor = createIntrinsicConstructor(intrinsics, "Promise", 1, INTRINSICS.PROMISE);
        var PromisePrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.PROMISEPROTOTYPE);
        var WeakMapConstructor = createIntrinsicConstructor(intrinsics, "WeakMap", 0, INTRINSICS.WEAKMAP);
        var WeakMapPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.WEAKMAPPROTOTYPE);
        var WeakSetConstructor = createIntrinsicConstructor(intrinsics, "WeakSet", 0, INTRINSICS.WEAKSET);
        var WeakSetPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.WEAKSETPROTOTYPE);
        var MapConstructor = createIntrinsicConstructor(intrinsics, "Map", 0, INTRINSICS.MAP);
        var MapPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.MAPPROTOTYPE);
        var MapIteratorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.MAPITERATORPROTOTYPE);
        var SetConstructor = createIntrinsicConstructor(intrinsics, "Set", 0, INTRINSICS.SET);
        var SetPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.SETPROTOTYPE);
        var SetIteratorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.SETITERATORPROTOTYPE);
        var TypedArrayConstructor = createIntrinsicConstructor(intrinsics, "TypedArray", 0, INTRINSICS.TYPEDARRAY);
        var TypedArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.TYPEDARRAYPROTOTYPE);
        var Uint8ArrayConstructor = createIntrinsicConstructor(intrinsics, "Uint8Array", 1, INTRINSICS.UINT8ARRAY);
        var Int8ArrayConstructor = createIntrinsicConstructor(intrinsics, "Int8Array", 1, INTRINSICS.INT8ARRAY);
        var Uint8ClampedArrayConstructor = createIntrinsicConstructor(intrinsics, "Uint8ClampedArray", 1, INTRINSICS.UINT8CLAMPEDARRAY);
        var Int16ArrayConstructor = createIntrinsicConstructor(intrinsics, "Int16Array", 1, INTRINSICS.INT16ARRAY);
        var Uint16ArrayConstructor = createIntrinsicConstructor(intrinsics, "Uint16Array", 1, INTRINSICS.UINT16ARRAY);
        var Int32ArrayConstructor = createIntrinsicConstructor(intrinsics, "Int32Array", 1, INTRINSICS.INT32ARRAY);
        var Uint32ArrayConstructor = createIntrinsicConstructor(intrinsics, "Uint32Array", 1, INTRINSICS.UINT32ARRAY);
        var Float32ArrayConstructor = createIntrinsicConstructor(intrinsics, "Float32Array", 1, INTRINSICS.FLOAT32ARRAY);
        var Float64ArrayConstructor = createIntrinsicConstructor(intrinsics, "Float64Array", 1, INTRINSICS.FLOAT64ARRAY);
        var Uint8ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.UINT8ARRAYPROTOTYPE);
        var Int8ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.INT8ARRAYPROTOTYPE);
        var Uint8ClampedArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.UINT8CLAMPEDARRAYPROTOTYPE);
        var Int16ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.INT16ARRAYPROTOTYPE);
        var Uint16ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.UINT16ARRAYPROTOTYPE);
        var Int32ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.INT32ARRAYPROTOTYPE);
        var Uint32ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.UINT32ARRAYPROTOTYPE);
        var Float32ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.FLOAT32ARRAYPROTOTYPE);
        var Float64ArrayPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.FLOAT64ARRAYPROTOTYPE);
        var ArrayBufferConstructor = createIntrinsicConstructor(intrinsics, "ArrayBuffer", 1, INTRINSICS.ARRAYBUFFER);
        var ArrayBufferPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.ARRAYBUFFERPROTOTYPE);
        var DataViewConstructor = createIntrinsicConstructor(intrinsics, "DataView", 1, INTRINSICS.DATAVIEW);
        var DataViewPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.DATAVIEWPROTOTYPE);
        var JSONObject = createIntrinsicObject(intrinsics, INTRINSICS.JSON);
        var MathObject = createIntrinsicObject(intrinsics, INTRINSICS.MATH);
        var ConsoleObject = createIntrinsicObject(intrinsics, INTRINSICS.CONSOLE);
	// ---
        var EmitterConstructor = createIntrinsicConstructor(intrinsics, "Emitter", 0, INTRINSICS.EMITTER);
        var EmitterPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.EMITTERPROTOTYPE);
        // Object.observe
        var NotifierPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.NOTIFIERPROTOTYPE);
        var ObserverCallbacks = [];
        var LoaderConstructor = createIntrinsicConstructor(intrinsics, "Loader", 0, INTRINSICS.LOADER);
        var LoaderPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.LOADERPROTOTYPE);
        var LoaderIteratorPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.LOADERITERATORPROTOTYPE);
        var RealmConstructor = createIntrinsicConstructor(intrinsics, "Realm", 0, INTRINSICS.REALM);
        var RealmPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.REALMPROTOTYPE);
        var ModulePrototype = null;
        // that is something from the dom, which is useful for communication and its messaging needs structured cloning so i can check out both
        var EventConstructor = createIntrinsicConstructor(intrinsics, "Event", 0, INTRINSICS.EVENT);
        var EventPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.EVENTPROTOTYPE);
        var EventTargetConstructor = createIntrinsicConstructor(intrinsics, "EventTarget", 0, INTRINSICS.EVENTTARGET);
        var EventTargetPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.EVENTTARGETPROTOTYPE);
        var MessagePortConstructor = createIntrinsicConstructor(intrinsics, "MessagePort", 0, INTRINSICS.MESSAGEPORT);
        var MessagePortPrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.MESSAGEPORTPROTOTYPE);
	// EventTarget and MessagePort are just stubs yet.
        var DebugFunction = createIntrinsicFunction(intrinsics, "debug", 1, INTRINSICS.DEBUGFUNCTION);
        var PrintFunction = createIntrinsicFunction(intrinsics, "print", 1, INTRINSICS.PRINTFUNCTION);
        var StructTypeConstructor = createIntrinsicConstructor(intrinsics, "StructType", 0, INTRINSICS.STRUCTTYPE);
        var StructTypePrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.STRUCTTYPEPROTOTYPE);
        var TypeConstructor = createIntrinsicConstructor(intrinsics, "Type", 0, INTRINSICS.TYPE);
        var TypePrototype = createIntrinsicPrototype(intrinsics, INTRINSICS.TYPEPROTOTYPE);
        var ThrowTypeError = createIntrinsicFunction(intrinsics, "ThrowTypeError", 0, INTRINSICS.THROWTYPEERROR);
        var ArrayProto_values = createIntrinsicFunction(intrinsics, "values", 0, INTRINSICS.ARRAYPROTO_VALUES);
        
        var VMObject = createIntrinsicObject(intrinsics,INTRINSICS.VM); // that i can play with from inside the shell, too.
                
        var ThrowTypeError_Call = function (thisArg, argList) {
            return newTypeError(format("THROW_TYPE_ERROR"));
        };
        setInternalSlot(ThrowTypeError, SLOTS.CALL, ThrowTypeError_Call);
        setInternalSlot(ThrowTypeError, SLOTS.CONSTRUCT, undefined);

        var SetLanguage_Call = function (thisArg, argList) {
                try {var languages = require("i18n").languages;}
                catch (ex) {return newTypeError(ex.message);}
                if (argList.length === 0) {
                    var status = callInternalSlot(SLOTS.CALL, PrintFunction, undefined, [format("AVAILABLE_LANGUAGES")])
                    if (isAbrupt(status)) return status;
                    for (var lang in languages) {
                        if (objectHasOwnProperty(languages, lang)) {
                            status = callInternalSlot(SLOTS.CALL, PrintFunction, undefined, [lang]);
                            if (isAbrupt(status)) return status;
                        }
                    }
                    return NormalCompletion(undefined);
                }
                var lang = ToString(argList[0]);
                if (isAbrupt(lang=ifAbrupt(lang))) return lang;
                try {require("i18n").setLang(lang);}
                catch (ex) {return newTypeError(ex.message);}
                return NormalCompletion(undefined);
        };
        var SetLanguage = createIntrinsicFunction(intrinsics, "setLanguage", 1, INTRINSICS.SETLANGUAGE)
        setInternalSlot(SetLanguage, SLOTS.CALL, SetLanguage_Call);
        setInternalSlot(SetLanguage, SLOTS.CONSTRUCT, undefined);

        // maybe it´s best on: Reflect.
        // but i get strange feelings to wish to implement the intl api together with es6 and asm.js


    /*
	These include files include the builtin library
	
	refactoring decision: the xxxConstructor_fname and xxxPrototype_fname
	[[Call]] Operations of the Builtins have to move into the upper block
	together with a few helper functions, e.g. when writing the loader in
	january i had put the operations all together.
	The [[Call]] and the helpers belong into the include file list above.
	Here they waste time instantiating the realms, because the (never modified)
	[[Call]] Operations are newly compiled instantiated each time a realm is 
	made. I guess it, but i guess also i am right, that moving them up will
	save some instantiation costs, coz all realms then share the [[Call]] operations,
	which solve the invariant, that no realm ever touches them, the properties are
	set on the xxxPrototype and xxxConstructor functions, which of course are
	created new. So far for my library refactoring plans. The other piece is to
	replace the DefineOwnProperty(...  { value: CreateBuiltinFunction(...)  }) with
	LazyDefineBuiltinFunction to remove the repeating property descriptors. For
	that i wanted to write a tool, refactorDOP.js in /tools, some day. Apropos
	/tools the important files are testmaker.js, tester.js, inlinefiles.js
	
    */

setInternalSlot(PrintFunction, SLOTS.CALL, function (thisArg, argList) {
   var str = "";
   var j = argList.length-1;
   if (j === 0) str = argList[0];
   else {
       for (var i = 0; i < j; i++) {
           str += argList[i] + " ";
       }
       str += argList[j];
   }
   if (hasConsole) console.log(str);
   else if (hasPrint) print(str);
   return NormalCompletion(undefined);
});

/**
 *
 * debug(val) is some util.inspect() with now just less styling
 *
 *
 */


setInternalSlot(DebugFunction, SLOTS.CALL, function debugfunc (thisArg, argList)  {

    var TAB = "\t";
    var O = argList[0];
    var type = Type(O);

    console.log("Type() results in " + type);

    function printProps(name) {
        var desc = this[name];
        console.log(TAB+TAB+name+": ("+Type(desc.value)+") "+(desc.enumerable?"e":"-")+""+(desc.configurable?"c":"-")+""+(desc.writable?"w":"-"));
    }

    if (type == OBJECT) {

        var isCallable = IsCallable(O);

        if (!isCallable)  {
            var toString = Invoke(O, "toString", []);
            if (isAbrupt(toString=ifAbrupt(toString))) return toString;
        } else {
            var funcName = Get(O, "name");
            console.log("[object Function]: "+funcName);
        }
        console.log(toString);
        console.log("{");

        var bindings = getInternalSlot(O, SLOTS.BINDINGS);
        var symbols = getInternalSlot(O, SLOTS.SYMBOLS);
        var isExtensible = getInternalSlot(O, SLOTS.EXTENSIBLE);
        var proto = GetPrototypeOf(O);
        var prototypeInfo;

        if (proto == null) prototypeInfo = "null";
        else prototypeInfo = Invoke(proto, "toString", []);
        if (isAbrupt(prototypeInfo=ifAbrupt(prototypeInfo))) return prototypeInfo;

        console.log(TAB+"[[Prototype]]: " + prototypeInfo);
        console.log(TAB+"[[Extensible]]: " +isExtensible);

        console.log(TAB+"[[Bindings]]:");
        var printer = printProps.bind(bindings);
        Object.keys(bindings).forEach(printer);
        
        console.log(TAB+"[[Symbols]]:");
        printer = printProps.bind(symbols);
        Object.keys(symbols).forEach(printer);

        if (IsCallable(O)) {
            var strict = getInternalSlot(O, SLOTS.STRICT);
            console.log(TAB+"[[Strict]]:" + strict);

            var thisMode = getInternalSlot(O, SLOTS.THISMODE);
            console.log(TAB+"[[ThisMode]]: "+thisMode);

            var formals = getInternalSlot(O, SLOTS.FORMALPARAMETERS);
            console.log(TAB+"[[FormalParameters]]:");
            console.log(formals.join(","));

            console.log(TAB+"[[Code]]:");

            var code = getInternalSlot(O, SLOTS.CODE);
            console.log(JSON.stringify(code, null, 4));
        }

        console.log("}");

        return NormalCompletion();
    }

    if (type == NUMBER) {
        console.log("Number");
        console.log("binary (base 2): "+O.toString(2));
        console.log("decimal (base 10): "+O.toString(10));
        console.log("hex (base 16): "+O.toString(16));

    } else if (type == STRING) {
        var len = O.length;
        console.log("String");
        console.log("value: "+O);
        console.log("length: "+len);

    } else if (type == SYMBOL) {
        console.log("Symbol");
        var descr = getInternalSlot(O, SLOTS.DESCRIPTION);
        console.log("[[Description]]: " +descr);
    } else if (type == BOOLEAN) {
        console.log("Boolean");
        console.log("value: "+!!O);
    } else if (type === NULL) {
        console.log("it´s null");
    } else if (type === UNDEFINED) {
        console.log("it´s undefined");
    }
    return NormalCompletion();
});
/**
 *
 *  load(file);
 *
 *
 */
var loaderAdapter = require("filesystem").makeAdapter({
    test: {
        "node": typeof process === "object" && typeof window === "undefined",
        "browser": typeof window === "object" && typeof XMLHttpRequest === "function",
        "worker": typeof window == "undefined" && typeof importScripts === "function" && typeof XMLHttpRequest === "function",
        "sm": typeof load === "function" && typeof print === "function"
    },
    work: (function () {
        function xmlHTTPrequest(file) {
            var xhr;
            try {
                xhr = new XMLHttpRequest();
                xhr.open("GET", file, false);
                xhr.send(null);
                return xhr.responseText;
            } catch (ex) {
                return newTypeError( "can not xml http request " + file);
            }
        }

        return {
            "node": function (file) {
                var data;
                var fs = module.require("fs");
                try {
                    data = fs.readFileSync(file, "utf8");
                } catch (ex) {
                    return newTypeError( "fs.readFileSync threw a "+ex.name+" exception "+ ex.message+"\n"+ (ex.stack&&ex.stack.toString()));
                }
                return data;
            },
            "browser": xmlHTTPrequest,
            "worker": xmlHTTPrequest,
            "sm": function (file) {
                return load(file)
            }
        };
    }())
});

setInternalSlot(LoadFunction, SLOTS.CALL, function load(thisArg, argList) {
    var file = argList[0];
    try {
        var data = loaderAdapter(file);
    } catch (ex) {
        return newTypeError( "loaderAdaper fails with a " + ex.name + ": " + ex.message + "\n" + ex.stack)
    }
    return data;
});

/**
 *
 * request
 *
 *
 *
 *
 */

    setInternalSlot(RequestFunction, SLOTS.CALL, function request(thisArg, argList) {
        var url = argList[0];
        var d, p;


        if (isWindow) {

            var handler = CreateBuiltinFunction(realm, function handler(thisArg, argList) {
                var resolve = argList[0];
                var reject = argList[1];
            });

            d = OrdinaryConstruct(PromiseConstructor, [handler]);

            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.onload = function (e) {
                if (xhr.status !== 200 || xhr.status === 301) {}
            };

            xhr.send();

            return xhr.responseText;

        } else if (isNode) {

        } else if (isWorker) {

        } else {
            return newTypeError( "Unknown architecture. Request function not available.");
        }
    });


var RealmPrototype_get_global = function (thisArg, argList) {
    var RealmConstructor = thisArg;
    if (Type(RealmConstructor) !== OBJECT || !hasInternalSlot(RealmConstructor, SLOTS.REALM)) return newTypeError(format("S_HAS_NO_S", "thisValue", "[[Realm]]"));
    var realm = getInternalSlot(RealmConstructor, SLOTS.REALM);
    var globalThis = realm.globalThis;
    return globalThis;
};

var RealmPrototype_eval = function (thisArg, argList) {
    var source = argList[0];
    var RealmConstructor = thisArg;
    if (Type(RealmConstructor) !== OBJECT || !hasInternalSlot(RealmConstructor, SLOTS.REALM)) return newTypeError(format("S_HAS_NO_S", "thisValue", "[[Realm]]"));
    return IndirectEval(getInternalSlot(RealmConstructor, SLOTS.REALM), source);
};

var RealmConstructor_Call = function (thisArg, argList) {
    var RealmConstructor = thisArg;
    var options = argList[0];
    var initializer = argList[1];
    if (Type(RealmConstructor) !== OBJECT) return newTypeError(format("S_NOT_OBJECT", "thisValue"));
    if (!hasInternalSlot(RealmConstructor, SLOTS.REALM)) return newTypeError(format("S_NOT_COMPLETE", "thisValue"));
    if (getInternalSlot(RealmConstructor, SLOTS.REALM) !== undefined) return newTypeError(format("S_NOT_UNDEFINED", "[[Realm]]"));
    if (options === undefined) options = ObjectCreate(null);
    else if (Type(options) !== OBJECT) return newTypeError(format("S_NOT_OBJECT", "options"));
    var realm = CreateRealm();
    var evalHooks = Get(options, "eval");
    if (isAbrupt(evalHooks = ifAbrupt(evalHooks))) return evalHooks;
    if (evalHooks === undefined) evalHooks = ObjectCreate();
    var directEval = Get(evalHooks, "directEval");
    if (isAbrupt(directEval = ifAbrupt(directEval))) return directEval;
    if (directEval === undefined) directEval = ObjectCreate();
    else if (Type(directEval) !== OBJECT) return newTypeError(format("S_NOT_OBJECT", "directEval"));
    var translate = Get(directEval, "translate");
    if (isAbrupt(translate = ifAbrupt(translate))) return translate;
    if ((translate !== undefined) && !IsCallable(translate)) return newTypeError(format("S_NOT_CALLABLE", "translate"));
    setInternalSlot(realm, "translateDirectEvalHook", translate);
    var fallback = Get(directEval, "fallback");
    if (isAbrupt(fallback = ifAbrupt(fallback))) return fallback;
    setInternalSlot(realm, "fallbackDirectEvalHook", fallback);
    var indirectEval = Get(options, "indirect");
    if (isAbrupt(indirectEval = ifAbrupt(indirectEval))) return indirectEval;
    if ((indirectEval !== undefined) && !IsCallable(indirectEval)) return newTypeError(format("S_NOT_CALLABLE", "indirectEval"));
    setInternalSlot(realm, "indirectEvalHook", indirectEval);
    var Function = Get(options, "Function");
    if (isAbrupt(Function = ifAbrupt(Function))) return Function;
    if ((Function !== undefined) && !IsCallable(Function)) return newTypeError(format("S_NOT_CALLABLE", "Function"));
    setInternalSlot(realm, "FunctionHook", Function);
    setInternalSlot(RealmConstructor, SLOTS.REALM, realm);

    realm.directEvalTranslate = translate;
    realm.directEvalFallback = fallback;
    realm.indirectEval = indirectEval;
    realm.Function = Function;

    if (initializer !== undefined) {
        if (!IsCallable(initializer)) return newTypeError(format("S_NOT_CALLABLE", "initializer"));
        var builtins = ObjectCreate();
        DefineBuiltinProperties(realm, builtins);
        var status = callInternalSlot(SLOTS.CALL, initializer, RealmConstructor, [builtins]);
        if (isAbrupt(status)) return status;
    }
    return RealmConstructor;
};

var RealmConstructor_Construct = function (argList) {
    var F = this;
    var args = argList;
    return Construct(F, argList);
};

var RealmConstructor_$$create = function (thisArg, argList) {
    return OrdinaryCreateFromConstructor(thisArg, INTRINSICS.REALMPROTOTYPE, [
        SLOTS.REALM
    ]);
};


var RealmPrototype_stdlib_get = function (thisArg, argList) {
    var RealmConstructor = thisArg;
    var source = argList[0];
    if (Type(RealmConstructor) !== OBJECT || !hasInternalSlot(RealmConstructor, SLOTS.REALM)) return newTypeError("S_HAS_NO_S", "thisValue", "[[Realm]]");    var realm = getInternalSlot(RealmConstructor, SLOTS.REALM);
    if (realm === undefined) return newTypeError(format("S_IS_UNDEFINED", "[[Realm]]"));
    var props = ObjectCreate(getIntrinsic(INTRINSICS.OBJECTPROTOTYPE));
    var bindings = getInternalSlot(getGlobalThis(), SLOTS.BINDINGS);
    var symbols = getInternalSlot(getGlobalThis(), SLOTS.SYMBOLS);
    function forEachProperty(props, bindings) {
        for (var P in bindings) {
            var desc = bindings[P];
            var newDesc = {
                value: desc.value,
                enumerable: desc.enumerable,
                configurable: desc.configurable,
                writable: desc.writable
            };
            var status = DefineOwnPropertyOrThrow(props, P, newDesc);
            if (isAbrupt(status)) return status;
        }
    }
    forEachProperty(props, bindings);
    forEachProperty(props, symbols);

};
var RealmPrototype_intrinsics = function (thisArg, argList) {
};
var RealmPrototype_initGlobal = function (thisArg, argList) {
};
var RealmPrototype_directEval = function (thisArg, argList) {
};
var RealmPrototype_indirectEval = function (thisArg, argList) {
    var RealmConstructor = thisArg;
    var source = argList[0];
    if (Type(RealmConstructor) !== OBJECT || !hasInternalSlot(RealmConstructor, SLOTS.REALM)) return newTypeError(format("S_HAS_NO_S", "thisValue", "[[Realm]]"));
    var realm = getInternalSlot(RealmConstructor, SLOTS.REALM);
    if (realm === undefined) return newTypeError(format("S_IS_UNDEFINED", "[[Realm]]"));
    return IndirectEval(realm, source);
};


// %Realm%
setInternalSlot(RealmConstructor, SLOTS.CALL, RealmConstructor_Call);
setInternalSlot(RealmConstructor, SLOTS.CONSTRUCT, RealmConstructor_Construct);
LazyDefineProperty(RealmConstructor, $$create, CreateBuiltinFunction(realm,RealmConstructor_$$create, 0, "[Symbol.create]"));
MakeConstructor(RealmConstructor, false, RealmPrototype);


LazyDefineBuiltinFunction(RealmPrototype, "intrinsics", 2, RealmPrototype_intrinsics);
LazyDefineBuiltinFunction(RealmPrototype, "indirectEval", 2, RealmPrototype_indirectEval);
LazyDefineBuiltinFunction(RealmPrototype, "initGlobal", 2, RealmPrototype_initGlobal);
LazyDefineAccessorFunction(RealmPrototype, "stdlib", 3, RealmPrototype_stdlib_get);

// %RealmPrototype%
LazyDefineAccessor(RealmPrototype, "global", CreateBuiltinFunction(realm,RealmPrototype_get_global, 0, "get global"));
LazyDefineProperty(RealmPrototype, "eval", CreateBuiltinFunction(realm,RealmPrototype_eval, 1, "eval"));
LazyDefineProperty(RealmPrototype, $$toStringTag, "Reflect.Realm");


/**
 * a simplification to search through a list (in our case a js array)
 * and look at the current item.
 *
 * @param list
 * @param field
 * @param value
 * @returns {boolean}
 */
function hasRecordInList(list, field, value) {
    if (!list) return false;
    for (var i = 0, j = list.length; i < j; i++) {
        var r = list[i];
        if (r[field] === value) return true;
    }
    return false;
}

function getRecordFromList(list, field, value) {
    if (!list) return false;
    for (var i = 0, j = list.length; i < j; i++) {
        var r = list[i];
        if (r[field] === value) return r;
    }
    return undefined;
}


function thisLoader(value) {
    if (value instanceof CompletionRecord) return thisLoader(value.value);
    var m;
    if (Type(value) === OBJECT && (m=getInternalSlot(value, SLOTS.LOADERRECORD))) {
        if (m !== undefined) return value;
    }
    return newTypeError( "thisLoader(value): value is not a valid loader object");
}


//
// Runtime Semantics
// Loader State
//

// 27.1. add
function LoaderRecord () {
    var lr = Object.create(LoaderRecord.prototype);
    lr.Realm = undefined;
    lr.Modules = undefined; // record { Name, Module }
    lr.Loads = undefined;   // outstanding async requests
    lr.Loader = undefined;  // the loader obj
    return lr;
}
LoaderRecord.prototype.toString = function () { return "[object LoaderRecord]"; };

// 27.1.
function CreateLoaderRecord(realm, object) {
    var loader = LoaderRecord();
    loader.Realm = realm;
    loader.Modules = [];
    loader.Loads = [];
    loader.LoaderObj = object;
    return loader;
}

function LoadRecord() {
    var lr = Object.create(LoadRecord.prototype);
    lr.Status = undefined;
    lr.Name = undefined;
    lr.LinkSets = undefined;
    lr.Metadata = undefined;
    lr.Address = undefined;
    lr.Source = undefined;
    lr.Kind = undefined;
    lr.Body = undefined;
    lr.Execute = undefined;
    lr.Exception = undefined;
    lr.Module = undefined;
    lr.constructor = LoadRecord;
    return lr;
}
LoadRecord.prototype.toString = function () { return "[object LoadRecord]"; };

// 27.1. check
function CreateLoad(name) {
    var load = LoadRecord();
    var metadata = ObjectCreate();
    load.Status = "loading";
    load.Name = name;
    load.LinkSets = [];
    load.Metadata = metadata;
    // all other fields are exisiting but undefined.
    return load;
}

// 27.1.
function CreateLoadRequestObject(name, metadata, address, source) {
    var obj = ObjectCreate();
    var status, errmsg = "CreateLoadRequest: CreateDataProperty must not fail";
    status = CreateDataProperty(obj, "name", name);
    Assert(!isAbrupt(status), errmsg+ " - 1");
    status = CreateDataProperty(obj, "metadata", metadata);
    Assert(!isAbrupt(status), errmsg+ " - 2");
    if (address !== undefined) {
        status = CreateDataProperty(obj, "address", address);
        Assert(!isAbrupt(status), errmsg+ " - 3");
    }
    if (source !== undefined) {
        status = CreateDataProperty(obj, "source", source);
        Assert(!isAbrupt(status), errmsg + " - 4");
    }
    return obj;
}

// 27.1. updated
function LoadModule(loader, name, options) {
    ////debug2("loadmodule");
    if (!options) options = ObjectCreate();
    name = ToString(name);
    if (isAbrupt(name = ifAbrupt(name))) return name;
    var address = GetOption(options, "address");
    if (isAbrupt(address = ifAbrupt(address))) return address;
    var step;
    if (address === undefined) step = "locate";
    else step = "fetch";
    var metadata = ObjectCreate();
    var source;
    return PromiseOfStartLoadPartWayThrough(step, loader, name, metadata, source, address);
}

// 27.1. update
function RequestLoad(loader, request, refererName, refererAddress) {
    var F = CallNormalize();
    setInternalSlot(F, SLOTS.LOADER, loader);
    setInternalSlot(F, SLOTS.REQUEST, request);
    setInternalSlot(F, SLOTS.REFERERNAME, refererName);
    setInternalSlot(F, SLOTS.REFERERADDRESS, refererAddress);
    var p = PromiseNew(F);
    var G = GetOrCreateLoad();
    setInternalSlot(G, SLOTS.LOADER, loader);
    p = PromiseThen(p, G);
    return p;
}


// neu 27.1.
function CallNormalize() {
    var F = OrdinaryFunction();
    var CallNormalizeFunction_Call = function (thisArg, argList) {
        var resolve = argList[0];
        var reject = argList[1];
        var loader = getInternalSlot(F, SLOTS.LOADER);
        var request = getInternalSlot(F, SLOTS.REQUEST);
        var refererName = getInternalSlot(F, SLOTS.REFERERNAME);
        var refererAddress = getInternalSlot(F, SLOTS.REFERERADDRESS);
        var loaderObj = loader.LoaderObj;
        var normalizeHook = Get(loaderObj, "normalize");
        var name = callInternalSlot(SLOTS.CALL, normalizeHook, loaderObj, [request, refererName, refererAddress]);
        if (isAbrupt(name = ifAbrupt(name))) return name;
        return callInternalSlot(SLOTS.CALL, resolve, undefined, [name]);
    };
    setInternalSlot(F, SLOTS.CALL, CallNormalizeFunction_Call);
    return F;
}

// neu 27.1.
function GetOrCreateLoad() {
    var F = OrdinaryFunction();
    var GetOrCreateLoad_Call = function (thisArg, argList) {
        var name = argList[0];
        var loader = getInternalSlot(F, SLOTS.LOADER);
        name = ToString(name);
        if (isAbrupt(name = ifAbrupt(name))) return name;
        var modules = loaderRecord.Modules;
        for (var i = 0, j = modules.length; i < j; i++) {
            var p = modules[i];
            if (SameValue(p.key, name)) {
                var existingModule = p.value;
                load = CreateLoad(name);
                load.Status = "linked";
                load.Module = existingModule;
                return NormalCompletion(load);
            }
        }
        for (i = 0, j = loader.Loads.length; i < j; i++) {
            if (SameValue(load.Name, name)) {
                Assert(load.Status === "loading" || load.Status === "loaded", "load.Status has to be loading or loaded");
                return NormalCompletion(load);
            }
        }
        var load = CreateLoad(name);
        loader.Loads.push(load);
        ProceedToLocate(loader, load);
        return NormalCompletion(load);
    };
    setInternalSlot(F, SLOTS.CALL, GetOrCreateLoad_Call);
    return F;
}

// 27.1. update
function ProceedToLocate(loader, load, p) {
    p = PromiseOf(undefined);
    var F = CallLocate();
    setInternalSlot(F, SLOTS.LOADER, loader);
    setInternalSlot(F, "Load", load);
    p = PromiseThen(p, F);
    return ProceedToFetch(loader, load, p);
}

// 27.1. update
function CallLocate() {
    var F = OrdinaryFunction();
    var CallLocate_Call = function (thisArg, argList) {
        var F = this;
        var loader = getInternalSlot(F, SLOTS.LOADER);
        var load = getInternalSlot(F, "Load");
        var loaderObj = loader.LoaderObj;
        var hook = Get(loaderObj, "locate");
        if (isAbrupt(hook = ifAbrupt(hook))) return hook;
        if (!IsCallable(hook)) return newTypeError( "call locate hook is not callable");
        var obj = CreateLoadRequestObject(load.Name, load.Metadata);
        return callInternalSlot(SLOTS.CALL, hook, loader, [obj])
    };
    setInternalSlot(F, SLOTS.CALL, CallLocate_Call);
    return F;
}

// 27.1.
function ProceedToFetch(loader, load, p) {
    var F = CallFetch();
    setInternalSlot(F, SLOTS.LOADER, loader);
    setInternalSlot(F, "Load", load);
    setInternalSlot(F, "AddressPromise", p);
    p = PromiseThen(p, F);
    return ProceedToTranslate(loader, load, p);
}

// 27.1.
function CallFetch() {
    var F = OrdinaryFunction();
    var CallFetch_Call = function (thisArg, argList) {
        var F = this;
        var address = argList[0];
        var loader = getInternalSlot(F, SLOTS.LOADER);
        var load = getInternalSlot(F, "Load");
        if (load.LinkSets.length === 0) return NormalCompletion(undefined);
        load.Address = address;
        var loaderObj = loader.LoaderObj;
        var hook = Get(loaderObj, "fetch");
        if (isAbrupt(hook = ifAbrupt(hook))) return hook;
        if (!IsCallable(hook)) return newTypeError( "fetch hook is not a function");
        var obj = CreateLoadRequestObject(load.Name, load.Metadata, address);
        return callInternalSlot(SLOTS.CALL, hook, loader, [obj]);
    };
    setInternalSlot(F, SLOTS.CALL, CallFetch_Call);
    return F;
}

// 27.1.
function ProceedToTranslate(loader, load, p) {
    var F = CallTranslate();
    setInternalSlot(F, SLOTS.LOADER, loader);
    setInternalSlot(F, "Load", load);
    p = PromiseThen(p, F);
    F = CallInstantiate();
    setInternalSlot(F, SLOTS.LOADER, loader);
    setInternalSlot(F, "Load", load);
    p = PromiseThen(p, F);
    F = InstantiateSucceeded();
    setInternalSlot(F, SLOTS.LOADER, loader);
    setInternalSlot(F, "Load", load);
    p = PromiseThen(p, F);
    F = LoadFailed();
    setInternalSlot(F, "Load", load);
    return PromiseCatch(p, F);
}

// 27.1.
function CallTranslate() {
    var F = OrdinaryFunction();
    var CallTranslate_Call = function (thisArg, argList) {
        var F = this;
        var source = argList[0];
        var loader = getInternalSlot(F, SLOTS.LOADER);
        var load = getInternalSlot(F, "Load");
        if (load.LinkSets.length === 0) return NormalCompletion(undefined);
        var hook = Get(loader, "translate");
        if (isAbrupt(hook = ifAbrupt(hook))) return hook;
        if (!IsCallable(hook)) return newTypeError( "call translate hook is not callable");
        var obj = CreateLoadRequestObject(load.Name, load.Metadata, load.Address, source);
        return callInternalSlot(SLOTS.CALL, hook, loader, [obj]);
    };
    setInternalSlot(F, SLOTS.CALL, CallTranslate_Call);
    return F;
}


// 27.1.
function CallInstantiate() {
    var F = OrdinaryFunction();
    var CallInstantiate_Call = function (thisArg, argList) {
        var F = this;
        var source = argList[0];
        var loader = getInternalSlot(F, SLOTS.LOADER);
        var load = getInternalSlot(F, "Load");
        if (loader.LinkSets.length === 0) return NormalCompletion(undefined);
        var hook = Get(loader, "instantiate");
        if (isAbrupt(hook = ifAbrupt(hook))) return hook;
        if (!IsCallable(hook)) return newTypeError( "call instantiate hook is not callable");
        var obj = CreateLoadRequestObject(load.Name, load.Metadata, load.Address, source);
        return callInternalSlot(SLOTS.CALL, hook, loader, [obj]);
    };
    setInternalSlot(F, SLOTS.CALL, CallInstantiate_Call);
    return F;
}

// 27.1.
function InstantiateSucceeded() {
    var F = OrdinaryFunction();
    var InstantiateSucceeded_Call = function (thisArg, argList) {
        var instantiateResult = argList[0];
        var loader = getInternalSlot(F, SLOTS.LOADER);
        var load = getInternalSlot(F, "Load");
        if (load.LinkSets.length === 0) return NormalCompletion(undefined);
        if (instantiateResult === undefined) {
            try {
                var body = parseGoal("Module", load.Source);
            } catch (ex) {
                return newSyntaxError( ex.message);
            }
            load.Body = body;
            load.Kind = "declarative";
            var depsList = ModuleRequests(body);
        } else if (Type(instantiateResult) === OBJECT) {
            var deps = Get(instantiateResult, "deps");
            if (isAbrupt(deps = ifAbrupt(deps))) return deps;
            if (deps === undefined) depsList = [];
            else {
                depsList = IterableToList(deps); // IterableToArray?
                if (isAbrupt(depsList = ifAbrupt(depsList))) return depsList;
            }
            var execute = Get(instantiateResult, "execute");
            if (isAbrupt(execute = ifAbrupt(execute))) return execute;
            load.Execute = execute;
            load.Kind = "dynamic";
        } else {
            return newTypeError( "instantiateResult error");
        }
        return ProcessLoadDependencies(load, loader, depsList);
    };
    setInternalSlot(F, SLOTS.CALL, InstantiateSucceeded_Call);
    return F;
}

// 27.1.
function LoadFailed() {
    var LoadFailedFunction_Call = function (thisArg, argList) {
        var exc = argList[0];
        var F = this;
        var load = getInternalSlot(this, SLOTS.LOAD);
        Assert(load.Status === "loading", "load.[[Status]] has to be loading at this point");
        load.Status = "failed";
        load.Exception = exc;
        var linkSets = load.LinkSets;
        for (var i = 0, j = linkSets.length; i < j; i++) {
            LinkSetFailed(linkSets[i], exc);
        }
        Assert(load.LinkSets.length === 0, "load.[[LinkSets]] has to be empty at this point");
    };
    var F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.CALL, LoadFailedFunction_Call);
    return F;
}

// 27.1.
function ProcessLoadDependencies(load, loader, depsList) {
    var refererName = load.Name;
    load.Dependencies = [];
    var loadPromises = [];
    for (var i = 0, j = depsList.length; i < j; i++) {
        var request = depsList[i];
        var p = RequestLoad(loader, request, refererName, load.Address);
        var F = AddDependencyLoad();
        setInternalSlot(F, SLOTS.LOAD, load);
        setInternalSlot(F, SLOTS.REQUEST, request);
        p = PromiseThen(p, F);
        loadPromises.push(p);
    }
    p = PromiseAll(loadPromises);
    F = LoadSucceeded();
    setInternalSlot(F, SLOTS.LOAD, load);
    return PromiseThen(p, F);
}

// 27.1.
function AddDependencyLoad() {
    var AddDependencyLoad_Call = function (thisArg, argList) {
        var depLoad = argList[0];
        var parentLoad = getInternalSlot(F, "ParentLoad");
        var request = getInternalSlot(F, SLOTS.REQUEST);
        Assert(!hasRecordInList(parentLoad.Dependencies, "Key", request), "there must be no record in parentLoad.Dependencies with key equal to request ");
        parentLoad.Dependences.push({Key: request, Value: depLoad.Name });
        if (depLoad.Status !== "linked") {
            var linkSets = parentLoad.LinkSets;
            for (var i = 0, j = linkSets.length; i < j; i++) {
                AddLoadToLinkSet(linkSets[i], depLoad);
            }
        }
        return NormalCompletion(undefined);
    };
    var F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.CALL, AddDependencyLoad_Call);
    return F;
}

// 27.1.
function LoadSucceeded() {
    var LoadSucceeded_Call = function (thisArg, argList) {
        var load = getInternalSlot(F, SLOTS.LOAD);
        Assert(load.Status === "loading", "load.Status should have been loading but isnt");
        load.Status = "loaded";
        var linkSets = load.LinkSets;
        for (var i = 0, j = linkSets.length; i < j; i++) {
            UpdateLinkSetOnLoad(linkSets[i], load);
        }
        return NormalCompletion(undefined);
    };
    var F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.CALL, LoadSucceeded_Call);
    return F;
}

// 27.1.
function PromiseOfStartLoadPartWayThrough(step, loader, name, metadata, source, address) {
    //debug2("PromiseOfStartLoadPartWayThrough: start");
    var F = AsyncStartLoadPartwayThrough();
    var state = Object.create(null);
    state.Step = "translate";
    state.Loader = loader;
    state.ModuleName = name;
    state.ModuleMetadata = metadata;
    state.ModuleSource = source;
    state.ModuleAddress = address;
    setInternalSlot(F, "StepState", state);
    return PromiseNew(F);
}


// 26.1
function AsyncStartLoadPartwayThrough() {
    var F = OrdinaryFunction();
    //debug2("AsyncStartLoadPartwayThrough: start");
    var AsyncStartLoadPartwayThrough_Call = function (thisArg, argList) {
        //debug2("AsyncStartLoadPartwayThrough_Call");
        var resolve = argList[0];
        var reject = argList[1];
        var state = getInternalSlot(F, "StepState");
        var loader = state.Loader;
        var name = state.ModuleName;
        var step = state.Step;
        var source = state.ModuleSource;
        if (hasRecordInList(loader.Modules, "Name", name)) return newTypeError( "Got name in loader.Modules");
        if (hasRecordInList(loader.Loads, "Name", name)) return newTypeError( "loader.Loads contains another entry with name '"+name+"'");
        var load = CreateLoad(name);
        load.Metadata = state.ModuleMetadata;
        var linkSet = CreateLinkSet(loader, load);
        if (!Array.isArray(loader.Loads)) loader.Loads = [];
        loader.Loads.push(load);
        var result = callInternalSlot(SLOTS.CALL, resolve, null, [linkSet.done]);
        if (step === "locate") {
            ProceedToLocate(loader, load);
        } else if (step === "fetch") {
            var addressPromise = PromiseOf(address);
            ProceedToFetch(loader, load, addressPromise);
        } else {
            Assert(step === "translate", "step has to be translate");
            load.Address = state.ModuleAddress;
            var sourcePromise = PromiseOf(source);
            ProceedToTranslate(loader, load, sourcePromise);
        }
    };
    setInternalSlot(F, SLOTS.CALL, AsyncStartLoadPartwayThrough_Call);
    return F;
}
//
// Module Linkage
//

// 27.1.
function CreateModuleLinkageRecord (loader, body) {
    var M = ObjectCreate(null);
    setInternalSlot(M, "Body", body);
    setInternalSlot(M, "BoundNames", DeclaredNames(body));
    setInternalSlot(M, "KnownExportEntries", KnownExportEntries(body));
    setInternalSlot(M, "UnknownExportEntries", UnknownExportEntries(body));
    setInternalSlot(M, "ExportDefinitions", undefined);
    setInternalSlot(M, "Exports", undefined);
    setInternalSlot(M, "Dependencies", undefined);
    setInternalSlot(M, "UnlinkedDependencies", undefined);
    setInternalSlot(M, "ImportEntries", ImportEntries(body));
    setInternalSlot(M, "ImportDefinitions", undefined);
    setInternalSlot(M, "LinkErrors", []);
    var realm = loader.Realm;
    var globalEnv = realm.globalEnv;
    var env = NewModuleEnvironment(globalEnv);
    setInternalSlot(M, SLOTS.ENVIRONMENT, env);
    return M;
}
// 27.1.
function LookupExport(M, exportName) {
    var mExp = getInternalSlot(M, "Exports");
    var exp;
    if (!(exp=getRecordFromList(mExp, "ExportName", exportName))) {
        return NormalCompletion(undefined);
    }
    return exp.Binding;
}
// 27.1.
function LookupModuleDependency(M, requestName) {
    if (requestName === null) return M;
    var deps = getInternalSlot(M, "Dependencies");
    var pair = getRecordFromList(deps, "Key", requestName);
    return pair.Module;
}

// 27.1.
function LinkSet(loader, loads, done, resolve, reject) {
    var ls = Object.create(LinkSet.prototype);
    ls.Loader = loader;
    ls.Loads = loads;
    ls.Done = done;
    ls.Resolve = resolve;
    ls.Reject = reject;
    return ls;
}
LinkSet.prototype.toString = function () { return "[object LinkSet]"; };

// 27.1.
function CreateLinkSet(loader, startingLoad) {
    //debug2("createlinkset");
    if (Type(loader) !== OBJECT) return newTypeError( "CreateLinkSet: loader has to be an object");
    if (!hasInternalSlot(loader, SLOTS.LOAD)) return newTypeError( "CreateLinkSet: loader is missing internal properties");
    var promiseCapability = PromiseBuiltinCapability();
    if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;
    var linkSet = LinkSet(loader, loads, promiseCapability.Promise, promiseCapability.Resolve, promiseCapability.Reject);
    AddLoadToLinkSet(linkSet, startingLoad);
    return NormalCompletion(linkSet);
}

// 27.1.
function AddLoadToLinkSet(linkSet, load) {
    //debug2("add load to linkset");
    Assert(load.Status === "loading" || load.Status === "loaded", "load.Status is either loading or loaded.");
    var loader = linkSet.Loader;
    if (linkSet.indexOf(load) === -1) {     // INDEX-OF (Das ist dieser O(n) den fast jeder bedenkenlos und viel zu oft nimmt)
        linkSet.Loads.push(load);
        load.LinkSets.push(linkSet);
        if (load.Status === "loaded") {
            for (var i = 0, j = load.Dependencies.length; i < j; i++) {
                var r = load.Dependencies[i];
                if (!hasRecordInList(loader.Modules, "Key", name)) {       // Evil cubic stuff.
                    var depLoad;
                    if ((depLoad=getRecordFromList(loader.Loads, "Name", name))) {
                        AddLoadToLinkSet(linkSet, depLoad);
                    }
                }
            }
        }
    }
}
// 27.1.
function UpdateLinkSetOnLoad(linkSet, load) {
    //debug2("updatelinksetonload");
    var loads = linkSet.Loads;
    Assert(loads.indexOf(loads) > -1, "linkset.Loads has to contain load");
    Assert(load.Status === "loaded" || load.Status === "linked", "load.Status must be one of loaded or linked");
    for (var i = 0, j = loads.length; i < j; i++) {
        var load = loads[i];
        if (load.Status === "loading") return NormalCompletion(undefined);
    }
    var startingLoad = loads[0];
    var status = Link(loads, linkSet.Loader);
    if (isAbrupt(status)) {
        return LinkSetFailed(linkSet, status.value);
    }
    Assert(linkSet.Loads.length === 0, "linkset.Loads has to be empty here");
    var result = callInternalSlot(SLOTS.CALL, linkset.Resolve, undefined, [startingLoad]);
    Assert(!isAbrupt(result), "linkSet.resolve had to terminate normally");
    return result;
}

// 27.1.
function LinkSetFailed(linkSet, exc) {
    //debug2("linksetfailed");
    var loader = linkSet.Loader;
    var loads = linkSet.Loads;
    for (var i = 0, j = loads.length; i < j; i++) {
        var load = loads[i];
        var idx;
        Assert((idx = load.LinkSets.indexOf(v)) > -1, "load.LinkSets has to contain linkset");
        load.LinkSets.splice(idx,1);    // SPLICE KOSTET EXTRA
        if ((load.LinkSets.length === 0) && ((idx=loader.Loads.indexOf(load)) > -1)) {
            loader.Loads.splice(idx,1); // SPLICE KOSTET EXTRA
        }
    }
    var result = callInternalSlot(SLOTS.CALL, linkset.Reject, undefined, [exc]);
    Assert(!isAbrupt(result), "linkSet.reject had to terminate normally");
    return NormalCompletion(result);
}

// 27.1.    USING EXPENSIVE SPLICES to EMPTY the array (and .indexOf Arrays )
function FinishLoad(loader, load) {
    //debug2("finishload");
    var name = load.Name;
    if (name !== undefined) {
        Assert(!hasRecordInList(loader.Modules, "Key", load.Name), "there may be no duplicate records in loader.Modules");
        loader.Modules.push({ key: load.Name, value: load.Module });
    }
    var idx;
    if ((idx=loader.Loads.indexOf(load)) > -1) {
        load.Loads.splice(idx, 1);
    }
    for (var i = 0, j = load.LinkSets.length; i < j; i++) {
        var loads = load.LinkSets[i].Loads;
        idx = loads.indexOf(loads);
        if (idx>-1) {
            loads.splice(idx, 1);
        }
    }
    load.LinkSets.splice(0, load.linkSets.length);
}
// 29.1.



/*

    this one is still incomplete.

*/

function LinkageGroups(start) {
    // 1.
    Assert(Array.isArray(start), "start has to be a list of LinkSet Records");
    // 2.
    var G = start.Loads;
    var kind;
    // 3.
    for (var i = 0, j = G.length; i < j; i++) {
        var load = G[i];
        if (load.Kind != kind) {
            if (kind === undefined) kind = G[i].Kind;
            else return newSyntaxError( "all loads must be of the same kind");
        }
    }
    var n = 0;
    
    // 4.
    for (i = 0, j = G.length; i < j; i++) {
        load = G[i];
        n = max(n, load.UnlinkedDependencies.length);
        load.GroupIndex = n;
    }
    
    var declarativeGroupCount = n;
    var declarativeGroups = [];
    // 8.
    for (i = 0; i < j; i++) declarativeGroups.push([]);
    

    var dynamicGroupCount = 0;
    var dynamicGroups = [];
    var visited = [];
    for (var i = 0, j = G.length; i < j; i++) {
        var load = G[i];
        BuildLinkageGroups(load, declarativeGroups, dynamicGroups, visited);
    }
    
    var first = declarativeGroups[0];
    if (hasRecordInList(first, "Kind", "dynamic")) {
        var groups = interleaveLists(dynamicGroups, declarativeGroups);
    } else {
        var groups = interleaveLists(declarativeGroups, dynamicGroups);
    }
    return groups;

}

function interleaveLists(list1, list2) {
    // temp. doing nothing
    return list1.concat(list2);
}


// 28.1.
function BuildLinkageGroups(load, declarativeGroups, dynamicGroups, visited) {
    if (hasRecordInList(visited, "Name", load.Name)) return NormalCompletion(undefined);
    visited.push(load);
    for (var i = 0, j = load.UnlinkedDependencies.length; i < j; i++) {
        BuildLinkageGroups(dep, declarativeGroups, dynamicGroups, visitied);
    }
    i = load.GroupIndex;
    if (load.Kind === "declarative") {
        var groups = declarativeGroups;
    } else {
        groups = dynamicGroups;
    }
    var group = groups[i];
    group.push(load);
    return NormalCompletion(undefined);
}


// 28.1.
function Link(start, loader) {
    var groups = LinkageGroups(start);
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        if (group[0].Kind === "declarative") {
            LinkDeclarativeModules(group, loader)
        } else {
            LinkDynamicModules(group, loader);
        }
    }
}


// 28.1
function LinkImports(M) {
    var envRec = getInternalSlot(M, SLOTS.ENVIRONMENT);
    var defs = getInternalSlot(M, "ImportDefinitions");
    for (var i = 0; i < defs.length; i++) {
        var def = defs[i];
        if (def.ImportName === "module") {
            envRec.CreateImmutableBinding(def.LocalName);
            envRec.InitializeBinding(def.LocalName, def.Module);
        } else {
            var binding = ResolveExport(def.Module, def.ImportName);
            if (binding === undefined) {
                var error = newReferenceError( "Can not resolve export to a binding record");
                var linkErrors = getInternalSlot(M, "LinkErrors");
                linkErrors.push(error);
                return error;
            }  else {
                env.CreateImportBinding(envRec, def.LocalName);
                // THIS FUNCTION DOES NOT EXIST YET.
            }
        }
    }
}


// 31.1.
function ResolveExportEntries(M, visited) {
    var exportDefs = getInternalSlot(M, "ExportDefinitions");
    if (exportDefs != undefined) return exportDefs;
    var defs = [];
    var boundNames = getInternalSlot(M, "BoundNames");
    var knownExportEntries = getInternalSlot(M, "KnownExportEntries");
    var linkErrors = getInternalSlot(M, "LinkErrors");
    for (var i = 0, j = knownExportEntries.length; i < j; i++) {

        var entry = knownExportEntries[i];
        var modReq = entry.ModuleRequest;
        var otherMod = LookupModuleDependency(M, modReq);

        if (entry.Module !== null && entry.LocalName !== null && !boundNames[entry.LocalName]) { // caps
            var error = newReferenceError( "linkError created in ResolveExportEntries");
            linkErrors.push(error);
        }
        defs.push({ Module: otherMod, ImportName: entry.ImportName, LocalName: entry.LocalName,
            ExportName: entry.ExportName, Explicit: true });

    }
    var MUEE = M.UnknownExportEntries;
    for (var i = 0; i < MUUE.length; i++) {
        modReq = LookupModuleDependency(M, modReq);
        if (visited.indexOf(otherMod) > -1) {
            error = newSyntaxError( "otherMod is alreay in visited");
            linkErrors.push(error);
        } else {
            visited.push(otherMod);
            var otherDefs = ResolveExportEntries(otherMod, visited);
            for (var j = 0, k = otherDefs.length; j < k; j++) {
                var def = otherDefs[j];
                defs.push({ Module: otherMod, ImportName: def.ExportName, LocalName: null, ExportName: def.ExportName,
                    Explicit: false });
            }
        }
    }
    setInteranlSlot(M, "ExportDefinitions", defs);
    return defs;
}

// 28.1.
function ResolveExports(M) {
    //debug2("resolve exports");
    var exportDefinitions = getInternalSlot(M, "ExportDefinitions");
    for (var i = 0, j = exportDefinitions.length; i < j; i++) {
        var def = exportDefinitions[i];
        ResolveExport(M, def.exportName, []);
    }
}

// 29.1
function ResolveExport(M, exportName, visited) {
    //debug2("resolve export");
    var exports = getInternalSlot(M,"Exports");
    var exported;
    if (exported=getRecordFromList(exports, "ExportName", exportName)) {
        return NormalCompletion(exported.Binding)
    }
    var ref = { Module: M, ExportName: exportName };
    if (visited.indexOf(ref) !== -1) {
        var error = newSyntaxError( "ResolveExport: can not find ref in visited");
        var linkErrors = getInternalSlot(M, "LinkErrors");
        linkErrors.push(error);
    }
    var defs = getInternalSlot(M, "ExportDefinitions");
    var overlappingDefs = [];
    for (var i = 0, j = defs.length; i < j; i++) {
        var def = defs[i];
        if (def.ExportName === exportName) overlappingDefs.push(def);
    }
    if (!overlappingDefs.length) {
        error = newReferenceError( "ResolveExport: overlappingDefs is empty");
        linkErrors = getInternalSlot(M, "LinkErrors");
        linkErrors.push(error);
    }
    var explicits = [];
    for (var i = 0, j = overlappingDefs.length; i < j; i++) {
        var overlappingDef = overlappingDefs[i];
        if (overlappingDef.Explicit === true) explicits.push(overlappingDef);
    }
    if ((explicits.length > 1) || ((overlappingDefs.length > 1) && !explicits.length)) {
        error = newSyntaxError( "");
        linkErrors = getInternalSlot(M, "LinkErrors");
        linkErrors.push(error);
        return error;
    }

    def = getRecordFromList(overlappingDefs, "Explicit", true);
    if (!def) def = overlappingDefs[0];
    Assert(def, "i should have a def here");
    if (def.LocalName !== null) {
        var binding = { Module: M, LocalName: def.LocalName };
        var exported = { ExportName: exportName, Binding: binding };
        exports.push(exported);
        return binding;

    }
    visited.push(ref);
    var binding = ResolveExport(def.Module, def.ImportName);
    return binding;
}

// 28.1.
function ResolveImportEntries(M) {
    var entries = getInternalSlot(M, "ImportEntries");
    var defs = [];
    for (var i = 0; i < entries.length; i++) {
        var entry = entries[i];
        var modReq = entry.ModuleRequest;
        var otherMod = LookupModuleDependency(M, modReq);
        var record = { Module: otherMod, ImportName: entry.ImportName, localName: entry.LocalName };
        defs.push(record);
    }
    return defs;
}


// 28.1.
function LinkDynamicModules(loads, loader) {
    for (var i = 0; i < loads.length; i++) {
        var load = loads[i];
        var factory = load.Execute;
        var module = callInternalSlot(SLOTS.CALL, factory, undefined, []);
        if (isAbrupt(module = ifAbrupt(module))) return module;

        if (!hasInternalSlot(module, "Exports")) {
            return newTypeError( "module object has not the required internal properties");
        }
        load.Module = module;
        load.Status = "linked";
        var r = FinishLoad(loader, load);
        if (isAbrupt(r=ifAbrupt(r))) return r;
    }
}




function LinkDeclarativeModules(loads, loader) {
    var unlinked = [];
    for (var i = 0, j = loads.length; i < j; i++) {
        var module =CreateModuleLinkageRecord(loader, load.Body);
        var pair ={ Module: module, Load: load };
        unlinked.push(pair);
    }
    for (i = 0, j = loads.length; i < j; i++) {
        var resolvedDeps = [];
        var unlinkedDeps = [];
        var pair = loads[i];
        var deps = pair.load.Dependencies;
        var pairModule = pair.Module;
        for (var k = 0; k < deps.length; k++) {
            var dep = deps[k];
            var requestName = dep.Key;
            var normalizedName = dep.Value;
            var load;
            if (load = getRecordFromList(loads, "Name", normalizedName)) {
                if (load.Status === "linked") {
                    var resolvedDep = genericRecord({ Key: requestName, Value: load.Module });
                    resolvedDeps.push(resolvedDep);
                } else {
                    for (var m = 0; m < unlinked.lengh; m++) {
                        var otherPair = unlinked[i];
                        if (otherPair.Load.Name == normalizedName) {
                            resolvedDeps.push(genericRecord({ Key: requestName, Value: otherPair.Module }));
                            unlinkedDeps.push(otherPair.Load);
                        }
                    }
                }
            } else {
                var module = LoaderRegistryLookup(loader, normalizedName);
                if (module === null) {
                    var error = newReferenceError("");
                    pair.Module.LinkErrors.push(error);

                } else {
                    resolvedDeps.push({ Key: requestName, Value: module });
                }
            }
        }
        pairModule.Dependencies = resolvedDeps;
        pairModule.UnlinkedDependencies = unlinkedDeps;
    }
    for (i = 0, j = unlinked.length; i < j; i++) {
        pair = unlinked[i];
        ResolveExportEntries(pair.Module, []);
        ResolveExports(pair.Module);
    }
    for (i = 0, j = unlinked.length; i < j; i++) {
        pair = unlinked[i];
        ResolveExportEntries(pair.Module, []);
        ResolveExports(pair.Module);
    }
}


// 29.1
function EvaluateLoadedModule() {
    var EvaluateLoadedModule_Call = function (thisArg, argList) {
        var F = thisArg;
        var load = argList[0];
        var loader = getInternalSlot(F, SLOTS.LOADER);
        Assert(load.Status === "linked", "load.Status has to be linked here");
        var module = load.Module;
        var result = EnsureEvaluated(module, [], loader);
        if (isAbrupt(result)) return result;
        return NormalCompletion(module);
    };
    var F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.CALL, EvaluateLoadedModule_Call);
    return F;
}

// 29.1.
function EnsureEvaluated(mod, seen, loader) {
    seen.push(mod);
    var deps = mod.Dependencies;
    for (var i = 0, j = deps.length; i < j; i++) {
        var pair = deps[i];
        var dep = pair.value;
        if (seen.indexOf(dep) === -1) EnsureEvaluated(dep, seen, loader);
        // index of is so expensive
    }
    if (getInternalSlot(mod, "Evaluated") === true) return NormalCompletion(undefined);
    setInternalSlot(mod, "Evaluated", true);
    var body;
    if ((body=getInternalSlot(mod, "Body")) === undefined) return NormalCompletion(undefined);
    var env = getInternalSlot(mod, SLOTS.ENVIRONMENT);
    var status = InstantiateModuleDeclaration(body, env);
    var initContext = ExecutionContext(null);
    initContext.realm = getInternalSlot(loader, SLOTS.REALM);
    initContext.VarEnv = env;
    initContext.LexEnv = env;
    var stack = getStack();
    if (stack.length) getStack().pop();
    stack.push(initContext);
    var r = Evaluate(body);
    Assert(stack.pop() === initContext, "EnsureEvaluated: The right context could not be popped off the stack.");
    return r;
}



var ReturnUndefined_Call = function (thisArg, argList) {
    return NormalCompletion(undefined);
};

var ConstantFunction_Call = function (thisArg, argList) {
    return getInternalSlot(this, "ConstantValue");
};

function CreateConstantGetter(key, value) {
    var getter = CreateBuiltinFunction(getRealm(), ConstantFunction_Call, 0, "get " + key);
    setInternalSlot(getter, "ConstantValue", value);
    return getter;
}

function ReturnUndefined() {
    var F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.CALL, ReturnUndefined_Call);
    return F;
}

function IterableToList(iterable) {
    //debug2("iterable2list");
    //var A = ArrayCreate();
    var A = [];
    var next, status;
    while (next = IteratorStep(iterable)) {
        A.push(next);
        // status = Invoke(A, "push", [next]);
        //if (isAbrupt(status)) return status;
    }
    return A;
}

// Seite 21 von 43

function GetOption(options, name) {
    //debug2("get options");
    if (options == undefined) return undefined;
    if (Type(options) !== OBJECT) return newTypeError( "options is not an object");
    return Get(options, name);
}

function OrdinaryModule() {
    //debug2("ordinarymodule");
    var mod = ObjectCreate(null, {
        "Environment" : undefined,
        "Exports": undefined,
        "Dependencies": undefined
    });
    return mod;
}
function Module(obj) {
    if (Type(obj) !== OBJECT) return newTypeError( "module obj is not an object");
    var mod = OrdinaryModule();
    var keys = OwnPropertyKeysAsList(obj);
    for (var k in keys) {
        var key = keys[k];
        var value = Get(obj, key);
        if (isAbrupt(value = ifAbrupt(value))) return value;
        var F = CreateConstantGetter(key, value);
        var desc = {
            get: F,
            set: undefined,
            enumerable: true,
            configurable: false
        };
        var status = DefineOwnPropertyOrThrow(mod, key, desc);
        if (isAbrupt(status = ifAbrupt(status))) return status;
    }
    callInternalSlot("PreventExtensions", mod, mod, []);
    return mod;
}


/************************* unupdated end ****/


var LoaderConstructor_Call = function (thisArg, argList) {
    var options = argList[0];
    var loader = thisArg;

    if (options === undefined) options = ObjectCreate();
    if (Type(loader) !== OBJECT) return newTypeError( "Loader is not an object");

    if (getInternalSlot(loader, SLOTS.LOADERRECORD) !== undefined) return newTypeError( "loader.[[LoaderRecord]] isnt undefined");
    if (Type(options) !== OBJECT) return newTypeError( "the Loader constructors´ options argument is not an object");

    var realmObject = Get(options, "realm");
    if (isAbrupt(realmObject = ifAbrupt(realmObject))) return realmObject;

    var realm;
    if (realmObject === undefined) realm = getRealm();
    else {
        if ((Type(realmObject) !== OBJECT) || !hasInternalSlot(realmObject, SLOTS.REALM)) {
            return newTypeError( "realmObject has to be an object and to have a [[RealmRecord]] internal slot");
        }
        var realm = getInternalSlot(realmObject, SLOTS.REALM);
        if (realm === undefined) return newTypeError( "[[RealmRecord]] of a realmObject must not be undefined here.")
    }

    var define_loader_pipeline_hook = function (name) {
        var hook = Get(options, name);
        if (isAbrupt(hook = ifAbrupt(hook))) return hook;
        if (hook !== undefined) {
            var result = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, loader, name, {
                value: hook,
                writable: true,
                enumerable: true,
                configurable: true
            });
            if (isAbrupt(result)) return result;
        }
        return NormalCompletion();
    };
    var status = define_loader_pipeline_hook("normalize");
    if (isAbrupt(status)) return status;
    status = define_loader_pipeline_hook("locate");
    if (isAbrupt(status)) return status;
    status = define_loader_pipeline_hook("fetch");
    if (isAbrupt(status)) return status;
    status = define_loader_pipeline_hook("translate");
    if (isAbrupt(status)) return status;
    status = define_loader_pipeline_hook("instantiate");
    if (isAbrupt(status)) return status;
    if (getInternalSlot(loader, SLOTS.LOADERRECORD) !== undefined) return newTypeError( "loader.[[LoaderRecord]] seems to have been changed, expected the undefined value.");

    var loaderRecord = CreateLoaderRecord(realm, loader);
    setInternalSlot(loader, SLOTS.LOADERRECORD, loaderRecord);
    return NormalCompletion(loader);
};

var LoaderConstructor_Construct = function (argList) {
    return Construct(this, argList);
};

// 31.1.
var LoaderConstructor_$$create = function (thisArg, argList) {
    var F = thisArg;
    var loader = OrdinaryCreateFromConstructor(F, INTRINSICS.LOADERPROTOTYPE, [ SLOTS.LOADERRECORD ]);
    return loader;
};

// 31.1.
var LoaderPrototype_get_realm = function (thisArg, argList) {
    var loader = thisArg;
    if (Type(loader) !== OBJECT || !hasInternalSlot(loader, SLOTS.REALM)) {
        return newTypeError( "the this value is not a valid loader object");
    }
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    var realm = loaderRecord.Realm;
    return NormalCompletion(realm);
};

// 31.1.
var LoaderPrototype_get_global = function (thisArg, argList) {
    var loader = thisArg;
    if (Type(loader) !== OBJECT || !hasInternalSlot(loader, SLOTS.REALM)) {
        return newTypeError( "the this value is not a valid loader object");
    }
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    var realm = loaderRecord.Realm;
    var global = realm.globalThis;
    return NormalCompletion(global);
};

// 31.1.
var LoaderPrototype_entries = function (thisArg, argList) {
    var loader = thisLoader(thisArg);
    return CreateLoaderIterator(loader, "key+value");
};

var LoaderPrototype_values = function (thisArg, argList) {
    var loader = thisLoader(thisArg);
    return CreateLoaderIterator(loader, "value");
};

var LoaderPrototype_keys = function (thisArg, argList) {
    var loader = thisLoader(thisArg);
    return CreateLoaderIterator(loader, "key");
};
// 31.1.
var LoaderPrototype_define = function (thisArg, argList) {
    //debug2("loaderprotodefine");
    var name = argList[0];
    var source =argList[1];
    var options = argList[2];
    var loader = thisArg;
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    name = ToString(name);
    if (isAbrupt(name = ifAbrupt(name))) return name;
    var address = GetOption(options, "address");
    if (isAbrupt(address = ifAbrupt(address))) return address;
    var metadata = GetOption(options, "metadata");
    if (isAbrupt(metadata = ifAbrupt(metadata))) return metadata;
    if (metadata === undefined) metadata = ObjectCreate();
    var p = PromiseOfStartLoadPartWayThrough("translate", loaderRecord, name, metadata, source, address);
    if (isAbrupt(p = ifAbrupt(p))) return p;
    var G = ReturnUndefined();
    p = PromiseThen(p, G);
    return p;
};

// 31.1.
var LoaderPrototype_load = function (thisArg, argList) {
    //debug2("loaderprotoload");
    var name = argList[0];
    var options = argList[1];
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var loaderRecord = getInternalSlot(loader,SLOTS.LOADERRECORD);
    var p = LoadModule(loader, name, options);
    if (isAbrupt(p = ifAbrupt(p))) return p;
    var F = ReturnUndefined();
    p = PromiseThen(p, F);
    return p;
};

// 31.1.
var LoaderPrototype_module = function (thisArg, argList) {
    //debug2("loaderprotomodule");
    var source = argList[0];
    var options = argList[1];
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    var address = GetOption(options, "address");
    if (isAbrupt(address = ifAbrupt(address))) return address;
    var load = CreateLoad(undefined);
    load.Address = address;
    var linkSet = CreateLinkSet(loaderRecord, load);
    var successCallback = EvaluateLoadedModule();
    setInternalSlot(successCallback, SLOTS.LOADER, loaderRecord);
    setInternalSlot(successCallback, SLOTS.LOAD, load);
    var p = PromiseThen(linkSet.Done, successCallback);
    var sourcePromise = PromiseOf(source);
    ProceedToTranslate(loader, load, sourcePromise);
    return NormalCompletion(p);
};

// 31.1.
var LoaderPrototype_import = function (thisArg, argList) {
    //debug2("loaderprototypeimport");
    var name = argList[0];
    var options = argList[1];
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    var p = LoadModule(loaderRecord, name, options);
    if (isAbrupt(p = ifAbrupt(p))) return p;
    var F = EvaluateLoadedModule();
    setInternalSlot(F, SLOTS.LOADER, loaderRecord);
    var p = PromiseThen(p, F);
    return p;
};

// 31.1.
var LoaderPrototype_eval = function (thisArg, argList) {
    //debug2("loaderprototypeeval");
    var source = argList[0];
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    return IndirectEval(loaderRecord.Realm, source);
};

// 31.1.
var LoaderPrototype_get = function (thisArg, argList) {
    //debug2("loaderprototypeget");
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var name = ToString(argList[0]);
    if (isAbrupt(name = ifAbrupt(name))) return name;
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);

    var modules = loaderRecord.Modules;
    var record, module;
    if ((record = getRecordFromList(modules, "Key", name))) {
        var module = p.Value;
        var result = EnsureEvaluated(module, [], loaderRecord);
        if (isAbrupt(result = ifAbrupt(result))) return result;
        return NormalCompletion(module);
        // has typo/bug in spec, let module = p.value. ensureenv(module) but return p.value
    }
    return NormalCompletion(undefined);
};
// 31.1.
var LoaderPrototype_has = function (thisArg, argList) {
    //debug2("loaderprototypehas");
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var name = ToString(argList[0]);
    if (isAbrupt(name = ifAbrupt(name))) return name;

    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    var modules = loaderRecord.Modules;
    if (hasRecordInList(modules, "Key", name)) return NormalCompletion(true);

    /*  
     refactoring hasRecord in list. must result in this:
     if (modules[name]) {
        return NormalCompletion(true);
     }
    */
     
    return NormalCompletion(false);

};
// 31.1.
var LoaderPrototype_set = function (thisArg, argList) {
    //debug2("loaderprototypeset");
    var name = argList[0];
    var module = argList[1];
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    var name = ToString(name);
    if (isAbrupt(name = ifAbrupt(name))) return name;
    if (Type(module) !== OBJECT) return newTypeError( "module is not an object");
    var modules = loaderRecord.Modules;
    var p;
    if (p=getRecordFromList(modules, "Key", name)) {
        p.Value = module;
        return NormalCompletion(loader);
    }
    p = { Key: name, Value: module };
    loaderRecord.Modules.push(p);
    return NormalCompletion(loader);
};
// 31.1.
var LoaderPrototype_delete = function (thisArg, argList) {
    var name = argList[0];
    var loader = thisLoader(thisArg);
    if (isAbrupt(loader = ifAbrupt(loader))) return loader;
    var loaderRecord = getInternalSlot(loader, SLOTS.LOADERRECORD);
    name = ToString(name);
    if (isAbrupt(name = ifAbrupt(name))) return name;
    var modules = loaderRecord.Modules;
    for (var i = 0, j = modules.length; i < j; i++) {
        var p = modules[i];
        if (SameValue(p.Key, name)) {
            // remove them from list otherwhere
            p.Key = empty;
            p.Value = empty;
            return NormalCompletion(true);
        }
    }
    return NormalCompletion(false);
};
var LoaderPrototype_normalize = function (thisArg, argList) {
    var name = argList[0];
    var refererName = argList[1];
    var refererAddress = argList[2];
    Assert(Type(name) === STRING, "Loader.prototype.normalize: name has to be a string.");
    return NormalCompletion(name);
};
var LoaderPrototype_locate = function (thisArg, argList) {
    var loadRequest = argList[0];
    var r = Get(loadRequest, "name");
    if (isAbrupt(r=ifAbrupt(r))) return r;
    return NormalCompletion(r);
};
var LoaderPrototype_fetch = function (thisArg, argList) {
    return newTypeError( "The Loader.prototype.fetch function is supposed to throw a type error.");
};
var LoaderPrototype_translate = function (thisArg, argList) {
    var load = argList[0];
    var r = Get(load, "source");
    if (isAbrupt(r=ifAbrupt(r))) return r;
    return NormalCompletion(r);
};

var LoaderPrototype_instantiate = function (thisArg, argList) {
    var loadRequest = argList[0];
    return NormalCompletion(undefined);
};

var LoaderPrototype_$$iterator = LoaderPrototype_entries;

// Loader
setInternalSlot(LoaderConstructor, SLOTS.PROTOTYPE, FunctionPrototype);
setInternalSlot(LoaderConstructor, SLOTS.CALL, LoaderConstructor_Call);
setInternalSlot(LoaderConstructor, SLOTS.CONSTRUCT, LoaderConstructor_Construct);
LazyDefineProperty(LoaderConstructor, $$create, CreateBuiltinFunction(realm,LoaderConstructor_$$create, 0, "[Symbol.create]"));
MakeConstructor(LoaderConstructor, false, LoaderPrototype);
//SetFunctionName(LoaderConstructor, SLOTS.LOADER);

// Loader.prototype
LazyDefineProperty(LoaderPrototype, "entries", CreateBuiltinFunction(realm,LoaderPrototype_entries, 0, "entries"));
LazyDefineProperty(LoaderPrototype, "values", CreateBuiltinFunction(realm,LoaderPrototype_values, 0, "values"));
LazyDefineProperty(LoaderPrototype, "keys", CreateBuiltinFunction(realm,LoaderPrototype_keys, 0, "keys"));
LazyDefineProperty(LoaderPrototype, "has", CreateBuiltinFunction(realm,LoaderPrototype_has, 0, "has"));
LazyDefineProperty(LoaderPrototype, "get", CreateBuiltinFunction(realm,LoaderPrototype_get, 0, "get"));
LazyDefineProperty(LoaderPrototype, "set", CreateBuiltinFunction(realm,LoaderPrototype_set, 0, "set"));
LazyDefineProperty(LoaderPrototype, "delete", CreateBuiltinFunction(realm,LoaderPrototype_delete, 0, "delete"));
LazyDefineProperty(LoaderPrototype, "define", CreateBuiltinFunction(realm,LoaderPrototype_define, 2, "define"));

LazyDefineProperty(LoaderPrototype, "load", CreateBuiltinFunction(realm,LoaderPrototype_load,    1, "load"));
LazyDefineProperty(LoaderPrototype, "module", CreateBuiltinFunction(realm,LoaderPrototype_module, 1, "module"));
LazyDefineProperty(LoaderPrototype, "import", CreateBuiltinFunction(realm,LoaderPrototype_import, 0, "import"));
LazyDefineProperty(LoaderPrototype, "eval", CreateBuiltinFunction(realm,LoaderPrototype_eval, 0, "eval"));
LazyDefineProperty(LoaderPrototype, "normalize", CreateBuiltinFunction(realm,LoaderPrototype_normalize, 0, "normalize"));
LazyDefineProperty(LoaderPrototype, "fetch", CreateBuiltinFunction(realm,LoaderPrototype_fetch, 0, "fetch"));
LazyDefineProperty(LoaderPrototype, "locate", CreateBuiltinFunction(realm,LoaderPrototype_locate, 0, "locate"));
LazyDefineProperty(LoaderPrototype, "translate", CreateBuiltinFunction(realm,LoaderPrototype_instantiate, 1, "translate"));
LazyDefineProperty(LoaderPrototype, "instantiate", CreateBuiltinFunction(realm,LoaderPrototype_instantiate, 0, "instantiate"));
LazyDefineProperty(LoaderPrototype, $$iterator, CreateBuiltinFunction(realm,LoaderPrototype_$$iterator, 0, "[Symbol.iterator]"));
LazyDefineProperty(LoaderPrototype, $$toStringTag, SLOTS.LOADER);

function CreateLinkedModuleInstance (loader) {
    var mod = OrdinaryModule();
//    var lr = getInternalSlot(loader, SLOTS.LOADERRECORD);
//    lr.Modules.push({ Name: name, Module: mod });
    return mod;
}

// 31.1.
var LoaderPrototype_newModule = function(thisArg, argList) {
    var obj = argList[0];
    if (Type(obj) !== OBJECT) return newTypeError( "newModule: obj is not an object");

    var mod = CreateLinkedModuleInstance(thisArg);
    var keys = OwnPropertyKeysAsList(obj);
    if (isAbrupt(keys = ifAbrupt(keys))) return keys;
    for (var i = 0, j = keys.length; i < j; i++) {
        var key = keys[i];
        var value = Get(obj, key);
        if (isAbrupt(value = ifAbrupt(value))) return value;
        var F = CreateConstantGetter(key, value);
        var desc = {
            configurable: false,
            enumerable: true,
            get: F,
            set: undefined
        };
        var status = DefineOwnPropertyOrThrow(mod, key, desc);
    }
    callInternalSlot("PreventExtensions", mod);
    return NormalCompletion(mod);
};

LazyDefineBuiltinFunction(LoaderPrototype, "newModule", 1, LoaderPrototype_newModule);
// ##################################################################
// Der Loader Iterator
// ##################################################################

// 31.1.
function CreateLoaderIterator(loader, kind) {
    var loaderIterator = ObjectCreate(LoaderIteratorPrototype, [
        SLOTS.LOADER,
        SLOTS.LOADERNEXTINDEX,
        SLOTS.LOADERITERATIONKIND
    ]);
    setInternalSlot(loaderIterator, SLOTS.LOADER, loader);
    setInternalSlot(loaderIterator, SLOTS.LOADERNEXTINDEX, 0);
    setInternalSlot(loaderIterator, SLOTS.LOADERITERATIONKIND, kind);
    return loaderIterator;
}
exports.CreateLoaderIterator = CreateLoaderIterator;
// 31.1.
var LoaderIteratorPrototype_next = function next(thisArg, argList) {
    var iterator = thisArg;
    var m = getInternalSlot(iterator, SLOTS.LOADER);
    var loaderRecord = getInternalSlot(m, SLOTS.LOADERRECORD);
    var index = getInternalSlot(iterator, SLOTS.LOADERNEXTINDEX);
    var itemKind = getInternalSlot(iterator, SLOTS.LOADERITERATIONKIND);
    if (m === undefined) return CreateItrResultObject(undefined, true);
    var result;
    var entries = loaderRecord.Modules;
    while (index < entries.length) {
        var e = entries[index];
        index = index + 1;
        setInternalSlot(iterator, SLOTS.LOADERNEXTINDEX, index);
        if (e.Key !== empty) {
            if (itemKind === "key") result = e.Key;
            else if (itemKind === "value") result = e.Value;
            else {
                Assert(itemKind==="key+value", "itemKind has to be key+value here");
                result = ArrayCreate(2);
                CreateDataProperty(result, "0", e.Key);
                CreateDataProperty(result, "1", e.Value);
            }
            return CreateItrResultObject(result, false);
        }
    }
    setInternalSlot(iterator, SLOTS.LOADER, undefined);
    return CreateItrResultObject(undefined, true);
};

// 31.1.
var LoaderIteratorPrototype_$$iterator = function $$iterator(thisArg, argList) {
    return thisArg;
};

LazyDefineProperty(LoaderIteratorPrototype, $$iterator, CreateBuiltinFunction(realm, LoaderIteratorPrototype_$$iterator, 0, "[Symbol.iterator]"));
LazyDefineProperty(LoaderIteratorPrototype, "next", CreateBuiltinFunction(realm, LoaderIteratorPrototype_next, 0, "next"));
LazyDefineProperty(LoaderIteratorPrototype, $$toStringTag, "Loader Iterator");


// ===========================================================================================================
// Console (add-on, with if (hasConsole) console.log);
// ===========================================================================================================

LazyDefineBuiltinConstant(ConsoleObject, $$toStringTag, "Console");

DefineOwnProperty(ConsoleObject, "log", {
    value: CreateBuiltinFunction(realm, function log(thisArg, argList) {
        if (hasConsole) console.log.apply(console, argList);
    }),
    writable: true,
    enumerable: false,
    configurable: true

});
DefineOwnProperty(ConsoleObject, "dir", {
    value: CreateBuiltinFunction(realm, function dir(thisArg, argList) {
        if (hasConsole) console.dir.apply(console, argList);
    }),
    writable: true,
    enumerable: false,
    configurable: true

});

DefineOwnProperty(ConsoleObject, "error", {
    value: CreateBuiltinFunction(realm, function error(thisArg, argList) {
        if (hasConsole) console.error.apply(console, argList);
    }),
    writable: true,
    enumerable: false,
    configurable: true

});
DefineOwnProperty(ConsoleObject, "html", {
    value: CreateBuiltinFunction(realm, function html(thisArg, argList) {
        var selector = argList[0];
        var html = "";
        if (Type(selector) !== STRING) return newTypeError( "First argument of console.html should be a valid css selector string.");
        if (typeof document !== "undefined") {
            var element = document.querySelector(selector);
        } else {
            if (typeof process !== "undefined") {
                if (hasConsole) console.log.apply(console, argList.slice(1));
            } else
                return newReferenceError( "Can not select element. document.querySelector is not supported in the current environment.");
        }
        if (element) {
            html += argList[1];
            for (var i = 2, j = argList.length; i < j; i++) {
                html += ", " + argList[i];
            }
            html += "<br>\n";
        } else {
            return newReferenceError( "document.querySelector could not find the element " + selector);
        }
        element.innerHTML += html;
        return NormalCompletion(undefined);
    }),
    writable: true,
    enumerable: false,
    configurable: true
});


function IsSparseArray(A) {
    var len = Get(A, "length");
    var elem;
    for (var i = 0, j = ToUint32(len); i < j; i++) {
        elem = Get(A, ToString(i));
        if (isAbrupt(elem = ifAbrupt(elem))) return elem;
        if (elem === undefined) return true;
    }
    return false;
}

function IsArray(A) {
    return A instanceof ArrayExoticObject;
}


DefineOwnProperty(ArrayConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function $$create(thisArg, argList) {
        var F = thisArg;
        var proto = GetPrototypeFromConstructor(F, INTRINSICS.ARRAYPROTOTYPE);
        if (isAbrupt(proto = ifAbrupt(proto))) return proto;
        var obj = ArrayCreate(undefined, proto);
        return obj;
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

var ArrayConstructor_call =  function (thisArg, argList) {
    var O = thisArg;
    var array;
    var intLen;
    var F, proto;
    var defineStatus;
    var len;
    var k;
    var putStatus;
    var numberOfArgs;
    var Pk, itemK;
    var items;
    numberOfArgs = argList.length;

    if (numberOfArgs === 1) {
        len = GetValue(argList[0]);
        if (Type(O) === OBJECT && !getInternalSlot(O, SLOTS.ARRAYINITIALISATIONSTATE)) {
            setInternalSlot(O, SLOTS.ARRAYINITIALISATIONSTATE, true);
            array = O;
        } else {
            F = this;
            proto = OrdinaryCreateFromConstructor(F, INTRINSICS.ARRAYPROTOTYPE);
            if (isAbrupt(proto)) return proto;
            proto = ifAbrupt(proto);
            array = ArrayCreate(0, proto);
        }
        array = ifAbrupt(array);
        if (isAbrupt(array)) return array;
        if (Type(len) !== NUMBER) {
            defineStatus = DefineOwnPropertyOrThrow(array, "0", {
                value: len,
                writable: true,
                enumerable: true,
                configurable: true
            });
            if (isAbrupt(defineStatus)) return defineStatus;
            intLen = 1;
        } else {
            intLen = ToUint32(len);
            if (intLen != len) return newRangeError(trans("ARRAY_LENGTH_ERROR"));
        }
        putStatus = Put(array, "length", intLen, true);
        if (isAbrupt(putStatus)) return putStatus;
        return NormalCompletion(array);

    } else {
        len = GetValue(argList[0]);
        if (Type(O) === OBJECT && !getInternalSlot(O, SLOTS.ARRAYINITIALISATIONSTATE)) {
            setInternalSlot(O, SLOTS.ARRAYINITIALISATIONSTATE, true);
            array = O;
        } else {
            F = this;
            proto = OrdinaryCreateFromConstructor(F, INTRINSICS.ARRAYPROTOTYPE);
            if (isAbrupt(proto)) return proto;
            proto = ifAbrupt(proto);
            array = ArrayCreate(0, proto);
        }

        array = ifAbrupt(array);
        if (isAbrupt(array)) return array;
        k = 0;
        items = argList;

        while (k < numberOfArgs) {
            Pk = ToString(k);
            itemK = items[k];
            defineStatus = DefineOwnPropertyOrThrow(array, Pk, {
                value: itemK,
                writable: true,
                enumerable: true,
                configurable: true

            });
            if (isAbrupt(defineStatus)) return defineStatus;
            k = k + 1;
        }
        putStatus = Put(array, "length", numberOfArgs, true);
        if (isAbrupt(putStatus)) return putStatus;
        return NormalCompletion(array);
    }

};
var ArrayConstructor_construct = function (argList) {
    var F = this;
    var argumentsList = argList;
    return OrdinaryConstruct(F, argumentsList);
};



DefineOwnProperty(ArrayConstructor, "isArray", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var arg = GetValue(argList[0]);
        return IsArray(arg);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayConstructor, "of", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var items = CreateArrayFromList(argList);
        var lenValue = Get(items, "length");
        var C = thisArg;
        var newObj;
        var A;
        var len = ToInteger(lenValue);
        if (IsConstructor(C)) {
            newObj = OrdinaryConstruct(C, [len]);
            A = ToObject(newObj);
        } else {
            A = ArrayCreate(len);
        }
        if (isAbrupt(A = ifAbrupt(A))) return A;
        var k = 0;
        var Pk, kValue, defineStatus, putStatus;
        while (k < len) {
            Pk = ToString(k);
            kValue = Get(items, Pk);
            defineStatus = DefineOwnPropertyOrThrow(A, Pk, {
                value: kValue,
                writable: true,
                configurable: true,
                enumerable: true
            });
            if (isAbrupt(defineStatus)) return defineStatus;
            k = k + 1;
        }
        putStatus = Put(A, "length", len, true);
        if (isAbrupt(putStatus)) return putStatus;
        return A;

    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayConstructor, "from", {
    value: CreateBuiltinFunction(realm, function from(thisArg, argList) {
        var C = thisArg;
        var arrayLike = argList[0];
        var mapfn = argList[1];
        var thisArg2 = argList[2];
        var T;
        var items = ToObject(arrayLike);
        var mapping = false;
        var len, lenValue;
        var k;
        var iterator;
        var done, Pk, kValue, defineStatus, putStatus, kPresent, mappedValue;
        var newObj, A;
        if (isAbrupt(items = ifAbrupt(items))) return items;
        if (mapfn == undefined) {
            mapping = true;
        } else {
            if (!IsCallable(mapfn)) return newTypeError(format("S_NOT_CALLABLE"), "Array.from: mapfn");
            if (thisArg2) T = thisArg2;
            else T = undefined;
            mapping = true;

        }
        var usingIterator = HasProperty(items, $$iterator);

        var next, nextValue;
        if (usingIterator) {
            iterator = GetIterator(items);
            if (IsConstructor(C)) {
                newObj = OrdinaryConstruct(C, []);
                A = ToObject(newObj);
            } else {
                A = ArrayCreate(0);
            }
            while (!done) {

                Pk = ToString(k);
                next = IteratorNext(iterator);
                if (isAbrupt(next)) return next;
                next = ifAbrupt(next);
                done = IteratorComplete(next);
                if (isAbrupt(done)) return done;
                done = ifAbrupt(done);
                if (done) {

                }
                nextValue = IteratorValue(next);
                if (isAbrupt(nextValue)) return nextValue;
                nextValue = ifAbrupt(nextValue);
                if (mapping) {
                    mappedValue = mapfn.Call(T, [nextValue]);
                    if (isAbrupt(mappedValue)) return mappedValue;
                    mappedValue = ifAbrupt(mappedValue);

                } else mappedValue = nextValue;

                defineStatus = DefineOwnPropertyOrThrow(A, Pk, {
                    value: mappedValue,
                    writable: true,
                    enumberable: true,
                    configurable: true
                });

                if (isAbrupt(defineStatus)) return defineStatus;

                k = k + 1;
            }

        } else {

            // Assert(items is array like and no iterator)
            lenValue = Get(items, "length");
            len = ToInteger(lenValue);
            if (isAbrupt(len)) return len;
            if (IsConstructor(C)) {
                newObj = OrdinaryConstruct(C, [len]);
                A = ToObject(newObj);
            } else {
                A = ArrayCreate(len);
            }
            k = 0;
            while (k < len) {
                Pk = ToString(k);
                kPresent = HasProperty(items, Pk);
                if (isAbrupt(kPresent)) return kPresent;
                if (kPresent) {
                    kValue = Get(items, Pk);
                    if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
                    if (mapping) {
                        mappedValue = mapfn.Call(T, [kValue, k, items]);
                        if (isAbrupt(mappedValue = ifAbrupt(mappedValue))) return mappedValue;
                        defineStatus = DefineOwnPropertyOrThrow(A, Pk, {
                            value: mappedValue,
                            writable: true,
                            configurable: true,
                            enumerable: true
                        });

                    } else mappedValue = kValue;

                }
                k = k + 1;
            }

        }
        putStatus = Put(A, "length", len, true);
        if (isAbrupt(putStatus)) return putStatus;
        return A;
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "constructor", {
    value: ArrayConstructor,
    enumerable: false,
    writable: false,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "toString", {
    value: CreateBuiltinFunction(realm, function toString(thisArg, argList) {
        var array = ToObject(thisArg);
        if (isAbrupt(array = ifAbrupt(array))) return array;
        array = GetValue(array);
        var func = Get(array, "join");
        if (isAbrupt(func = ifAbrupt(func))) return func;
        if (!IsCallable(func)) func = Get(ObjectPrototype, "toString");
        return callInternalSlot(SLOTS.CALL, func, array, []);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});


function IsConcatSpreadable(O) {
    if (Type(O) !== OBJECT) return false;
    if (isAbrupt(O)) return O;
    var spreadable = Get(O, $$isConcatSpreadable);
    if (isAbrupt(spreadable = ifAbrupt(spreadable))) return spreadable;
    if (spreadable !== undefined) return ToBoolean(spreadable);
    return O instanceof ArrayExoticObject;
}

var ArrayPrototype_concat = function (thisArg, argList) {
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var A = undefined;
    if (IsArray(O)) {
        var C = Get(O, "constructor");
        if (isAbrupt(C=isAbrupt(C))) return C;
        if (IsConstructor(C)) {
            var thisRealm = getRealm();
            if (thisRealm === getInternalSlot(C, SLOTS.REALM)) {
                A =  callInternalSlot(SLOTS.CONSTRUCT, C, [0]);
                if (isAbrupt(A=ifAbrupt(A))) return A;
            }
        }
    }
    if (A === undefined) {
        A = ArrayCreate(0);
        if (isAbrupt(A=ifAbrupt(A))) return A;
    }
    var n = 0;
    var items = [O].concat(argList);
    var i = 0;
    var status;
    while (i < items.length) {
        var E = items[i];
        var spreadable = IsConcatSpreadable(E);
        if (spreadable) {
            var k = 0;
            var lenVal = Get(E, "length");
            var len = ToLength(lenVal);
            if (isAbrupt(len=ifAbrupt(len))) return len;
            while (k < len) {
                var P = ToString(k);
                var exists = HasProperty(E, P);
                if (isAbrupt(exists=ifAbrupt(exists))) return exists;
                if (exists) {
                    var subElement = Get(E, P);
                    if (isAbrupt(subElement=ifAbrupt(subElement))) return subElement;
                    status = CreateDataPropertyOrThrow(A, ToString(n), subElement);
                    if (isAbrupt(status)) return status;
                }
                n = n + 1;
                k = k + 1;
            }
        } else  {
            status = CreateDataPropertyOrThrow(A, ToString(n), E);
            if (isAbrupt(status=ifAbrupt(status))) return status;
            n = n + 1;
        }
        i = i + 1;
    }
    var putStatus = Put(A, "length", n, true);
    if (isAbrupt(putStatus)) return putStatus;
    return NormalCompletion(A);
};


DefineOwnProperty(ArrayPrototype, "join", {
    value: CreateBuiltinFunction(realm, function join(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var separator = argList[0];
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (isAbrupt(len = ifAbrupt(len))) return len;
        if (separator === undefined) separator = ",";
        var sep = ToString(separator);
        if (len === 0) return NormalCompletion("");
        var element0 = Get(O, "0");
        var R;
        if (element0 === undefined) R = "";
        else R = ToString(element0);
        var k = 1;
        while (k < len) {
            var S = R + sep;
            var element = Get(O, ToString(k));
            var next;
            if (element === undefined || element === null) next = "";
            else next = ToString(element);
            if (isAbrupt(next = ifAbrupt(next))) return next;
            R = S + next;
            k = k + 1;
        }
        return NormalCompletion(R);
    }, 1),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "pop", {
    value: CreateBuiltinFunction(realm, function pop(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (isAbrupt(len = ifAbrupt(len))) return len;
        var putStatus, deleteStatus;
        if (len === 0) {
            putStatus = Put(O, "length", 0, true);
            if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
            return undefined;
        } else {
            var newLen = len - 1;
            var index = ToString(newLen);
            var element = Get(O, index);
            if (isAbrupt(element = ifAbrupt(element))) return element;
            deleteStatus = DeletePropertyOrThrow(O, index);
            if (isAbrupt(deleteStatus = ifAbrupt(deleteStatus))) return deleteStatus;
            putStatus = Put(O, "length", newLen, true);
            if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
            return NormalCompletion(element);
        }
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "push", {
    value: CreateBuiltinFunction(realm, function push(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var n = ToUint32(lenVal);
        if (isAbrupt(n = ifAbrupt(n))) return n;
        var items = argList;
        var E, putStatus;
        for (var i = 0, j = items.length; i < j; i++) {
            E = items[i];
            putStatus = Put(O, ToString(n), E, true);
            if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
            n = n + 1;
        }
        putStatus = Put(O, "length", n, true);
        if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
        return NormalCompletion(n);
    }, 1),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "reverse", {
    value: CreateBuiltinFunction(realm, function reverse(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (isAbrupt(len = ifAbrupt(len))) return len;
        var middle = Math.floor(len / 2);
        var lower = 0;
        var putStatus;
        var deleteStatus;
        while (lower < middle) {
            var upper = len - lower - 1;
            var upperP = ToString(upper);
            var lowerP = ToString(lower);
            var lowerValue = Get(O, lowerP);
            if (isAbrupt(lowerValue = ifAbrupt(lowerValue))) return lowerValue;
            var upperValue = Get(O, upperP);
            if (isAbrupt(upperValue = ifAbrupt(upperValue))) return upperValue;
            var lowerExists = HasProperty(O, lowerP);
            if (isAbrupt(lowerExists = ifAbrupt(lowerExists))) return lowerExists;
            var upperExists = HasProperty(O, upperP);
            if (isAbrupt(upperExists = ifAbrupt(upperExists))) return upperExists;
            if (lowerExists === true && upperExists === true) {
                putStatus = Put(O, lowerP, upperValue, true);
                if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
                putStatus = Put(O, upperP, lowerValue, true);
                if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;

            } else if (lowerExists === false && upperExists === true) {

                putStatus = Put(O, lowerP, upperValue, true);
                if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
                deleteStatus = DeletePropertyOrThrow(O, upperP);
                if (isAbrupt(deleteStatus = ifAbrupt(deleteStatus))) return deleteStatus;

            } else if (lowerExists === true && upperExists === false) {

                deleteStatus = DeletePropertyOrThrow(O, lowerP);
                if (isAbrupt(deleteStatus = ifAbrupt(deleteStatus))) return deleteStatus;
                putStatus = Put(O, upperP, lowerValue, true);
                if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;

            }

            lower = lower + 1;
        }
        return NormalCompletion(O);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "shift", {
    value: CreateBuiltinFunction(realm, function shift(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (isAbrupt(len = ifAbrupt(len))) return len;

    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "slice", {
    value: CreateBuiltinFunction(realm, function slice(thisArg, argList) {
        var start = argList[0];
        var end = argList[1];
        var O = ToObject(thisArg);
        var A = ArrayCreate(0);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (isAbrupt(len = ifAbrupt(len))) return len;

        var relativeStart = ToInteger(start);
        if (isAbrupt(relativeStart = ifAbrupt(relativeStart))) return relativeStart;

        var k;
        if (relativeStart < 0) k = max((len + relativeStart), 0);
        else k = min(relativeStart, len);
        var relativeEnd;
        if (end === undefined) relativeEnd = len;
        else relativeEnd = ToInteger(end);
        if (isAbrupt(relativeEnd = ifAbrupt(relativeEnd))) return relativeEnd;
        var final;
        if (relativeEnd < 0) final = max((len + relativeEnd), 0);
        else final = min(relativeEnd, len);
        var n = 0;
        var putStatus, status;
        while (k < final) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var kValue = Get(O, Pk);
                if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
                status = CreateDataProperty(A, ToString(n), kValue);
                if (isAbrupt(status)) return status;
                if (status === false) return newTypeError(format("CREATEDATAPROPERTY_FAILED"));
            }
            k = k + 1;
            n = n + 1;
        }
        putStatus = Put(A, "length", n, true);
        if (isAbrupt(putStatus)) return putStatus;
        return NormalCompletion(A);
    }, 2),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "sort", {
    value: CreateBuiltinFunction(realm, function sort(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (isAbrupt(len = ifAbrupt(len))) return len;

    }),
    enumerable: false,
    writable: true,
    configurable: true
});

var ArrayPrototype_splice = function splice(thisArg, argList) {
    var start = argList[0];
    var deleteCount = argList[1];
    var items = arraySlice(argList, 2);
    var O = ToObject(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var lenVal = Get(O, "length");
    var len = ToLength(lenVal);
    if (isAbrupt(len = ifAbrupt(len))) return len;
    var relativeStart = ToInteger(start);
    if (isAbrupt(relativeStart = ifAbrupt(relativeStart))) return relativeStart;
    var actualStart;
    if (relativeStart < 0) actualStart = max((len+relativeStart),0);
    else actualStart=min(relativeStart,len);
    if (start === undefined) {
        var actualDeleteCount = 0;
    } else if (deleteCount === undefined) {
        actualDeleteCount = len - actualStart;
    } else {
        var dc = ToInteger(deleteCount);
        if (isAbrupt(dc = ifAbrupt(dc))) return dc;
        actualDeleteCount = min(max(dc, 0), len - actualStart);
    }
    var A = undefined;
    if (IsArray(O)) {
        var C = Get(O, "constructor");
        if (isAbrupt(C = ifAbrupt(C))) return C;
        if (IsConstructor(C) === true) {
            var thisRealm = getRealm();
            if (SameValue(thisRealm, getInternalSlot(C, SLOTS.REALM))) {
                A = callInternalSlot(SLOTS.CONSTRUCT, [actualDeleteCount]);
            }
        }
    }
    if (A === undefined) {
        A = ArrayCreate(actualDeleteCount);
    }
    if (isAbrupt(A = ifAbrupt(A))) return A;
    var k = 0;
    while (k < actualDeleteCount) {
        var from = ToString(actualStart + k);
        var fromPresent = HasProperty(O, from);
        if (isAbrupt(fromPresent = ifAbrupt(fromPresent))) return fromPresent;
        if (fromPresent === true) {
            var fromValue = Get(O, from);
            if (isAbrupt(fromValue = ifAbrupt(fromValue))) return fromValue;
            var status = CreateDataPropertyOrThrow(A, ToString(k), fromValue);
            if (isAbrupt(status)) return status;
        }
        k = k + 1;
    }
    var putStatus = Put(A, "length", actualDeleteCount, true);
    if (isAbrupt(putStatus)) return putStatus;
    var itemCount = items.length;
    if (itemCount < actualDeleteCount) {
        k = actualStart;
        while (k < (len - actualDeleteCount)) {
            from = ToString(k+actualDeleteCount);
            var to = ToString(k+itemCount);
            fromPresent = HasProperty(O, from);
            if (isAbrupt(fromPresent = ifAbrupt(fromPresent))) return fromPresent;
            if (fromPresent  === true) {
                fromValue = Get(O, from);
                if (isAbrupt(fromValue = ifAbrupt(fromValue))) return fromValue;
                putStatus = Put(O, to, fromValue, true);
                if (isAbrupt(putStatus)) return putStatus;

            } else {
                var deleteStatus = DeletePropertyOrThrow(O, to);
                if (isAbrupt(deleteStatus)) return deleteStatus;
            }
            k = k + 1;
        }
    } else if (itemCount > actualDeleteCount) {
        k = len - actualDeleteCount;
        while (k < actualStart) {
            from = ToString(k + actualDeleteCount - 1);
            to = ToString(k + itemCount - 1);
            fromPresent = HasProperty(O, from);
            if (fromPresent === true) {
                fromValue = Get(O, from);
                if (isAbrupt(fromValue = ifAbrupt(fromValue))) return fromValue;
                putStatus = Put(O, to, fromValue, true);
                if (isAbrupt(putStatus)) return putStatus;
            } else {
                deleteStatus = DeletePropertyOrThrow(O, to);
                if (isAbrupt(deleteStatus)) return deleteStatus;
            }
            k = k - 1;
        }
    }
    k = actualStart;
    var l = 0;
    while (k < actualStart) {
        var E = items[l];
        putStatus = Put(O, ToString(k), E, true);
        l = l + 1;
        k = k + 1;
        if (isAbrupt(putStatus)) return putStatus;
    }
    putStatus = Put(O, "length", len - actualDeleteCount + itemCount, true);
    if (isAbrupt(putStatus)) return putStatus;
    return NormalCompletion(A);
};

DefineOwnProperty(ArrayPrototype, "indexOf", {
    value: CreateBuiltinFunction(realm, function indexOf(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var searchElement = argList[0];
        var fromIndex = argList[1];
        var lenValue = Get(O, "length");
        var len = ToUint32(lenValue);
        if (isAbrupt(len = ifAbrupt(len))) return len;
        var n;
        var k;
        if (fromIndex !== undefined) n = ToInteger(fromIndex);
        else n = 0;
        if (isAbrupt(n = ifAbrupt(n))) return n;
        if (len === 0) return -1;
        if (n >= 0) k = n;
        else {
            k = len - abs(n);
            if (k < 0) k = 0;
        }
        while (k < len) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var elementK = Get(O, Pk);
                if (isAbrupt(elementK = ifAbrupt(elementK))) return elementK;
                /* Replace mit Strict EQ Abstract Op */
                var same = (searchElement === elementK);
                if (same) return NormalCompletion(k);
            }
            k = k + 1;
        }
        return NormalCompletion(-1);
    }, 1),
    enumerable: false,
    writable: true,
    configurable: true
});
DefineOwnProperty(ArrayPrototype, "lastIndexOf", {
    value: CreateBuiltinFunction(realm, function lastIndexOf(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var searchElement = argList[0];
        var fromIndex = argList[1];
        var lenValue = Get(O, "length");
        var len = ToUint32(lenValue);
        if (isAbrupt(len = ifAbrupt(len))) return len;
        var n;
        var k;
        if (len === 0) return -1;
        if (fromIndex !== undefined) n = ToInteger(fromIndex);
        else n = len - 1;
        if (isAbrupt(n = ifAbrupt(n))) return n;
        if (n >= 0) k = min(n, len - 1);
        else {
            k = len - abs(n);
        }
        while (k > 0) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var elementK = Get(O, Pk);
                if (isAbrupt(elementK = ifAbrupt(elementK))) return elementK;
                /* Replace mit Strict EQ Abstract Op */
                var same = (searchElement === elementK);
                if (same) return NormalCompletion(k);
            }
            k = k - 1;
        }
        return NormalCompletion(-1);

    }, 1),
    enumerable: false,
    writable: true,
    configurable: true
});
DefineOwnProperty(ArrayPrototype, "forEach", {
    value: CreateBuiltinFunction(realm, function forEach(thisArg, argList) {
        var callback = argList[0];
        var T = argList[1];
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (isAbrupt(len = ifAbrupt(len))) return len;
        if (!IsCallable(callback)) return newTypeError(format("S_NOT_CALLABLE", "forEach: callback"));
        if (argList.length < 2) T = undefined;
        var k = 0;
        while (k < len) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var kValue = Get(O, Pk);
                if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
                var funcResult = callInternalSlot(SLOTS.CALL, callback, T, [kValue, k, O]);
                if (isAbrupt(funcResult)) return funcResult;
            }
            k = k + 1;
        }
        return NormalCompletion(undefined);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});
DefineOwnProperty(ArrayPrototype, "map", {
    value: CreateBuiltinFunction(realm, function map(thisArg, argList) {

        var callback = argList[0];
        var T = argList[1];
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (!IsCallable(callback)) return newTypeError(format("S_NOT_CALLABLE", "map: callback"));
        if (argList.length < 2) T = undefined;
        var k = 0;
        var A = ArrayCreate(len);
        while (k < len) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var kValue = Get(O, Pk);
                if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
                var mappedValue = callInternalSlot(SLOTS.CALL, callback, T, [kValue, k, O]);
                if (isAbrupt(mappedValue = ifAbrupt(mappedValue))) return mappedValue;
                callInternalSlot(SLOTS.DEFINEOWNPROPERTY, A, Pk, {
                    value: mappedValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            }
            k = k + 1;
        }
        return NormalCompletion(A);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});
DefineOwnProperty(ArrayPrototype, "filter", {
    value: CreateBuiltinFunction(realm, function filter(thisArg, argList) {

        var callback = argList[0];
        var T = argList[1];
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (!IsCallable(callback)) return newTypeError(format("S_NOT_CALLABLE", "filter: callback"));
        if (argList.length < 2) T = undefined;
        var k = 0;
        var to = 0;
        var A = ArrayCreate(len);
        while (k < len) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var kValue = Get(O, Pk);
                if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;

                var selected = callInternalSlot(SLOTS.CALL, callback, T, [kValue, k, O]);
                if (isAbrupt(selected = ifAbrupt(selected))) return selected;
                if (ToBoolean(selected) === true) {

                    A.DefineOwnProperty(ToString(to), {
                        value: kValue,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                    to = to + 1;
                }
            }
            k = k + 1;
        }
        return NormalCompletion(A);
    }, 1),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "every", {
    value: CreateBuiltinFunction(realm, function every(thisArg, argList) {
        var callback = argList[0];
        var T = argList[1];
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (!IsCallable(callback)) return newTypeError(format("S_NOT_CALLABLE", "every: callback"));
        if (argList.length < 2) T = undefined;
        var k = 0;
        while (k < len) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var kValue = Get(O, Pk);
                if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
                var testResult = callInternalSlot(SLOTS.CALL, callback, T, [kValue, k, O]);
                if (isAbrupt(testResult = ifAbrupt(testResult))) return testResult;
                if (ToBoolean(testResult) === false) return NormalCompletion(false);
            }
            k = k + 1;
        }
        return NormalCompletion(true);
    }, 1),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "some", {
    value: CreateBuiltinFunction(realm, function some(thisArg, argList) {
        var callback = argList[0];
        var T = argList[1];
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        var lenVal = Get(O, "length");
        var len = ToUint32(lenVal);
        if (!IsCallable(callback)) return newTypeError(format("S_NOT_CALLABLE", "some: callback"));
        if (argList.length < 2) T = undefined;
        var k = 0;
        while (k < len) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                var kValue = Get(O, Pk);
                if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
                var testResult = callInternalSlot(SLOTS.CALL, callback, T, [kValue, k, O]);
                if (isAbrupt(testResult = ifAbrupt(testResult))) return testResult;
                if (ToBoolean(testResult) === true) return NormalCompletion(true);
            }
            k = k + 1;
        }
        return NormalCompletion(false);
    }, 1),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, "entries", {
    value: CreateBuiltinFunction(realm, function entries(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O)) return O;
        return CreateArrayIterator(O, "key+value");
    }),
    enumerable: false,
    writable: true,
    configurable: true
});
DefineOwnProperty(ArrayPrototype, "keys", {
    value: CreateBuiltinFunction(realm, function keys(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O)) return O;
        return CreateArrayIterator(O, "key");
    }),
    enumerable: false,
    writable: true,
    configurable: true
});


// %ArrayProto_values === Array.prototype.values

var ArrayPrototype_values = function (thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O)) return O;
        return CreateArrayIterator(O, "value");
};
setInternalSlot(ArrayProto_values, SLOTS.CALL, ArrayPrototype_values);
setInternalSlot(ArrayProto_values, SLOTS.CONSTRUCT, undefined);
LazyDefineProperty(ArrayPrototype, "values", ArrayProto_values);


DefineOwnProperty(ArrayPrototype, $$iterator, {
    value: CreateBuiltinFunction(realm, function $$iterator(thisArg, argList) {
        var O = ToObject(thisArg);
        if (isAbrupt(O = ifAbrupt(O))) return O;
        return CreateArrayIterator(O, "value");
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(ArrayPrototype, $$unscopables, {
    value: (function () {
        var blackList = ObjectCreate();
        CreateDataProperty(blackList, "find", true);
        CreateDataProperty(blackList, "findIndex", true);
        CreateDataProperty(blackList, "fill", true);
        CreateDataProperty(blackList, "copyWithin", true);
        CreateDataProperty(blackList, "entries", true);
        CreateDataProperty(blackList, "keys", true);
        CreateDataProperty(blackList, "values", true);
        return blackList;
    }()),
    enumerable: false,
    writable: true,
    configurable: true
});



var ArrayPrototype_toLocaleString = function toLocaleString(thisArg, argList) {

};


var ArrayPrototype_copyWithin = function (thisArg, argList) {
    var target = argList[0];
    var start = argList[1];
    var end = argList[2];
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var lenVal = Get(O, "length");
    var len = ToLength(lenVal);
    if (isAbrupt(len=ifAbrupt(len))) return len;
    var relativeTarget = ToInteger(target);
    if (isAbrupt(relativeTarget=ifAbrupt(relativeTarget))) return relativeTarget;
    var from, to, final;
    if (relativeTarget < 0) to = max((len+relativeTarget), 0);
    else to = min(relativeTarget, len);
    var relativeStart = ToInteger(start);
    if (isAbrupt(relativeStart=ifAbrupt(relativeStart))) return relativeStart;
    if (relativeStart < 0) from = max((len+relativeStart), 0);
    else from = min(relativeStart, len);
    var relativeEnd;
    if (end === undefined) relativeEnd = len;
    else relativeEnd = ToInteger(end);
    if (isAbrupt(relativeEnd=ifAbrupt(relativeEnd))) return relativeEnd;
    if (relativeEnd < 0) final = max((len+relativeEnd),0);
    else final = min(relativeEnd, len);
    var count = min(final-from, len-to);
    var direction;
    if (from < to && (to < from+count)) {
        direction = -1;
        from = from + count - 1;
        to = to + count - 1;
    } else {
        direction = 1;
    }
    while (count > 0) {
        var fromKey = ToString(from);
        var toKey = ToString(to);
        var fromPresent = HasProperty(O, fromKey);
        if (isAbrupt(fromPresent=ifAbrupt(fromPresent))) return fromPresent;
        if (fromPresent === true) {
            var fromVal = Get(O, fromKey);
            if (isAbrupt(fromVal = ifAbrupt(fromVal))) return fromVal;
            var putStatus = Put(O, toKey, fromVal, true);
            if (isAbrupt(putStatus)) return putStatus;
        } else {
            var deleteStatus = DeletePropertyOrThrow(O, toKey);
            if (isAbrupt(deleteStatus)) return deleteStatus;
        }
        from = from + direction;
        to = to + direction;
        count = count - 1;
    }
    return NormalCompletion(O);
};

var ArrayPrototype_reduce = function reduce(thisArg, argList) {
    var callback = argList[0];
    var initialValue = argList[1];
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var lenValue = Get(O, "length");
    var len = ToLength(lenValue);
    if (isAbrupt(len=ifAbrupt(len))) return len;
    if (!IsCallable(callback)) return newTypeError(format("S_NOT_CALLABLE", "reduce: first argument"));
    var k = 0;
    var accumulator;
    if (argList.length > 1) {
        accumulator = initialValue;
    } else {
        var kPresent = false;
        while (!kPresent && (k < len)) {
            var Pk = ToString(k);
            var kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent=ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                accumulator = Get(O, Pk);
                if (isAbrupt(accumulator=ifAbrupt(accumulator))) return accumulator;
            }
            k = k + 1;
        }
        if (!kPresent) return newTypeError(format("S_IS_FALSE", "kPresent"));
    }
    while (k < len) {
        Pk = ToString(k);
        kPresent = HasProperty(O, Pk);
        if (kPresent) {
            var kValue = Get(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            accumulator = callInternalSlot(SLOTS.CALL, callback, undefined, [accumulator, kValue, k, O]);
            if (isAbrupt(accumulator=ifAbrupt(accumulator))) return accumulator;
        }
        k = k + 1;
    }
    return NormalCompletion(accumulator);
};
var ArrayPrototype_reduceRight = function reduceRight(thisArg, argList) {
    var callback = argList[0];
    var initialValue = argList[1];
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var lenValue = Get(O, "length");
    var len = ToLength(lenValue);
    if (isAbrupt(len=ifAbrupt(len))) return len;
    if (!IsCallable(callback)) return newTypeError(format("S_NOT_CALLABLE", "reduce: first argument"));
    var accumulator;
    var k = len - 1;
    if (argList.length > 1) {
        accumulator = initialValue;
    } else {
        var kPresent = false;
        while (!kPresent && (k >= 0)) {
            var Pk = ToString(k);
            kPresent = HasProperty(O, Pk);
            if (isAbrupt(kPresent=ifAbrupt(kPresent))) return kPresent;
            if (kPresent) {
                accumulator = Get(O, Pk);
                if (isAbrupt(accumulator=ifAbrupt(accumulator))) return accumulator;
            }
            k = k - 1;
        }
        if (!kPresent) return newTypeError(format("S_IS_FALSE", "kPresent"));
    }
    while (k >= 0) {
        Pk = ToString(k);
        kPresent = HasProperty(O, Pk);
        if (kPresent) {
            var kValue = Get(O, Pk);
            if (isAbrupt(kPresent = ifAbrupt(kPresent))) return kPresent;
            accumulator = callInternalSlot(SLOTS.CALL, callback, undefined, [accumulator, kValue, k, O]);
            if (isAbrupt(accumulator=ifAbrupt(accumulator))) return accumulator;
        }
        k = k - 1;
    }
    return NormalCompletion(accumulator);
};
var ArrayPrototype_unshift = function unshift(thisArg, argList) {
    var items = argList;
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var lenValue = Get(O, "length");
    var len = ToLength(lenValue);
    if (isAbrupt(len=ifAbrupt(len))) return len;
    var argCount = argList.length;
    var k = len;
    // first move 0...n to k+1..n+k+1
    while (k > 0) {
        var from = ToString(k-1);
        var to = ToString(k+argCount-1);
        var fromPresent = HasProperty(O,from);
        if (isAbrupt(fromPresent=ifAbrupt(fromPresent))) return fromPresent;
        if (fromPresent === true) {
            var fromValue = Get(O, from);
            if (isAbrupt(fromValue=ifAbrupt(fromValue))) return fromValue;
            var putStatus = Put(O, to, fromValue, true);
            if (isAbrupt(putStatus)) return putStatus;
        } else {
            var deleteStatus = DeletePropertyOrThrow(O, to);
            if (isAbrupt(deleteStatus)) return deleteStatus;
        }
        k = k - 1;
    }
    var j = 0;
    var i = 0;
    // secondly insert new 0..k before [k+1..n+k+1]
    while (i < items.length) {
        var E = items[i];
        var putStatus = Put(O, ToString(j), E, true);
        if(isAbrupt(putStatus)) return putSttus;
        i = i + 1;
        j = j + 1;
    }
    putStatus = Put(O, "length", len+argCount, true);
    if (isAbrupt(putStatus)) return putStatus;
    // thats unshift (renumber the old, prepend the new) == O(n) total copy and define
    return NormalCompletion(len+argCount);
};

var ArrayPrototype_findIndex = function (thisArg, argList) {
    var predicate = argList[0];
    var optThisArg = argList[1];
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var lenValue = Get(O, "length");
    var len = ToLength(lenValue);
    if (isAbrupt(len=ifAbrupt(len))) return len;
    if (!IsCallable(predicate)) return newTypeError(format("S_NOT_CALLABLE", "findIndex: predicate"));
    var T;
    if (optThisArg != undefined) T = optThisArg; else T = undefined; // or just "optThisArg = T;"
    var k = 0;
    while (k < len) {
        var Pk = ToString(k);
        var kPresent = HasProperty(O, Pk);
        if (isAbrupt(kPresent=ifAbrupt(kPresent))) return kPresent;
        if (kPresent === true) {
            var kValue = Get(O, Pk);
            if (isAbrupt(kValue=ifAbrupt(kValue))) return kValue;
            var testResult = callInternalSlot(SLOTS.CALL, predicate, T, [kValue, k, O]);
            if (isAbrupt(testResult=ifAbrupt(testResult))) return testResult;
            if (ToBoolean(testResult) === true) return NormalCompletion(k);
        }
        k = k + 1;
    }
    return NormalCompletion(-1);
};

var ArrayPrototype_find = function (thisArg, argList) {
    var predicate = argList[0];
    var optThisArg = argList[1];
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var lenValue = Get(O, "length");
    var len = ToLength(lenValue);
    if (isAbrupt(len=ifAbrupt(len))) return len;
    if (!IsCallable(predicate)) return newTypeError(format("S_NOT_CALLABLE", "findIndex: predicate"));
    var T;
    if (optThisArg != undefined) T = optThisArg; else T = undefined; // or just "optThisArg = T;"
    var k = 0;
    while (k < len) {
        var Pk = ToString(k);
        var kPresent = HasProperty(O, Pk);
        if (isAbrupt(kPresent=ifAbrupt(kPresent))) return kPresent;
        if (kPresent === true) {
            var kValue = Get(O, Pk);
            if (isAbrupt(kValue=ifAbrupt(kValue))) return kValue;
            var testResult = callInternalSlot(SLOTS.CALL, predicate, T, [kValue, k, O]);
            if (isAbrupt(testResult=ifAbrupt(testResult))) return testResult;
            if (ToBoolean(testResult) === true) return NormalCompletion(kValue);
        }
        k = k + 1;
    }
    return NormalCompletion(-1);
};

var ArrayPrototype_fill = function (thisArg, argList) {
    var value = argList[0];
    var start = argList[1];
    var end = argList[2];
    var O = ToObject(thisArg);
    if (isAbrupt(O=ifAbrupt(O))) return O;
    var lenVal = Get(O, "length");
    var len = ToLength(lenVal);
    if (isAbrupt(len=ifAbrupt(len))) return len;
    var k, final;
    var relativeStart = ToInteger(start);
    if (isAbrupt(relativeStart=ifAbrupt(relativeStart))) return relativeStart;
    if (relativeStart < 0) k = max((len+relativeStart), 0);
    else k = min(relativeStart, len);
    var relativeEnd;
    if (end === undefined) relativeEnd = len;
    else relativeEnd = ToInteger(end);
    if (isAbrupt(relativeEnd=ifAbrupt(relativeEnd))) return relativeEnd;
    if (relativeEnd < 0) final = max((len+relativeEnd),0);
    else final = min(relativeEnd, len);
    while (k < final) {
        var Pk = ToString(k);
        var putStatus = Put(O, Pk, value, true);
        if (isAbrupt(putStatus)) return putStatus;
        k = k + 1;
    }
    return NormalCompletion(O);
};

MakeConstructor(ArrayConstructor, true, ArrayPrototype);
setInternalSlot(ArrayConstructor, SLOTS.CALL, ArrayConstructor_call);
setInternalSlot(ArrayConstructor, SLOTS.CONSTRUCT, ArrayConstructor_construct);
LazyDefineBuiltinConstant(ArrayConstructor, "length", 1);

setInternalSlot(ArrayPrototype, SLOTS.PROTOTYPE, ObjectPrototype);
LazyDefineBuiltinConstant(ArrayConstructor, "prototype", ArrayPrototype);
LazyDefineBuiltinFunction(ArrayPrototype, "concat", 1, ArrayPrototype_concat);
LazyDefineBuiltinFunction(ArrayPrototype, "copyWithin", 2, ArrayPrototype_copyWithin);
LazyDefineBuiltinFunction(ArrayPrototype, "fill", 1, ArrayPrototype_fill);
LazyDefineBuiltinFunction(ArrayPrototype, "find", 1, ArrayPrototype_find);
LazyDefineBuiltinFunction(ArrayPrototype, "findIndex", 1, ArrayPrototype_findIndex);

LazyDefineBuiltinFunction(ArrayPrototype, "reduce", 1, ArrayPrototype_reduce);
LazyDefineBuiltinFunction(ArrayPrototype, "reduceRight", 1, ArrayPrototype_reduceRight);
LazyDefineBuiltinFunction(ArrayPrototype, "splice", 2, ArrayPrototype_splice);
LazyDefineBuiltinFunction(ArrayPrototype, "toLocaleString", 2, ArrayPrototype_toLocaleString);
LazyDefineBuiltinFunction(ArrayPrototype, "unshift", 1, ArrayPrototype_unshift);
LazyDefineBuiltinConstant(ArrayPrototype, $$toStringTag, "Array");
// ===========================================================================================================
// Array Iterator
// ===========================================================================================================

setInternalSlot(ArrayIteratorPrototype, SLOTS.PROTOTYPE, ObjectPrototype);
DefineOwnProperty(ArrayIteratorPrototype, $$iterator, {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        return thisArg;
    }, 0, "[Symbol.iterator]"),
    enumerable: false,
    configurable: false,
    writable: false
});

DefineOwnProperty(ArrayIteratorPrototype, $$toStringTag, {
    value: "Array Iterator",
    enumerable: false,
    configurable: false,
    writable: false
});

DefineOwnProperty(ArrayIteratorPrototype, "next", {
    value: CreateBuiltinFunction(realm, function next(thisArg, argList) {
        var O = thisArg;
        if (Type(O) !== OBJECT) return newTypeError( "ArrayIterator.prototype.next: O is not an object. ");

        if (!hasInternalSlot(O, SLOTS.ITERATEDOBJECT) || !hasInternalSlot(O, SLOTS.ARRAYITERATIONNEXTINDEX) || !hasInternalSlot(O, SLOTS.ARRAYITERATIONKIND)) {
            return newTypeError( "Object has not all ArrayIterator properties.");
        }

        var a = getInternalSlot(O, SLOTS.ITERATEDOBJECT);
        var index = getInternalSlot(O, SLOTS.ARRAYITERATIONNEXTINDEX);
        var itemKind = getInternalSlot(O, SLOTS.ARRAYITERATIONKIND);
        var lenValue = Get(a, "length");
        var len = ToUint32(lenValue);
        var elementKey, found, result, elementValue;
        if (isAbrupt(len = ifAbrupt(len))) return len;
        if ((/sparse/).test(itemKind)) {
            var found = false;
            while (!found && (index < len)) {
                elementKey = ToString(index);
                found = HasProperty(a, elementKey);
                if (isAbrupt(found)) return found;
                if (!(found = ifAbrupt(found))) index = index + 1;
            }
        }
        if (index >= len) {
            setInternalSlot(O, SLOTS.ARRAYITERATIONNEXTINDEX, +Infinity);
            return CreateItrResultObject(undefined, true);
        }
        elementKey = ToString(index);
        setInternalSlot(O, SLOTS.ARRAYITERATIONNEXTINDEX, index + 1);

        if (itemKind === "key+value") {
            elementValue = Get(a, elementKey);
            if (isAbrupt(elementValue = ifAbrupt(elementValue))) return elementValue;

            result = ArrayCreate(2);
            callInternalSlot(SLOTS.DEFINEOWNPROPERTY, result, "0", {
                value: elementKey,
                writable: true,
                enumerable: true,
                configurable: true
            });
            callInternalSlot(SLOTS.DEFINEOWNPROPERTY, result, "1", {
                value: elementValue,
                writable: true,
                enumerable: true,
                configurable: true
            });
            callInternalSlot(SLOTS.DEFINEOWNPROPERTY, result, "length", {
                value: 2,
                writable: true,
                eumerable: false,
                configurable: false
            });
            return CreateItrResultObject(result, false);

        } else if (itemKind === "value") {
            elementValue = Get(a, elementKey);
            if (isAbrupt(elementValue = ifAbrupt(elementValue))) return elementValue;
            return CreateItrResultObject(elementValue, false);
        } else if (itemKind === "key") {
            return CreateItrResultObject(elementKey, false);
        }

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

// ===========================================================================================================
// String Constructor and Prototype
// ===========================================================================================================
// ===========================================================================================================
// String Constructor and Prototype
// ===========================================================================================================

setInternalSlot(StringConstructor, SLOTS.CALL, function Call(thisArg, argList) {
    var O = thisArg;
    var s;
    if (!argList.length) s = "";
    else s = ToString(argList[0]);
    if (isAbrupt(s = ifAbrupt(s))) return s;
    if (Type(O) === OBJECT && hasInternalSlot(O, SLOTS.STRINGDATA) && getInternalSlot(O, SLOTS.STRINGDATA) === undefined) {
        var length = s.length;
        var status = DefineOwnPropertyOrThrow(O, "length", {
            value: length,
            writable: false,
            enumerable: false,
            configurable: false
        });
        if (isAbrupt(status = ifAbrupt(status))) return status;
        setInternalSlot(O, SLOTS.STRINGDATA, s);
        return O;
    }
    return s;
});
setInternalSlot(StringConstructor, SLOTS.CONSTRUCT, function Construct(argList) {
    var F = StringConstructor;
    return OrdinaryConstruct(F, argList);
});

DefineOwnProperty(StringConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function $$create(thisArg, argList) {
        var F = thisArg;
        var obj = StringExoticObject();
        var proto = GetPrototypeFromConstructor(F, INTRINSICS.STRINGPROTOTYPE);
        if (isAbrupt(proto = ifAbrupt(proto))) return proto;
        setInternalSlot(obj, SLOTS.PROTOTYPE, proto);
        setInternalSlot(obj, SLOTS.STRINGDATA, undefined);
        return obj;
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

var StringRawFunction = CreateBuiltinFunction(realm, function raw(thisArg, argList) {
    // String.raw(callSite, ...substitutions)

    var callSite = argList[0];
    // ,...substitions)
    var substitutions = CreateArrayFromList(arraySlice(argList, 1));
    var cooked = ToObject(callSite);
    if (isAbrupt(cooked = ifAbrupt(cooked))) return cooked;
    var rawValue = Get(cooked, "raw");
    var raw = ToObject(rawValue);
    if (isAbrupt(raw = ifAbrupt(raw))) return raw;
    var len = Get(raw, "length");
    var literalSegments = ToLength(len);
    if (isAbrupt(literalSegments = ifAbrupt(literalSegments))) return literalSegments;
    if (literalSegments <= 0) return "";
    var stringElements = [];
    var nextIndex = 0;
    for (;;) {
        var nextKey = ToString(nextIndex);
        var next = Get(raw, nextKey);
        var nextSeg = ToString(next);
        if (isAbrupt(nextSeg = ifAbrupt(nextSeg))) return nextSeg;
        stringElements.push(nextSeg);
        if (nextIndex + 1 === literalSegments) {
            var string = stringElements.join('');
            return NormalCompletion(string);
        }
        next = Get(substitutions, nextKey);
        var nextSub = ToString(next);
        if (isAbrupt(nextSub = ifAbrupt(nextSub))) return nextSub;
        stringElements.push(nextSub);
        nextIndex = nextIndex + 1;
    }

});

DefineOwnProperty(StringConstructor, "raw", {
    value: StringRawFunction,
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(StringConstructor, "fromCharCode", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
       try {
           var str = String.fromCharCode.apply(null, argList);
       } catch (ex) {
           return newTypeError( "error converting string to charcode");
       }
       return NormalCompletion(str);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});

DefineOwnProperty(StringConstructor, "fromCodePoint", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        try {
            var str = String.fromCharCode.apply(null, argList);
        } catch (ex) {
            return newTypeError( "error converting string to charcode");
        }
        return NormalCompletion(str);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});



function GetReplaceSubstitution (matched, string, postion, captures) {
    Assert(Type(matched) === STRING, "matched has to be a string");
    var matchLength = matched.length;
    Assert(Type(string) === STRING);
    var stringLength = string.length;
    Assert(position >= 0, "position isnt a non negative integer");
    Assert(position <= stringLength);
    Assert(Array.isArray(captures), "captures is a possibly empty list but a list");
    var tailPos = position + matchLength;
    var m = captures.length;
    var result = matched.replace("$$", "$");
    /*
     Table 39 - Replacement Text Symbol Substitutions missing
     Please fix your skills here
     */
    return result;
}

var normalizeOneOfs = {
    "NFC":true,
    "NFD":true,
    "NFKC":true,
    "NFKD":true
};

var StringPrototype_normalize = function (thisArg, argList) {
    var from = argList[0];
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    if (from === undefined) from = "NFC";
    var f = ToString(from);
    if ((f = ifAbrupt(f)) && ifAbrupt(f)) return f;
    if (!normalizeOneOfs[f]) return newRangeError( "f is not one of nfc, nfd, nfkc, nfkd.");
    if (S.normalize) {
        // powers of native es.
        var ns = S.normalize(f);
    } else {
        // off point, but a fill-in
        ns = ""+S;
    }
    return NormalCompletion(ns);
};

var StringPrototype_replace = function (thisArg, argList) {
    var searchValue = argList[0];
    var replaceValue = argList[1];
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    if (Type(searchValue) === OBJECT && HasProperty(searchValue, $$isRegExp)) {
        return Invoke(searchValue, "replace", [string, replaceValue]);
    }
    var searchString = ToString(searchValue);
    if (isAbrupt(searchString = ifAbrupt(searchString))) return searchString;
    var i = 0;
    var len = S.length;
    var searchLen = searchString.length;
    while (i < len) {
        if ((S[i] == searchString[0]) && (S[i+searchLen-1] == searchString[searchLen-1])) {
            var k = 0;
            var match = true;
            while (k < searchLen) {
                if (S[k] !== searchString[k]) {
                    match = false;
                    break;
                }
                k = k + 1;
            }

            if (match) {
                var matched = searchString;
                if (IsCallable(replaceValue)) {
                    var replValue = callInternalSlot(SLOTS.CALL, replaceValue, undefined, [matched, pos, string]);
                    if (isAbrupt(replValue = ifAbrupt(replValue))) return replValue;
                    var replStr = ToString(replValue);
                    if (isAbrupt(replStr = ifAbrupt(replStr))) return replStr;

                } else {
                    var capstures = [];
                    var replStr = GetReplaceSubstitution(matched, string, pos, captures);

                }
                var tailPos = pos - matched.length;
                var newString;


            }
        }
        i = i + 1;
    }
    return NormalCompletion(string);
};
var StringPrototype_match = function (thisArg, argList) {
    var regexp = argList[0];
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var rx;
    if (Type(regexp) === OBJECT && HasProperty(regexp, $$isRegExp)) {
        rx = regexp;
    } else {
        rx = RegExpCreate(regexp, undefined);
    }
    if (isAbrupt(rx = ifAbrupt(rx))) return rx;
    return Invoke(rx, "match", []);
};
var StringPrototype_repeat = function (thisArg, argList) {
    var count = argList[0];
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var n = ToInteger(count);
    if (isAbrupt(n = ifAbrupt(n))) return n;
    if (n < 0) return newRangeError( "n is less than 0");
    if (n === Infinity) return newRangeError( "n is infinity");
    var T = "";
    for (var i = 0; i < n; i++) T+=S;
    return NormalCompletion(T);
};

var StringPrototype_contains = function (thisArg, argList) {
    var searchString = argList[0];
    var position = argList[1];
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var searchStr = ToString(searchString);
    var pos = ToInteger(position);
    var len = S.length;
    var start = min(max(pos, 0), len);
    var searchLen = searchStr.length;
    var i = start;
    var j = len;
    var result = false;
    while (i < len-searchLen) {

        if ((searchStr[0] === S[i]) && (searchStr[searchLen-1] === S[i+searchLen-1])) {
            result = true;
            for (var k = i+1, l = i+searchLen-1, m = 1; k < l; k++, m++) {
                if (searchStr[m] !== S[k]) result = false;
            }
            if (result) return true;
        }

        i = i+1;
    }
    return false;
};

var StringPrototype_startsWith = function (thisArg, argList) {
    var searchString = argList[0];
    var position = argList[1];
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var searchStr = ToString(searchString);
    var pos = ToInteger(position);
    var len = S.length;
    var start = min(max(pos, 0), len);
    var searchLength = searchString.length;
    if (searchLength+start > len) return false;
    var result = true;
    for (var k = 0, i = start, j = searchLength+start; i < j; i++, k++) {
        if (searchStr[k] !== S[i]) { result = false; break; }
    }
    return result;
};
var StringPrototype_endsWith = function (thisArg, argList) {
    var searchString = argList[0];
    var endPosition = argList[1];
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var searchStr = ToString(searchString);
    var pos = endPosition === undefined ? len : ToInteger(endPosition);
    var len = S.length;
    var end = min(max(pos, 0), len);
    var searchLength = searchString.length;
    var start = end - searchLength;
    if (start < 0) return false;
    var result = true;
    for (var i = start, j = start + searchLength, k = 0; i < j; i++, k++) {
        if (searchString[k] !== S[i]) { result = false; break; }
    }
    return result;
};
var StringPrototype_valueOf = function valueOf(thisArg, argList) {
    var x = thisStringValue(thisArg);
    return x;
};
var StringPrototype_toArray = function (thisArg, argList) {
    var S = CheckObjectCoercible(thisArg);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    S = ToString(S);
    var array = ArrayCreate(0);
    var len = S.length;
    var n = 0;
    while (n < len) {
        var c = S[n];
        callInternalSlot(SLOTS.DEFINEOWNPROPERTY, array, ToString(n), {
            configurable: true,
            enumerable: true,
            value: c,
            writable: true
        }, false);
        n = n + 1;
    }
    return NormalCompletion(array);

};

var trim_leading_space_expr = /^([\s]*)/;
var trim_trailing_space_expr = /([\s]*)$/;
// 31.1.
var StringPrototype_trim = function (thisArg, argList) {
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var T;
    T = S.replace(trim_leading_space_expr, "");
    T = T.replace(trim_trailing_space_expr, "");
    return NormalCompletion(T);
};

// 31.1.
var StringPrototype_search = function (thisArg, argList) {
    var regexp = argList[0];
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var rx;
    if (Type(regexp) === OBJECT  && HasProperty(regexp, $$isRegExp)) {
        rx = regexp;
    } else {
        rx = RegExpCreate(regexp, undefined);
    }
    if (isAbrupt(rx = ifAbrupt(rx))) return rx;
    return Invoke(rx, "search", [S]);
};
// 31.1.
var StringPrototype_toUpperCase = function (thisArg, argList) {
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var U = S.toUpperCase();
    return NormalCompletion(U);
};

// 31.1.
var StringPrototype_toLowerCase = function (thisArg, argList) {
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var L = S.toLowerCase();
    return NormalCompletion(L);
};

var StringPrototype_charAt = function (thisArg, argList) {
    var index = argList[0];
    index = index|0;
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var V = S.charAt(index);
    return NormalCompletion(V);
};
var StringPrototype_charCodeAt = function (thisArg, argList) {
    var index = argList[0];
    index = index|0;
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    if (index < 0) return NormalCompletion(NaN);
    if (index >= S.length) return NormalCompletion(NaN);
    var C = S.charCodeAt(index);
    return NormalCompletion(C);
};

var StringPrototype_split = function (thisArg, argList) {
    var separator = argList[0];
    var limit = argList[1];
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    if (Type(separator) === OBJECT && HasProperty(separator, $$isRegExp)) {
        return Invoke(separator, "split", [O, limit]);
    }
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var A = ArrayCreate(0);
    var lengthA = 0;
    var lim;
    if (limit === undefined) lim = Math.pow(2,53)-1;
    else lim = ToLength(limit);
    var s = S.length;
    var p = 0;
    var R = ToString(separator);

};

// http://wiki.ecmascript.org/doku.php?id=strawman:strawman
// 29.1. i have read a post about es7 timeline and one
// said for es7 we should look into the strawman namespace except
// for observe which is in harmony. Here is string_extensions
// http://wiki.ecmascript.org/doku.php?id=strawman:string_extensions
// the document defines lpad and rpad
var StringPrototype_lpad = function (thisArg, argList) {
    var minLength = argList[0];
    var fillStr = argList[1];
    var O = CheckObjectCoercible(thisArg);
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var intMinLength = ToInteger(minLength);
    if (isAbrupt(intMinLength = ifAbrupt(intMinLength))) return intMinLength;
    if (intMinLength === undefined) return NormalCompletion(S);
    var fillLen = intMinLength - S.length;
    if (fillLen < 0) return newRangeError( "lpad: fillLen is smaller than the string"); // maybe auto cut just the string. too?
    if (fillLen == Infinity) return newRangeError( "lpad: fillLen is Infinity");
    var sFillStr;
    if (fillStr === undefined) sFillStr = " ";
    else sFillStr = ""+fillStr;
    var sFillVal = sFillStr;
    var sFillLen;
    do { sFillVal += sFillStr; } while ((sFillLen = (sFillVal.length - S.length)) < fillLen);
    if (sFillLen > fillLen) sFillVal = sFillVal.substr(0, fillLen);
    return NormalCompletion(sFillVal + S)
};
var StringPrototype_rpad = function (thisArg, argList) {
    var minLength = argList[0];
    var fillStr = argList[1];
    var O = CheckObjectCoercible(thisArg);
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var intMinLength = ToInteger(minLength);
    if (isAbrupt(intMinLength = ifAbrupt(intMinLength))) return intMinLength;
    if (intMinLength === undefined) return NormalCompletion(S);
    var fillLen = intMinLength - S.length;
    if (fillLen < 0) return newRangeError( "lpad: fillLen is smaller than the string");
    if (fillLen == Infinity) return newRangeError( "lpad: fillLen is Infinity");
    var sFillStr;
    if (fillStr === undefined) sFillStr = " ";
    else sFillStr = ""+fillStr;
    var sFillVal = sFillStr;
    var sFillLen;
    do { sFillVal += sFillStr; } while ((sFillLen = (sFillVal.length - S.length)) < fillLen);
    if (sFillLen > fillLen) sFillVal = sFillVal.substr(0, fillLen);
    return NormalCompletion(S + sFillVal);
};


var StringPrototype_codePointAt = function (thisArg, argList) {
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var position = ToInteger(pos);
    var size = S.length;
    if (position < 0 || position >= size) return NormalCompletion(undefined);
    var first = S.charCodeAt(position);
    if (first < 0xD800 || first > 0xDBFF || (position+1===size)) return S;
    var second = S.charCodeAt(position+1);
    if (second < 0xDC00 || second > 0xDFFF) return NormalCompletion(first);
    var result = (((first - 0xD800)*1024) + (second - 0xDC00)) + 0x10000;
    return NormalCompletion(result);
};

var StringPrototype_concat = function (thisArg, argList) {
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var R = S;
    var next;
    for (var i = 0, j = argList.length; i < j; i++ ) {
        next = argList[i];
        var nextString = ToString(next);
        if (isAbrupt(nextString = ifAbrupt(nextString))) return nextString;
        R = R + next;
    }
    return NormalCompletion(R);
};

var StringPrototype_indexOf = function (thisArg, argList) {
    var searchString = argList[0];
    var position = argList[1];
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var searchStr = ToString(searchString);
    var pos = position | 0;
    var len = S.length;
    var start = min(max(pos, 0), len);
    var searchLen = searchStr.length;
    outer:
        for (var i = 0, j = (S.length-searchLen); i < j; i++) {
            var ch = S[i];
            if (ch === searchStr[0]) {
                var k = 0;
                while (k < searchLen) {
                    if (S[i+k] !== searchStr[k]) continue outer;
                    k = k + 1;
                }
                return NormalCompletion(i);
            }
        }
    return NormalCompletion(-1);
    
};


var StringPrototype_lastIndexOf = function (thisArg, argList)   {
    var searchString = argList[0];
    var position = argList[1];
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var searchStr = ToString(searchString);
    if (isAbrupt(searchStr=ifAbrupt(searchStr))) return searchStr;
    var numPos = ToNumber(position);
    if (isAbrupt(numPos = ifAbrupt(numPos))) return numPos;
    var pos;
    if (numPos !== numPos) pos = Infinity;
    else pos = numPos|0;
    var len = S.length;
    var start = min(pos, len);
    var searchLen = searchStr.length;
    //return S.lastIndexOf(searchStr, position);
    
    outer:
        for (var j = 0, i = start; j >= i; i--) {
            var ch = S[i];
            if (ch === searchStr[0]) {
                var k = 0;
                while (k < searchLen) {
                    if (S[i+k] !== searchStr[k]) continue outer;
                    k = k + 1;
                }
                return NormalCompletion(i);
            }
        }
        return NormalCompletion(-1);
    
};

var StringPrototype_localeCompare = function (thisArg, argList) {
    var that = argList[0];
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var S = ToString(O);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    var That = ToString(that);
    if (isAbrupt(that = ifAbrupt(that))) return that;
    return NormalCompletion(undefined);
};

var StringPrototype_at = function (thisArg, argList) {
    var position = argList[0];
    var O = CheckObjectCoercible(thisArg);
    var S = ToString(O);
    if (isAbrupt(S=ifAbrupt(S))) return S;
    var pos = ToInteger(position);
    if (isAbrupt(pos=ifAbrupt(pos))) return pos;
    var size = S.length;
    //if (pos < size || pos > size) return NormalCompletion("");
    var first = S[position];
    var cuFirst = s.charCodeAt(0);
    if (cuFirst < 0xD800 || cuFirst > 0xDBFF || (position + 1 === size)) return NormalCompletion(first);
    var cuSecond = S.charCodeAt[position+1];
    if (cuSecond < 0xDC00 || cuSecond > 0xDFFF) return NormalCompletion(String.fromCharCode(cuFirst));
    var second = S.charCodeAt[position+1];
    var cp = (first - 0xD800) * 0x400+(second-0xDC00)+0x1000;
    return NormalCompletion(String.fromCharCode(cuFirst, cuSecond));
};

LazyDefineBuiltinFunction(StringPrototype, "at", 1, StringPrototype_at);
LazyDefineBuiltinFunction(StringPrototype, "charAt", 1, StringPrototype_charAt);
LazyDefineBuiltinFunction(StringPrototype, "charCodeAt", 1, StringPrototype_charCodeAt);
LazyDefineBuiltinFunction(StringPrototype, "codePointAt", 1, StringPrototype_codePointAt);
LazyDefineBuiltinFunction(StringPrototype, "concat", 1, StringPrototype_concat);
LazyDefineBuiltinFunction(StringPrototype, "contains", 1, StringPrototype_contains);
LazyDefineBuiltinFunction(StringPrototype, "endsWith", 1, StringPrototype_endsWith);
LazyDefineBuiltinFunction(StringPrototype, "indexOf", 1, StringPrototype_indexOf);
LazyDefineBuiltinFunction(StringPrototype, "lastIndexOf", 1, StringPrototype_lastIndexOf);
LazyDefineBuiltinFunction(StringPrototype, "lpad", 1, StringPrototype_lpad);
LazyDefineBuiltinFunction(StringPrototype, "rpad", 1, StringPrototype_rpad);
LazyDefineBuiltinFunction(StringPrototype, "match", 0, StringPrototype_match);
LazyDefineBuiltinFunction(StringPrototype, "normalize", 0, StringPrototype_normalize);
LazyDefineBuiltinFunction(StringPrototype, "repeat", 0, StringPrototype_repeat);
LazyDefineBuiltinFunction(StringPrototype, "replace", 0, StringPrototype_replace);
LazyDefineBuiltinFunction(StringPrototype, "search", 1, StringPrototype_search);
LazyDefineBuiltinFunction(StringPrototype, "startsWith", 1, StringPrototype_startsWith);
LazyDefineBuiltinFunction(StringPrototype, "toArray", 0, StringPrototype_toArray);
LazyDefineBuiltinFunction(StringPrototype, "toLocaleCompare", 0, StringPrototype_localeCompare);
LazyDefineBuiltinFunction(StringPrototype, "toLowerCase", 0, StringPrototype_toLowerCase);
LazyDefineBuiltinFunction(StringPrototype, "toUpperCase", 0, StringPrototype_toUpperCase);
LazyDefineBuiltinFunction(StringPrototype, "trim", 1, StringPrototype_trim);
LazyDefineBuiltinFunction(StringPrototype, "valueOf", 0, StringPrototype_valueOf);
LazyDefineBuiltinConstant(StringPrototype, $$toStringTag, "String");
MakeConstructor(StringConstructor, true, StringPrototype);

DefineOwnProperty(StringPrototype, $$iterator, {
    value: CreateBuiltinFunction(realm, function iterator(thisArg, argList) {
        return CreateStringIterator(thisArg, "value");
    }, 0, "[Symbol.iterator]"),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(StringPrototype, "values", {
    value: CreateBuiltinFunction(realm, function values(thisArg, argList) {
        return CreateStringIterator(thisArg, "value");
    }),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(StringPrototype, "keys", {
    value: CreateBuiltinFunction(realm, function keys(thisArg, argList) {
        return CreateStringIterator(thisArg, "key");
    }),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(StringPrototype, "entries", {
    value: CreateBuiltinFunction(realm, function entries(thisArg, argList) {
        return CreateStringIterator(thisArg, "key+value");
    }),
    writable: false,
    enumerable: false,
    configurable: false
});
// ===========================================================================================================
// String Iterator
// ===========================================================================================================


DefineOwnProperty(StringIteratorPrototype, "next", {
    value: CreateBuiltinFunction(realm, function next(thisArg, argList) {
        var O = thisArg;
        if (Type(O) !== OBJECT)
            return newTypeError( "the this value is not an object");

        if (!hasInternalSlot(O, SLOTS.ITERATEDSTRING) || !hasInternalSlot(O, SLOTS.ITERATORNEXTINDEX) || !hasInternalSlot(O, SLOTS.ITERATIONKIND))
            return newTypeError( "iterator has not all of the required internal properties");

        var string = getInternalSlot(O, SLOTS.ITERATEDSTRING);
        var kind = getInternalSlot(O, SLOTS.ITERATIONKIND);
        var index = getInternalSlot(O, SLOTS.ITERATORNEXTINDEX);
        var result;


        string = ToString(string);
        var len = string.length;

        if (index < len) {
            var ch = string[index];
            setInternalSlot(O, SLOTS.ITERATORNEXTINDEX, index + 1);
            if (kind === "key") result = index;
            else if (kind === "value") result = ch;
            else {
                Assert(kind === "key+value", "string iteration kind has to be key+value");
                var result = ArrayCreate(2);
                CreateDataProperty(result, "0", index);
                CreateDataProperty(result, "1", ch);
            }
            return CreateItrResultObject(result, false);
        }
        return CreateItrResultObject(undefined, true);
    }),
    enumerable: false,
    configurable: false,
    writable: false
});

function CreateStringIterator(string, kind) {
    var iterator = ObjectCreate(StringIteratorPrototype, [
        SLOTS.ITERATEDSTRING,
        SLOTS.ITERATORNEXTINDEX,
        SLOTS.ITERATIONKIND
    ]);
    // for-of before worked without. there must be a mistake somewhere (found in ToPrimitive)
    // if (string instanceof StringExoticObject) string = getInternalSlot(string, SLOTS.STRINGDATA);
    // ---
    setInternalSlot(iterator, SLOTS.ITERATEDSTRING, string);
    setInternalSlot(iterator, SLOTS.ITERATORNEXTINDEX, 0);
    setInternalSlot(iterator, SLOTS.ITERATIONKIND, kind);
    return iterator;
}


LazyDefineBuiltinConstant(StringIteratorPrototype, $$toStringTag, "String Iterator");


// ===========================================================================================================
// Boolean Constructor and Prototype
// ===========================================================================================================

setInternalSlot(BooleanConstructor, SLOTS.CALL, function Call(thisArg, argList) {
    var O = thisArg;
    var value = argList[0];
    var b = ToBoolean(value);
    if (Type(O) === OBJECT && hasInternalSlot(O, SLOTS.BOOLEANDATA) && getInternalSlot(O, SLOTS.BOOLEANDATA) === undefined) {
        setInternalSlot(O, SLOTS.BOOLEANDATA, b);
        return NormalCompletion(O);
    }
    return NormalCompletion(b);
});
setInternalSlot(BooleanConstructor, SLOTS.CONSTRUCT, function Construct(argList) {
    return OrdinaryConstruct(this, argList);
});
MakeConstructor(BooleanConstructor, true, BooleanPrototype);
DefineOwnProperty(BooleanConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        return OrdinaryCreateFromConstructor(thisArg, INTRINSICS.BOOLEANPROTOTYPE,[SLOTS.BOOLEANDATA]);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});
DefineOwnProperty(BooleanConstructor, "length", {
    value: 1,
    enumerable: false,
    writable: false,
    configurable: false
});
DefineOwnProperty(BooleanPrototype, "constructor", {
    value: BooleanConstructor,
    enumerable: false,
    writable: false,
    configurable: false
});
DefineOwnProperty(BooleanPrototype, "toString", {
    value: CreateBuiltinFunction(realm, function toString(thisArg, argList) {
        var b = thisBooleanValue(thisArg);
        if (isAbrupt(b)) return b;
        if (b === true) return "true";
        if (b === false) return "false";
    }),
    enumerable: false,
    writable: true,
    configurable: true
});
DefineOwnProperty(BooleanPrototype, "valueOf", {
    value: CreateBuiltinFunction(realm, function valueOf(thisArg, argList) {
        return thisBooleanValue(thisArg);
    }),
    enumerable: false,
    writable: true,
    configurable: true
});
var SymbolFunction_Call = function Call(thisArg, argList) {
    var descString;
    var description = argList[0];
    if (description !== undefined) descString = ToString(description);
    if (isAbrupt(descString = ifAbrupt(descString))) return descString;
    var symbol = SymbolPrimitiveType();
    setInternalSlot(symbol, SLOTS.DESCRIPTION, descString);
    return NormalCompletion(symbol);
};
var SymbolFunction_Construct = function Construct(argList) {
    return OrdinaryConstruct(this, argList);
};
var SymbolPrototype_toString = function toString(thisArg, argList) {
    var s = thisArg;
    if (hasInternalSlot(s, SLOTS.SYMBOLDATA)) return newTypeError(format("HAS_NO_SLOT_S", "[[SymbolData]]"));
    var sym = getInternalSlot(s, SLOTS.SYMBOLDATA);
    var desc = getInternalSlot(sym, SLOTS.DESCRIPTION);
    if (desc === undefined) desc = "";
    Assert(Type(desc) === STRING, format("SLOT_S_NOT_A_STRING", "[[Description]]"));
    var result = "Symbol(" + desc + ")";
    return NormalCompletion(result);
};

var SymbolPrototype_valueOf = function valueOf(thisArg, argList) {
    var s = thisArg;
    if (hasInternalSlot(s, SLOTS.SYMBOLDATA)) return newTypeError(format("HAS_NO_SLOT_S", "[[SymbolData]]"));
    var sym = getInternalSlot(s, SLOTS.SYMBOLDATA);
    return NormalCompletion(sym);
};
var SymbolPrototype_$$toPrimitive = function (thisArg, argList) {
    return newTypeError(format("SYMBOL_TOPRIMITVE_ERROR"));
};
var SymbolFunction_keyFor = function (thisArg, argList) {
    var sym = argList[0];
    if (Type(sym) !== SYMBOL) return newTypeError(format("S_NOT_A_SYMBOL","keyFor: sym"));
    var key = getInternalSlot(sym, SLOTS.DESCRIPTION);
    var e = getRealm().GlobalSymbolRegistry[key];
    if (SameValue(e.Symbol, sym)) return NormalCompletion(e.Key);
    Assert(getRealm().GlobalSymbolRegistry[key] === undefined, trans("GLOBAL_SYMBOL_REGISTRY_ERROR"));
    return NormalCompletion(undefined);
};
var SymbolFunction_for = function (thisArg, argList) {
    var key = argList[0];
    var stringKey = ToString(key);
    if (isAbrupt(stringKey = ifAbrupt(stringKey))) return stringKey;
    var e = getRealm().GlobalSymbolRegistry[key];
    if (e !== undefined && SameValue(e.Key, stringKey)) return NormalCompletion(e.Symbol);
    Assert(e === undefined, trans("GLOBAL_SYMBOL_REGISTRY_ERROR"));
    var newSymbol = SymbolPrimitiveType();
    setInternalSlot(newSymbol, SLOTS.DESCRIPTION, stringKey);
    getRealm().GlobalSymbolRegistry[stringKey] = { Key: stringKey, Symbol: newSymbol };
    return NormalCompletion(newSymbol); // There is a Typo newSumbol in the Spec.
};
var SymbolFunction_$$create = function (thisArg, argList) {
    return newTypeError( format("SYMBOL_CREATE_ERROR"));
};
MakeConstructor(SymbolFunction, true, SymbolPrototype);
setInternalSlot(SymbolFunction, SLOTS.CALL, SymbolFunction_Call);
setInternalSlot(SymbolFunction, SLOTS.CONSTRUCT, SymbolFunction_Construct);
setInternalSlot(SymbolPrototype, SLOTS.PROTOTYPE, ObjectPrototype);

LazyDefineBuiltinConstant(SymbolFunction, $$create, CreateBuiltinFunction(realm, SymbolFunction_$$create, 0, "[Symbol.create]"));
LazyDefineBuiltinConstant(SymbolFunction, "create", $$create);
LazyDefineBuiltinFunction(SymbolFunction, "for", 1, SymbolFunction_for);
LazyDefineBuiltinConstant(SymbolFunction, "isConcatSpreadable", $$isConcatSpreadable);
LazyDefineBuiltinConstant(SymbolFunction, "isRegExp", $$isRegExp);
LazyDefineBuiltinConstant(SymbolFunction, "iterator", $$iterator);
LazyDefineBuiltinFunction(SymbolFunction, "keyFor", 1, SymbolFunction_keyFor /* ,realm */);
LazyDefineBuiltinConstant(SymbolFunction, "prototype", SymbolPrototype);
LazyDefineBuiltinConstant(SymbolFunction, "hasInstance", $$hasInstance);
LazyDefineBuiltinConstant(SymbolFunction, "toPrimitive", $$toPrimitive);
LazyDefineBuiltinConstant(SymbolFunction, "toStringTag", $$toStringTag);
LazyDefineBuiltinConstant(SymbolFunction, "unscopables", $$unscopables);
LazyDefineBuiltinConstant(SymbolPrototype, "constructor", SymbolFunction);
LazyDefineBuiltinConstant(SymbolPrototype, $$toPrimitive, CreateBuiltinFunction(realm, SymbolPrototype_$$toPrimitive, 1, "[Symbol.toPrimitive]"));
LazyDefineBuiltinFunction(SymbolPrototype, "toString", 0, SymbolPrototype_toString);
LazyDefineBuiltinConstant(SymbolPrototype, $$toStringTag, "Symbol");
LazyDefineBuiltinFunction(SymbolPrototype, "valueOf", 0, SymbolPrototype_valueOf);

// ===========================================================================================================
// Error
// ===========================================================================================================

setInternalSlot(ErrorPrototype, SLOTS.PROTOTYPE, ObjectPrototype);
MakeConstructor(ErrorConstructor, true, ErrorPrototype);
LazyDefineBuiltinConstant(ErrorConstructor, "prototype", ErrorPrototype);
LazyDefineBuiltinConstant(ErrorPrototype, "constructor", ErrorConstructor);
LazyDefineBuiltinConstant(ErrorPrototype, "name", "Error");

setInternalSlot(ErrorConstructor, SLOTS.CALL, function (thisArg, argList) {
    var func = ErrorConstructor;
    var message = argList[0];
    var name = "Error";
    var O = thisArg;
    var isObject = Type(O) === OBJECT;
    // This is different from the others in the spec
    if (!isObject || (isObject &&
        (!hasInternalSlot(O, SLOTS.ERRORDATA) || (getInternalSlot(O, SLOTS.ERRORDATA) === undefined)))) {
        O = OrdinaryCreateFromConstructor(func, INTRINSICS.ERRORPROTOTYPE, [
            SLOTS.ERRORDATA
        ]);
        if (isAbrupt(O = ifAbrupt(O))) return O;
    }
    // or i read it wrong
    Assert(Type(O) === OBJECT);
    setInternalSlot(O, SLOTS.ERRORDATA, "Error");
    if (message !== undefined) {
        var msg = ToString(message);
        if (isAbrupt(msg = ifAbrupt(msg))) return msg;
        var msgDesc = {
            value: msg,
            writable: true,
            enumerable: false,
            configurable: true
        };
        var status = DefineOwnPropertyOrThrow(O, "message", msgDesc);
        if (isAbrupt(status)) return status;
    }

    CreateDataProperty(O, "stack", stringifyErrorStack());
    setInternalSlot(O, "toString", function () { return "[object Error]"; });
    return O;
});

setInternalSlot(ErrorConstructor, SLOTS.CONSTRUCT, function (argList) {
    var F = this;
    var argumentsList = argList;
    return OrdinaryConstruct(F, argumentsList);
});

DefineOwnProperty(ErrorConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var F = thisArg;
        var obj = OrdinaryCreateFromConstructor(F, INTRINSICS.ERRORPROTOTYPE, [
            SLOTS.ERRORDATA
    ]);
        return obj;
    }),
    writable: false,
    configurable: false,
    enumerable: false
});

DefineOwnProperty(ErrorPrototype, "toString", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var O = thisArg;
        if (Type(O) !== OBJECT) return newTypeError( "Error.prototype.toString: O is not an object.");
        var name = Get(O, "name");
        if (isAbrupt(name)) return name;
        name = ifAbrupt(name);
        var msg = Get(O, "message");
        if (isAbrupt(msg)) return msg;
        msg = ifAbrupt(msg);
        if (msg === undefined) msg = "";
        else msg = ToString(msg);
        if (name === "") return msg;
        if (msg === "") return name;
        return name + ": " + msg;
    }),
    writable: false,
    configurable: false,
    enumerable: false

});

function createNativeError(nativeType, ctor, proto) {
    //var name = nativeType + "Error";
    // var intrProtoName = "%" + nativeType + "ErrorPrototype%";
    var name;
    var intrProtoName;
    switch(nativeType) {
        case "URI": name = "URIError"; intrProtoName = INTRINSICS.URIERROR; break;
        case "Range": name = "RangeError"; intrProtoName = INTRINSICS.RANGEERROR; break;
        case "Type": name = "TypeError"; intrProtoName = INTRINSICS.TYPEERROR; break;
        case "Reference": name = "ReferenceError"; intrProtoName = INTRINSICS.REFERENCEERROR; break;
        case "Syntax": name = "SyntaxError"; intrProtoName = INTRINSICS.SYNTAXERROR; break;
        case "Eval": name = "EvalError"; intrProtoName = INTRINSICS.EVALERROR; break;
    }

    //SetFunctionName(ctor, name);
    setInternalSlot(ctor, SLOTS.CALL, function (thisArg, argList) {
        var func = this;
        var O = thisArg;
        var message = argList[0];
        if (Type(O) !== OBJECT ||
            (Type(O) === OBJECT && getInternalSlot(O, SLOTS.ERRORDATA) == undefined)) {
            O = OrdinaryCreateFromConstructor(func, intrProtoName);
            if (isAbrupt(O=ifAbrupt(O))) return O;
        }
        if (Type(O) !== OBJECT) return newTypeError(format("S_NOT_OBJECT", "O"));
        setInternalSlot(O, SLOTS.ERRORDATA, name);
        if (message !== undefined) {
            var msg = ToString(message);
            var msgDesc = {
                value: msg,
                writable: true,
                enumerable: false,
                configurable: true
            };
            var status = DefineOwnPropertyOrThrow(O, "message", msgDesc);
            if (isAbrupt(status)) return status;
        }
        var cx = getContext();
        if (cx && cx.line != undefined) {
            var lineNumber = cx.line;
            var columnNumber = cx.column;
            CreateDataProperty(O, "lineNumber", lineNumber);
            CreateDataProperty(O, "columnNumber", columnNumber);
        }
        CreateDataProperty(O, "stack", stringifyErrorStack());
        // interne representation
        setInternalSlot(O, "toString", function () {
            return "[object "+name+"]";
        });
        return O;

    });

    setInternalSlot(ctor, SLOTS.CONSTRUCT, function (thisArg, argList) {
        var F = ctor;
        var argumentsList = argList;
        return OrdinaryCreateFromConstructor(F, argumentsList);
    });

    DefineOwnProperty(ctor, "length", {
        value: 1,
        enumerable: false,
        configurable: false,
        writable: false
    });
    DefineOwnProperty(ctor, $$create, {
        value: CreateBuiltinFunction(realm, function (thisArg, argList) {
            var F = thisArg;
            var obj = OrdinaryCreateFromConstructor(F, intrProtoName);
            return obj;
        }),
        enumerable: false,
        configurable: false,
        writable: false
    });

    LazyDefineBuiltinConstant(ctor, "prototype", proto);
    LazyDefineBuiltinConstant(proto, "constructor", ctor);
    LazyDefineBuiltinConstant(proto, "name", name);
    LazyDefineBuiltinConstant(proto, "message", "");
    MakeConstructor(ctor, false, proto);
}

// ===========================================================================================================
// SyntaxError, TypeError, ReferenceError, URIError, RangeError, EvalError
// ===========================================================================================================

createNativeError("Syntax", SyntaxErrorConstructor, SyntaxErrorPrototype);
createNativeError("Type", TypeErrorConstructor, TypeErrorPrototype);
createNativeError("Reference", ReferenceErrorConstructor, ReferenceErrorPrototype);
createNativeError("Range", RangeErrorConstructor, RangeErrorPrototype);
createNativeError("URI", URIErrorConstructor, URIErrorPrototype);
createNativeError("Eval", EvalErrorConstructor, EvalErrorPrototype);

// ===========================================================================================================
// eval("let x = 10"); Function calls the parser and exports.Evaluate
// ===========================================================================================================

setInternalSlot(EvalFunction, SLOTS.CALL, function (thisArg, argList) {

    var input, strict, direct, strictCaller, evalRealm, directCallToEval,
        ctx, value, result, script, evalCxt, LexEnv, VarEnv, strictVarEnv,
        strictScript;

    var Evaluate = require("runtime").Evaluate;

    input = GetValue(argList[0]);
    if (isAbrupt(input=ifAbrupt(input))) return input;

    if (Type(input) !== STRING) return input;
    try {
        script = parse(input);
    } catch (ex) {
        return newSyntaxError( ex.message);
    }

    if (script.type !== "Program") return undefined;

    if (script.strict) {
        strict = true;
    }

    if (directCallToEval) direct = true;
    strictCaller = !!direct;
    ctx = getContext();
    if (strict) ctx.strict = true;
    evalRealm = ctx.realm;

    if (direct) {

        // 1. if the code that made the call is function code
        // and ValidInFunction is false throw SyntaxError
        // 2. If the code is module code and
        // ValidInModule ist false throw SyntaxError
    }
    if (direct) {
        LexEnv = ctx.LexEnv;
        VarEnv = ctx.VarEnv;
    } else {
        LexEnv = evalRealm.globalEnv;
        VarEnv = evalRealm.globalEnv;
    }
    if (strictScript || (direct && strictCaller)) {
        strictVarEnv = NewDeclarativeEnvironment(LexEnv);
        LexEnv = strictVarEnv;
        VarEnv = strictVarEnv;
    }

    evalCxt = ExecutionContext(getContext());
    evalCxt.realm = evalRealm;
    evalCxt.VarEnv = VarEnv;
    evalCxt.LexEnv = LexEnv;
    getStack().push(evalCxt);
    result = Evaluate(script);
    getStack().pop();
    return result;
});

setInternalSlot(EvalFunction, SLOTS.CONSTRUCT, null);


// ===========================================================================================================
// Date Constructor and Prototype (algorithms above)
// ===========================================================================================================

setInternalSlot(DateConstructor, SLOTS.CALL, function (thisArg, argList) {

    var O = thisArg;
    var numberOfArgs = argList.length;
    var y, m, dt, h, min, milli, finalDate;

    if (numberOfArgs >= 2) {

        var year = argList[0];
        var month = argList[1];
        var date = argList[2];
        var hours = argList[3];
        var minutes = argList[4];
        var seconds = argList[5];
        var ms = argList[6];

        if (Type(O) === OBJECT
            && hasInternalSlot(O, SLOTS.DATEVALUE)
            && (getInternalSlot(O, SLOTS.DATEVALUE) === undefined)) {

            y = ToNumber(year);
            if (isAbrupt(y)) return y;
            m = ToNumber(month);
            if (isAbrupt(m)) return m;
            if (date) dt = ToNumber(date);
            else dt = 1;
            if (isAbrupt(dt)) return dt;
            if (hours) h = ToNumber(hours);
            else h = 0;
            if (minutes) min = ToNumber(minutes);
            else min = 0;
            if (isAbrupt(min)) return min;
            if (ms) milli = ToNumber(ms);
            else milli = 0;
            if (isAbrupt(milli)) return milli;
            finalDate = MakeDate(MakeDay(y, m, dt), MakeTime(h, min, s, milli));
            setInternalSlot(O, SLOTS.DATEVALUE, TimeClip(UTC(finalDate)));
        }
        return O;
    } else if (numberOfArgs === 1) {
        var value = argList[0];
        var tv, v;
        if (Type(O) === OBJECT && hasInternalSlot(O, SLOTS.DATEVALUE) && getInternalSlot(O, SLOTS.DATEVALUE) === undefined) {
            if (Type(value) === OBJECT && hasInternalSlot(value, SLOTS.DATEVALUE)) tv = thisTimeValue(value);
            else {
                v = ToPrimitive(value);
                if (Type(v) === STRING) {
                    tv = Invoke(DateConstructor, "parse", [v])
                } else {
                    tv = ToNumber(v);
                }
            }
                if (isAbrupt(tv = ifAbrupt(tv))) return tv;
                setInternalSlot(O, SLOTS.DATEVALUE, TimeClip(tv));
                return O;

        }
    } else if (numberOfArgs === 0) {
        if (Type(O) === OBJECT && hasInternalSlot(O, SLOTS.DATEVALUE) && getInternalSlot(O, SLOTS.DATEVALUE) === undefined) {
            setInternalSlot(O, SLOTS.DATEVALUE, Date.now()/*TimeClip(UTC(Date.now()))*/);
            return O;
        }
    } else {
        O = OrdinaryConstruct(DateConstructor, []);
        return Invoke(O, "toString", []);
    }
});

setInternalSlot(DateConstructor, SLOTS.CONSTRUCT, function (thisArg, argList) {
    return OrdinaryConstruct(this, argList);
});


DefineOwnProperty(DateConstructor, "prototype", {
    value: DatePrototype,
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "constructor", {
    value: DateConstructor,
    writable: false,
    enumerable: false,
    configurable: false
});

//DatePrototype
DefineOwnProperty(DateConstructor, "parse", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var string = ToString(argList[0]);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

//DatePrototype
DefineOwnProperty(DateConstructor, "now", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        return NormalCompletion(Date.now());
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DateConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var obj = OrdinaryCreateFromConstructor(DateConstructor, INTRINSICS.DATEPROTOTYPE, [
           SLOTS.DATEVALUE
    ]);
        return obj;
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getDate", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return DateFromTime(LocalTime(t));
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getDay", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return WeekDay(LocalTime(t));
    }),

    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getFullYear", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return YearFromTime(LocalTime(t));
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getHours", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return HourFromTime(LocalTime(t));
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getMilliSeconds", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return msFromTime(LocalTime(t));
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getMinutes", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return MinFromTime(LocalTime(t));
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getMonth", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return MonthFromTime(LocalTime(t));
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getTimeZoneOffset", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return (t - LocalTime(t));

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getUTCDay", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return WeekDay(t);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getUTCFullYear", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return YearFromTime(t);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getUTCHours", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return HourFromTime(t);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getUTCMilliseconds", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return msFromTime(t);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getUTCMinutes", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return MinFromTime(t);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "getUTCSeconds", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var t = thisTimeValue(thisArg);
        if (isAbrupt(t)) return t;
        if (t !== t) return NaN;
        return SecFromTime(t);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "setDate", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var date = argList[0];
        var t = LocalTime(thisTimeValue(thisArg));
        var newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t));
        var u = TimeClip(UTC(newDate));
        setInternalSlot(thisArg, SLOTS.DATEVALUE, u);
        return u;
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(DatePrototype, "", {
    value: null,
    writable: false,
    enumerable: false,
    configurable: false
});

LazyDefineBuiltinConstant(DatePrototype, $$toStringTag, "Date");


// ===========================================================================================================
// encodeURI, decodeURI functions
// ===========================================================================================================

setInternalSlot(EncodeURIFunction, SLOTS.CALL, function (thisArg, argList) {
    var uri = argList[0];
    var uriString = ToString(uri);
    if (isAbrupt(uriString = ifAbrupt(uriString))) return uriString;
    var unescapedUriSet = "" + uriReserved + uriUnescaped + "#";
    return Encode(uriString, unescapedUriSet);
});

setInternalSlot(EncodeURIComponentFunction, SLOTS.CALL, function (thisArg, argList) {
    var uriComponent = argList[0];
    var uriComponentString = ToString(uriComponent);
    if (isAbrupt(uriComponentString = ifAbrupt(uriComponentString))) return uriComponentString;
    var unescapedUriComponentSet = "" + uriUnescaped;
    return Encode(uriComponentString, unescapedUriComponentSet);
});

setInternalSlot(DecodeURIFunction, SLOTS.CALL, function (thisArg, argList) {
    var encodedUri = argList[0];
    var uriString = ToString(encodedUri);
    if (isAbrupt(uriString = ifAbrupt(uriString))) return uriString;
    var reservedUriSet = "" + uriReserved + "#";
    return Decode(uriString, reservedUriSet);
});

setInternalSlot(DecodeURIComponentFunction, SLOTS.CALL, function (thisArg, argList) {
    var encodedUriComponent = argList[0];
    var uriComponentString = ToString(encodedUriComponent);
    if (isAbrupt(uriComponentString = ifAbrupt(uriComponentString))) return uriComponentString;
    var reservedUriComponentSet = "";
    return Decode(uriComponentString, reservedUriComponentSet);
});


// ===========================================================================================================
// escape, unescape
// ===========================================================================================================

setInternalSlot(EscapeFunction, SLOTS.CALL, function (thisArg, argList) {
    return escape(argList[0]);
});

setInternalSlot(UnescapeFunction, SLOTS.CALL, function (thisArg, argList) {
    return unescape(argList[0]);
});



var ParseIntFunction_call = function (thisArg, argList) {
    return parseInt(""+argList[0], +argList[1]);
};

var ParseFloatFunction_call = function (thisArg, argList) {
    return parseFloat(""+argList[0]);
};
setInternalSlot(ParseIntFunction, SLOTS.CALL, ParseIntFunction_call);

setInternalSlot(ParseFloatFunction, SLOTS.CALL, ParseFloatFunction_call);



//===========================================================================================================
// Math
//============================================================================================================

var PI = Math.PI;
var LOG2E = Math.LOG2E;
var SQRT1_2 = Math.SQRT1_2;
var SQRT2 = Math.SQRT2;
var LN10 = Math.LN10;
var LN2 = Math.LN2;
var LOG10E = Math.LOG10E;
var E = Math.E;

var MathObject_sign = function (thisArg, argList) {
    var x = ToNumber(argList[0]);
    if (isAbrupt(x)) return x;
    return NormalCompletion(x > 0 ? 1 : -1);
};

var MathObject_random = function (thisArg, argList) {
    return NormalCompletion(Math.random());
};

var MathObject_log = function (thisArg, argList) {
    var x = +argList[0];
    return NormalCompletion(Math.log(x));
};
var MathObject_ceil = function (thisArg, argList) {
    var x = +argList[0];
    return NormalCompletion(Math.ceil(x));
};
var MathObject_floor = function (thisArg, argList) {
    var x = +argList[0];
    return NormalCompletion(Math.floor(x));
};
var MathObject_abs = function (thisArg, argList) {
    var a = +argList[0];
    return NormalCompletion(Math.abs(a));
};

var MathObject_pow = function (thisArg, argList) {
    var b = +argList[0];
    var e = +argList[1];
    return NormalCompletion(Math.pow(b, e));
};
var MathObject_sin = function (thisArg, argList) {
    var x = +argList[0];
    return NormalCompletion(Math.sin(x));
};
var MathObject_cos = function (thisArg, argList) {
    var x = +argList[0];
    return NormalCompletion(Math.cos(x));
};
var MathObject_atan = function (thisArg, argList) {
    var x = +argList[0];
    return NormalCompletion(Math.atan(x));
};
var MathObject_atan2 = function (thisArg, argList) {
    var x = +argList[0];
    var y = +argList[1];
    return NormalCompletion(Math.atan2(x,y));
};
var MathObject_max = function (thisArg, argList) {
    var args = CreateListFromArray(argList);
    if (isAbrupt(args)) return args;
    return NormalCompletion(Math.max.apply(Math, args));
};
var MathObject_min = function (thisArg, argList) {
    var args = CreateListFromArray(argList);
    if (isAbrupt(args)) return args;
    return NormalCompletion(Math.min.apply(Math, args));
};
var MathObject_tan = function (thisArg, argList) {
    var x = +argList[0];
    return NormalCompletion(Math.tan(x));
};
var MathObject_exp = function (thisArg, argList) {
    var x = argList[0];
    return NormalCompletion(Math.exp(x));
};
var MathObject_hypot = function (thisArg, argList) {

};
var MathObject_imul = function (thisArg, argList) {

};

var MathObject_log1p = function (thisArg, argList) {

};

var MathObject_clz = function (thisArg, argList) {
    var x = argList[0];
    x = ToNumber(x);
    if (isAbrupt(x = ifAbrupt(x))) return x;
    var n = ToUint32(x);
    if (isAbrupt(n = ifAbrupt(n))) return n;
    if (n < 0) return 0;
    if (n == 0) return 32;
    var bitlen = Math.ceil(Math.log(Math.pow(n, Math.LOG2E)));
    var p = 32 - bitlen;
    return NormalCompletion(p);
};

setInternalSlot(MathObject, SLOTS.MATHTAG, true);
setInternalSlot(MathObject, SLOTS.PROTOTYPE, ObjectPrototype);

LazyDefineBuiltinConstant(MathObject, "PI", PI);
LazyDefineBuiltinConstant(MathObject, "LOG2E", LOG2E);
LazyDefineBuiltinConstant(MathObject, "SQRT1_2", SQRT1_2);
LazyDefineBuiltinConstant(MathObject, "SQRT2", SQRT2);
LazyDefineBuiltinConstant(MathObject, "LN10", LN10);
LazyDefineBuiltinConstant(MathObject, "LN2", LN2);
LazyDefineBuiltinConstant(MathObject, "E", E);
LazyDefineBuiltinConstant(MathObject, "LOG10E", LOG10E);
LazyDefineBuiltinConstant(MathObject, $$toStringTag, "Math");

LazyDefineBuiltinFunction(MathObject, "atan", 2, MathObject_atan);
LazyDefineBuiltinFunction(MathObject, "atan2", 1, MathObject_atan2);
LazyDefineBuiltinFunction(MathObject, "ceil", 1, MathObject_ceil);
LazyDefineBuiltinFunction(MathObject, "clz", 1, MathObject_clz);
LazyDefineBuiltinFunction(MathObject, "cos", 1, MathObject_cos);
LazyDefineBuiltinFunction(MathObject, "exp", 1, MathObject_exp);
LazyDefineBuiltinFunction(MathObject, "floor", 1, MathObject_floor);
LazyDefineBuiltinFunction(MathObject, "hypot", 2, MathObject_hypot);
LazyDefineBuiltinFunction(MathObject, "imul", 2, MathObject_imul);
LazyDefineBuiltinFunction(MathObject, "log", 1, MathObject_log);
LazyDefineBuiltinFunction(MathObject, "log1p", 1, MathObject_log1p);
LazyDefineBuiltinFunction(MathObject, "max", 0, MathObject_max);
LazyDefineBuiltinFunction(MathObject, "min", 0, MathObject_min);
LazyDefineBuiltinFunction(MathObject, "pow", 2, MathObject_pow);
LazyDefineBuiltinFunction(MathObject, "sin", 1, MathObject_sin);
LazyDefineBuiltinFunction(MathObject, "sign", 1, MathObject_sign);
LazyDefineBuiltinFunction(MathObject, "tan", 1, MathObject_tan);
LazyDefineBuiltinFunction(MathObject, "random", 0, MathObject_random);



// ===========================================================================================================
// Number
// ===========================================================================================================

MakeConstructor(NumberConstructor, true, NumberPrototype);

var MIN_INTEGER = Number.MIN_INTEGER;
var MAX_INTEGER = Number.MAX_INTEGER;
var EPSILON = Number.EPSILON;
var MIN_VALUE = Number.MIN_VALUE;
var MAX_VALUE = Number.MAX_VALUE;
var NAN = NaN;
var POSITIVE_INFINITY = Infinity;
var NEGATIVE_INFINITY = -Infinity;

setInternalSlot(NumberConstructor, SLOTS.CALL, function (thisArg, argList) {
    var value = argList[0];
    var O = thisArg;
    var n;
    if (argList.length === 0) n = +0;
    else n = ToNumber(value);
    if (isAbrupt(n = ifAbrupt(n))) return n;
    if (Type(O) === OBJECT && hasInternalSlot(O, SLOTS.NUMBERDATA) && getInternalSlot(O, SLOTS.NUMBERDATA) === undefined) {
        setInternalSlot(O, SLOTS.NUMBERDATA, n);
        return O;
    }
    return n;
});

setInternalSlot(NumberConstructor, SLOTS.CONSTRUCT, function (argList) {
    var F = NumberConstructor;
    return OrdinaryConstruct(F, argList);
});

var NumberConstructor_$$create = function (thisArg, argList) {
    var F = thisArg;
    var obj = OrdinaryCreateFromConstructor(F, INTRINSICS.NUMBERPROTOTYPE, [ SLOTS.NUMBERDATA ]);
    return obj;
};
var NumberConstructor_isFinite = function (thisArg, argList) {
    var number = argList[0];
    if (Type(number) !== NUMBER) return NormalCompletion(false);
    if ((number != number) || number === Infinity || number === -Infinity) return NormalCompletion(false);
    return NormalCompletion(true);
};
var NumberConstructor_isNaN = function (thisArg, argList) {
    var number = argList[0];
    if (Type(number) !== NUMBER) return NormalCompletion(false);
    if (number != number) return NormalCompletion(true);
    return NormalCompletion(false);
};

var NumberConstructor_isInteger = function (thisArg, argList) {
    var number = argList[0];
    if (Type(number) !== NUMBER) return NormalCompletion(false);
    if ((number != number) ||
        number === +Infinity || number === -Infinity) return NormalCompletion(false);
    return NormalCompletion(true);
};

var NumberPrototype_clz = function (thisArg, argList) {
    var x = thisNumberValue(thisArg);
    if (isAbrupt(x = ifAbrupt(x))) return x;
    var n = ToUint32(x);
    if (isAbrupt(n = ifAbrupt(n))) return n;
    if (n < 0) return 0;
    if (n === 0) return 32;
    var bitlen = Math.floor(Math.log(Math.pow(n, Math.LOG2E))) + 1;
    var p = 32 - bitlen;
    return NormalCompletion(p);
};
var NumberPrototype_toString = function (thisArg, argList) {
    var radix = argList[0];
    var radixNumber;
    var x = thisNumberValue(thisArg);
    var s = "";
    if (radix === undefined) radixNumber = 10;
    else radixNumber = ToInteger(radix);
    if (isAbrupt(radixNumber=ifAbrupt(radixNumber))) return radixNumber;
    if (radixNumber < 2 || radixNumber > 36) return newRangeError( "radixNumber has to be between 2 and 36");
    if (radixNumber === 10) return ToString(x);
    else s = ToString(x);

    /*
    var parts = s.split(".");
    var i = 0;
    var result = "";
    while ((i < 2) && (s = parts[i])) {    
	s = parts[i];
	if (i == 1) result += ".";
        var d = Math.floor((+s) / radixNumber);
	var r = (+s) % radixNumber;
        s = ""+d;
        if (r > 10) s += String.fromCharCode(("a").charCodeAt(0) + r - 10);
	else if (r > 0) s += r;
        result += s;
	i += 1;
    }
    */
    var result = x.toString(radixNumber);
    
    return NormalCompletion(result);
};
var NumberPrototype_valueOf = function (thisArg, argList) {
    var x = thisNumberValue(thisArg);
    return NormalCompletion(x);
};
var NumberPrototype_toPrecision = function (thisArg, argList) {
    var precision = argList[0];
    var x = thisNumberValue(thisArg);
    if (isAbrupt(x = ifAbrupt(x))) return x;
    if (precision === undefined) return ToString(x);
    var p = ToInteger(precision);
    if (isAbrupt(p = ifAbrupt(p))) return p;
    if (x !== x) return "NaN";
    var s = "";
    if (x < 0) {
        s = "-";
        x = -x;
    }
    if (x === +Infinity || x === -Infinity) {
        return NormalCompletion(s + "Infinity");
    }

};

function repeatString (str, times) {
    var concat = "";
    for (var i = 0; i < times; i++) {
        concat += str;
    }
    return concat;
}

var NumberPrototype_toFixed = function (thisArg, argList) {
    var fractionDigits = argList[0];
    var x = thisNumberValue(thisArg);
    if (isAbrupt(x = ifAbrupt(x))) return x;
    if (fractionDigits === undefined) return ToString(x);
    var f = ToInteger(fractionDigits);
    if (isAbrupt(f = ifAbrupt(f))) return f;
    if ((f < 0) || (f > 20)) return newRangeError( "fractionDigits is less or more than 20");
    if (x !== x) return "NaN";
    var s = "";
    if (x < 0) {
        s = "-";
        x = -x;
    }
    if (x >= 1021) {
        var m = ToString(x);
    } else {
        var n;
        if (n === 0) m = "0";
        else m = ""+n;
        if (f != 0) {
            var k = Math.ceil(Math.log(Math.pow(n, Math.LOG2E))); // = number of elements in n
            if (k <= f)  {
                var z = repeatString(0x0030, f+1-k);
                m = z + m;
                k = f + 1;
            }
            var a = m.substr(0, k-f);
            var b = m.substr(k-f);
            m = a + "." + b;
        }
    }
    return NormalCompletion(s + m);
};
var NumberPrototype_toExponential = function (thisArg, argList) {
    var fractionDigits = argList[0];
    var x = thisNumberValue(thisArg);
    if (isAbrupt(x = ifAbrupt(x))) return x;
    var f = ToInteger(fractionDigits);
    if (isAbrupt(f = ifAbrupt(f))) return f;
    if (x !== x) return "NaN";
    var s = "";
    if (x < 0) {
        s = "-";
        x = -x;
    }
    var n;
    if (x === Infinity || s === -Infinity) {
        return s + "Infinity";
    }
    if (fractionDigits !== undefined && ((f < 0) || (f > 20))) return newRangeError( "toExponential: fractionDigits < 0 or > 20");
    if (x === 0) {
        if (fractionDigits === undefined) f = 0;
        var m = stringRepeat(0x0030, f+1);
        var e = 0;
    } else {
        if (fractionDigits !== undefined) {

            // ich konnte das im mcview nicht lesen ob 10f oder 10^f
            // ich hab das unterwegs geschrieben, todo
            e;
            n;
        } else {
            e;
            n;
        }
        m = ""+n;
    }
    if (f != 0) {
        var a = m.substr(m, 1);
        var b = m.substr(1);
    }
    if (e === 0) {
        var c = "+";
        var d = "0";
    } else {
        if (e > 0) c = "+";
        else if (e <= 0) {
            c = "-";
            e = -e;
        }
        d = ""+e;
        m = m + "e" + c + d;
    }
    return NormalCompletion(s + m)
};

LazyDefineBuiltinFunction(NumberConstructor, "isFinite", 0, NumberConstructor_isFinite);
LazyDefineBuiltinFunction(NumberConstructor, "isNaN", 0, NumberConstructor_isNaN);
LazyDefineBuiltinFunction(NumberConstructor, "isInteger", 0, NumberConstructor_isInteger);
LazyDefineBuiltinFunction(NumberConstructor, $$create, 0, NumberConstructor_$$create);
LazyDefineBuiltinConstant(NumberConstructor, "EPSILON", EPSILON);
LazyDefineBuiltinConstant(NumberConstructor, "MIN_INTEGER", MIN_INTEGER);
LazyDefineBuiltinConstant(NumberConstructor, "MIN_VALUE", MIN_VALUE);
LazyDefineBuiltinConstant(NumberConstructor, "MAX_INTEGER", MAX_INTEGER);
LazyDefineBuiltinConstant(NumberConstructor, "MAX_VALUE", MAX_VALUE);
LazyDefineBuiltinConstant(NumberConstructor, "NaN", NAN);
LazyDefineBuiltinConstant(NumberConstructor, "NEGATIVE_INFINITY", NEGATIVE_INFINITY);

LazyDefineBuiltinFunction(NumberPrototype, "clz", 0, NumberPrototype_clz);
LazyDefineBuiltinFunction(NumberPrototype, "toExponential", 0, NumberPrototype_toExponential);
LazyDefineBuiltinFunction(NumberPrototype, "toFixed", 0, NumberPrototype_toFixed);
LazyDefineBuiltinFunction(NumberPrototype, "toPrecision", 0, NumberPrototype_toPrecision);
LazyDefineBuiltinFunction(NumberPrototype, "toString", 0, NumberPrototype_toString);
LazyDefineBuiltinFunction(NumberPrototype, "valueOf", 0, NumberPrototype_valueOf);

LazyDefineBuiltinConstant(NumberPrototype, $$toStringTag, "Number");

function isProxy(o) {
    return o instanceof ProxyExoticObject;
}

function ProxyCreate(target, handler) {
    var proxy = ProxyExoticObject();
    setInternalSlot(proxy, SLOTS.PROTOTYPE, ProxyPrototype);
    setInternalSlot(proxy, SLOTS.PROXYTARGET, target);
    setInternalSlot(proxy, SLOTS.PROXYHANDLER, handler);
    if (!IsConstructor(target)) setInternalSlot(proxy, SLOTS.CONSTRUCT, undefined);
    return proxy;
}

MakeConstructor(ProxyConstructor, true, ProxyPrototype);

var ProxyConstructor_revocable = function revocable(thisArg, argList) {
    var target = argList[0];
    var handler = argList[1];

    var revoker = CreateBuiltinFunction(realm, function revoke(thisArg, argList) {
        var p = getInternalSlot(revoker, SLOTS.REVOKABLEPROXY);
        if (p === null) return NormalCompletion(undefined);
        setInternalSlot(revoker, SLOTS.REVOKABLEPROXY, null);
        Assert(isProxy(p), "revoke: object is not a proxy");
        setInternalSlot(p, SLOTS.PROXYTARGET, null);
        setInternalSlot(p, SLOTS.PROXYHANDLER, null);
        return NormalCompletion(undefined);
    });

    var proxy = ProxyCreate(target, handler);
    setInternalSlot(revoker, SLOTS.REVOKABLEPROXY, proxy);
    var result = ObjectCreate();
    CreateDataProperty(result, "proxy", proxy);
    CreateDataProperty(result, "revoke", revoker);
    return NormalCompletion(result);
};

var ProxyConstructor_Call = function (thisArg, argList) {
    return newTypeError(format("PROXY_CALL_ERROR"));
};

var ProxyConstructor_Construct = function (argList) {
    var target = argList[0];
    var handler = argList[1];
    return ProxyCreate(target, handler);
};

LazyDefineBuiltinFunction(ProxyConstructor, "revocable", 2, ProxyConstructor_revocable);
setInternalSlot(ProxyConstructor, SLOTS.CALL, ProxyConstructor_Call);
setInternalSlot(ProxyConstructor, SLOTS.CONSTRUCT, ProxyConstructor_Construct);


function reflect_parse_transformASTtoOrdinaries(node, options) {
    var success;
    var newNode;
    var loc = options && options.loc;
    if (Array.isArray(node)) newNode = ArrayCreate(0);
    else newNode = ObjectCreate();
    var current;
    var value;
    for (var k in node) {
        if (!loc && k === "loc") continue;
        if (Object.hasOwnProperty.call(node, k)) {
            current = node[k];
            if (current && typeof current === "object") {
                value = reflect_parse_transformASTtoOrdinaries(current);
            } else {
                value = current;
            }
            success = DefineOwnProperty(newNode, k, {
                value: value,
                writable: true,
                enumerable: true,
                configurable: true
            });
            if (isAbrupt(success)) return success;
        }
    }
    return newNode;
}


var ReflectObject_parse = function (thisArg, argList) {
    var parse = require("parser");
    var parseGoal = parse.parseGoal;
    var source = argList[0];
    var options = argList[1];
    var jsAst, newAst, message;
    if (Type(source) !== STRING) return newTypeError( "String to parse expected");
    try {
        jsAst = parse(source);
    } catch (ex) {
        message = ex.message;
        return newSyntaxError( message);
    }
    newAst = reflect_parse_transformASTtoOrdinaries(jsAst, options);
    if (isAbrupt(newAst = ifAbrupt(newAst))) return newAst;
    return NormalCompletion(newAst);
};

var ReflectObject_parseGoal = function (thisArg, argList) {
    var parse = require("parser");
    var parseGoal = parse.parseGoal;
    var source = argList[1];
    var goal = argList[0];
    var jsAst, newAst, message;

    if (Type(goal) !== STRING) return newTypeError( "Goal to parse expected");
    if (Type(source) !== STRING) return newTypeError( "String to parse expected");
    try {
        jsAst = parseGoal(goal, source);
    } catch (ex) {
        message = ex.message;
        return newSyntaxError( message);
    }
    newAst = reflect_parse_transformASTtoOrdinaries(jsAst);
    if (isAbrupt(newAst = ifAbrupt(newAst))) return newAst;
    return NormalCompletion(newAst);
};


var ReflectObject_getPrototypeOf = function (thisArg, argList) {
    var target = argList[0];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    return GetPrototypeOf(obj);
};

var ReflectObject_setPrototypeOf = function (thisArg, argList) {
    var target = argList[0];
    var proto = argList[1];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    if (Type(proto) !== OBJECT && proto !== null) return newTypeError( "Reflect.setPrototypeOf: proto is neither an object nor null!");
    return SetPrototypeOf(obj, proto);
};


var ReflectObject_isExtensible = function (thisArg, argList) {
    var target = argList[0];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    return IsExtensible(obj);
};

var ReflectObject_preventExtensions = function (thisArg, argList) {
    var target = argList[0];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    return PreventExtensions(obj);
};
var ReflectObject_has = function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    return HasProperty(obj, key);
};
var ReflectObject_hasOwn = function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    return HasOwnProperty(obj, key);
};

var ReflectObject_getOwnPropertyDescriptor = function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    var desc = GetOwnProperty(obj, key);
    if (isAbrupt(desc = ifAbrupt(desc))) return desc;
    return FromPropertyDescriptor(desc);
};

var ReflectObject_get = function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var receiver = argList[2];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    if (receiver === undefined) receiver = target;
    return obj.Get(key, receiver);
};

var ReflectObject_set =function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var V = argList[2];
    var receiver = argList[3];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    if (receiver === undefined) receiver = target;
    return callInternalSlot(SLOTS.SET, obj, key, V, receiver);
};
var ReflectObject_invoke = function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var argumentList = argList[2];
    var receiver = argList[3];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    if (receiver === undefined) receiver = target;
    var A = CreateListFromArrayLike(argumentList);
    return obj.Invoke(key, A, receiver);
};
var ReflectObject_deleteProperty = function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    return callInternalSlot("Delete", obj, key);
};
var ReflectObject_defineProperty = function (thisArg, argList) {
    var target = argList[0];
    var propertyKey = argList[1];
    var attributes = argList[2];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(propertyKey);
    if (isAbrupt(key = ifAbrupt(key))) return key;
    var desc = ToPropertyDescriptor(attributes);
    if (isAbrupt(desc = ifAbrupt(desc))) return desc;
    return callInternalSlot(SLOTS.DEFINEOWNPROPERTY, obj,key, desc);
};
var ReflectObject_enumerate = function (thisArg, argList) {
    var target = argList[0];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    return callInternalSlot(SLOTS.ENUMERATE, obj);
};
var ReflectObject_ownKeys = function (thisArg, argList) {
    var target = argList[0];
    var obj = ToObject(target);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    return callInternalSlot("OwnPropertyKeys", obj);
};


LazyDefineBuiltinFunction(ReflectObject, "defineProperty", 2, ReflectObject_defineProperty);
LazyDefineBuiltinFunction(ReflectObject, "deleteProperty", 3, ReflectObject_deleteProperty);
LazyDefineBuiltinFunction(ReflectObject, "enumerate", 1, ReflectObject_enumerate);
LazyDefineBuiltinFunction(ReflectObject, "invoke", 3, ReflectObject_invoke);
LazyDefineBuiltinFunction(ReflectObject, "isExtensible", 1, ReflectObject_isExtensible);
LazyDefineBuiltinFunction(ReflectObject, "get", 2, ReflectObject_get);
LazyDefineBuiltinFunction(ReflectObject, "getOwnPropertyDescriptor", 2, ReflectObject_getOwnPropertyDescriptor);
LazyDefineBuiltinFunction(ReflectObject, "getPrototypeOf", 1, ReflectObject_getPrototypeOf);
LazyDefineBuiltinFunction(ReflectObject, "has", 2, ReflectObject_has);
LazyDefineBuiltinFunction(ReflectObject, "hasOwn", 2, ReflectObject_hasOwn);
LazyDefineProperty(ReflectObject, SLOTS.LOADER, LoaderConstructor);
LazyDefineBuiltinFunction(ReflectObject, "ownKeys", 1, ReflectObject_ownKeys);
LazyDefineBuiltinFunction(ReflectObject, "parse", 1, ReflectObject_parse);
LazyDefineBuiltinFunction(ReflectObject, "parseGoal", 1, ReflectObject_parseGoal);
LazyDefineBuiltinFunction(ReflectObject, "preventExtensions", 1, ReflectObject_preventExtensions);
LazyDefineProperty(ReflectObject, SLOTS.REALM, RealmConstructor);
LazyDefineBuiltinFunction(ReflectObject, "set", 3, ReflectObject_set);
LazyDefineBuiltinFunction(ReflectObject, "setPrototypeOf", 2, ReflectObject_setPrototypeOf);
LazyDefineBuiltinConstant(ReflectObject, $$toStringTag, "Reflect");

var ReflectObject_getIntrinsic = function (thisArg, argList) {
    var intrinsic = ToString(argList[0]);
    if (isAbrupt(intrinsic=ifAbrupt(intrinsic))) return intrinsic;
    return getIntrinsic(intrinsic);
};

LazyDefineBuiltinFunction(ReflectObject, "getIntrinsic", 1, ReflectObject_getIntrinsic);

var ReflectObject_createSelfHostingFunction = function(thisArg, argList) {
   var parseGoal = require("parser").parseGoal;
   var source = argList[0];
   var realm = argList[1];
   try {
       var fn = parseGoal("FunctionDeclaration", source);
   } catch (ex) {
       return newSyntaxError( ex.message);
   }
   var realmObject = realm === undefined ? getRealm() : getInternalSlot(realm, "RealmObject");
   var F = OrdinaryFunction();
   setInternalSlot(F, SLOTS.CODE, fn.body);
   setInternalSlot(F, SLOTS.FORMALPARAMETERS, fn.params);
   setInternalSlot(F, SLOTS.STRICT, !!fn.strict);
   setInternalSlot(F, SLOTS.REALM, realmObject);
   return NormalCompletion(F);
};
LazyDefineBuiltinFunction(ReflectObject, "createSelfHostingFunction", 2, ReflectObject_createSelfHostingFunction);


// ===========================================================================================================
// IsNaN
// ===========================================================================================================

IsNaNFunction = CreateBuiltinFunction(realm, function isNaN(thisArg, argList) {
    var nan = ToNumber(argList[0]);
    return nan !== nan;
}, 1, "isNaN");

// ===========================================================================================================
// IsFinite
// ===========================================================================================================

IsFiniteFunction = CreateBuiltinFunction(realm, function isFinite(thisArg, argList) {
    var number = ToNumber(argList[0]);
    return  !(number == Infinity || number == -Infinity || number != number);
}, 1, "isFinite");

// ===========================================================================================================
// Object
// ===========================================================================================================
var ObjectConstructor_assign = function (thisArg, argList) {
    var target = argList[0];
    var source = argList[1];
    var to = ToObject(target);
    if (isAbrupt(to = ifAbrupt(to))) return to;
    var from = ToObject(source);
    if (isAbrupt(source = ifAbrupt(source))) return source;
    var keys = OwnPropertyKeys(source);
    if (isAbrupt(keys = ifAbrupt(keys))) return keys;
    var gotAllNames = false;
    var pendingException = undefined;
    var next, nextKey, desc, propValue, status;
    while (!gotAllNames) {
        next = IteratorStep(keys);
        if (isAbrupt(next = ifAbrupt(next))) return next;
        if (!next) gotAllNames = true;
        else {
            nextKey = IteratorValue(next);
            if (isAbrupt(nextKey = ifAbrupt(nextKey))) return nextKey;
            desc = GetOwnProperty(from, nextKey);
            if (isAbrupt(desc)) pendingException = desc;
            else if (desc !== undefined && desc.enumerable === true) {
                propValue = Get(from, nextKey);
                if (isAbrupt(propValue)) pendingException = propValue;
                else {
                    status = Put(to, nextKey, propValue, true);
                    if (isAbrupt(status)) pendingException = status;
                }
            }
        }
    }
    if (pendingException !== undefined) return pendingException;
    return to;
};
var ObjectConstructor_create = function (thisArg, argList) {
    var O = argList[0];
    var Properties = argList[1];
    if (Type(O) !== OBJECT && Type(O) !== NULL) return newTypeError( "create: argument is not an object or null");
    var obj = ObjectCreate(O);
    if (Properties !== undefined) {
        return ObjectDefineProperties(obj, Properties);
    }
    return obj;
};
var ObjectConstructor_defineProperty = function (thisArg, argList) {
    var O = argList[0];
    var P = argList[1];
    var Attributes = argList[2];
    if (Type(O) !== OBJECT) return newTypeError( "defineProperty: argument 1 is not an object");
    var key = ToPropertyKey(P);
    var desc = ToPropertyDescriptor(Attributes);
    if (isAbrupt(desc = ifAbrupt(desc))) return desc;
    var success = DefineOwnPropertyOrThrow(O, key, desc);
    if (isAbrupt(success = ifAbrupt(success))) return success;
    return O;
};
var ObjectConstructor_defineProperties = function (thisArg, argList) {
    var O = argList[0];
    var Properties = argList[1];
    return ObjectDefineProperties(O, Properties);
};




var ObjectConstructor_call = function Call(thisArg, argList) {
    var value = argList[0];
    if (value === null || value === undefined) return ObjectCreate();
    return ToObject(value);
};

var ObjectConstructor_construct = function (argList) {
    var value = argList[0];
    var type = Type(value);
    switch (type) {
        case OBJECT:
            return value;
        case STRING:
        case NUMBER:
        case SYMBOL:
        case BOOLEAN:
            return ToObject(value);
    }
    return ObjectCreate();
};

setInternalSlot(ObjectConstructor, SLOTS.CALL, ObjectConstructor_call);
setInternalSlot(ObjectConstructor, SLOTS.CONSTRUCT, ObjectConstructor_construct);

var ObjectConstructor_seal = function (thisArg, argList) {
        var O;
        O = argList[0];
        if (Type(O) !== OBJECT) return newTypeError( "First argument is object");
        var status = SetIntegrityLevel(O, "sealed");
        if (isAbrupt(status = ifAbrupt(status))) return status;
        if (status === false) return newTypeError( "seal: can not seal object");
        return O;
};


var ObjectConstructor_freeze =function (thisArg, argList) {
    var O;
    O = argList[0];
    if (Type(O) !== OBJECT) return newTypeError( "First argument is object");
    var status = SetIntegrityLevel(O, "frozen");
    if (isAbrupt(status = ifAbrupt(status))) return status;
    if (status === false) return newTypeError( "freeze: can not freeze object");
    return O;
};

var ObjectConstructor_getOwnPropertyDescriptor = function (thisArg, argList) {
    var O = argList[0];
    var P = argList[1];
    var obj = ToObject(O);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var key = ToPropertyKey(P);
    var desc = GetOwnProperty(obj, key);
    if (isAbrupt(desc = ifAbrupt(desc))) return desc;
    return FromPropertyDescriptor(desc);
};
var ObjectConstructor_getOwnPropertyNames = function (thisArg, argList) {
    var O = argList[0];
    return GetOwnPropertyKeys(O, "string");
};

var ObjectConstructor_getOwnPropertySymbols =     function (thisArg, argList) {
        var O = argList[0];
        return GetOwnPropertyKeys(O, "symbol");
};
var ObjectConstructor_getPrototypeOf = function (thisArg, argList) {
        var O = argList[0];
        var obj = ToObject(O);
        if (isAbrupt(obj = ifAbrupt(obj))) return obj;
        return GetPrototypeOf(obj);
};
var ObjectConstructor_is = function (thisArg, argList) {
        var value1 = argList[0];
        var value2 = argList[1];
        return SameValue(value1, value2);
};
var ObjectConstructor_isExtensible = function (thisArg, argList) {
        var O = argList[0];
        if (Type(O) !== OBJECT) return false;
        return IsExtensible(O);
};

var ObjectConstructor_isSealed = function (thisArg, argList) {
        var O = argList[0];
        if (Type(O) !== OBJECT) return true;
        return TestIntegrityLevel(O, "sealed");
};

var ObjectConstructor_isFrozen = function (thisArg, argList) {
        var O = argList[0];
        if (Type(O) !== OBJECT) return true;
        return TestIntegrityLevel(O, "frozen");
};


var ObjectConstructor_preventExtensions = function (thisArg, argList) {
    var O = argList[0];
    if (Type(O) !== OBJECT) return newTypeError( "argument is not an object");
    var status = PreventExtensions(O);
    if (isAbrupt(status = ifAbrupt(status))) return status;
    if (status === false) return newTypeError( "can not prevent extensions");
    return O;
};


var ObjectConstructor_keys = function (thisArg, argList) {
    var O = argList[0];
    var obj = ToObject(O);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var keys = OwnPropertyKeys(O);
    if (isAbrupt(keys = ifAbrupt(keys))) return keys;

    var nameList = [];
    var gotAllNames = false;
    var next, nextKey, desc;
    while (!gotAllNames) {
        next = IteratorNext(keys);
        if (isAbrupt(next = ifAbrupt(next))) return next;
        nextKey = IteratorValue(next);
        if (isAbrupt(nextKey = ifAbrupt(nextKey))) return nextKey;
        if (Type(nextKey) === STRING) {
            desc = GetOwnProperty(O, nextKey);
            if (isAbrupt(desc = ifAbrupt(desc))) return desc;
            if (desc !== undefined && desc.enumerable === true) {
                nameList.push(nextKey);
            }
        }

        if (IteratorComplete(next)) gotAllNames = true;
    }
    return CreateArrayFromList(nameList);
};

var ObjectConstructor_mixin = function (thisArg, argList) {
    var target = argList[0];
    var source = argList[1];
    var to = ToObject(target);
    if (isAbrupt(to = ifAbrupt(to))) return to;
    var from = ToObject(source);
    if (isAbrupt(from = ifAbrupt(from))) return from;
    return MixinProperties(to, from);
};

//SetFunctionName(ObjectConstructor, "Object");
//SetFunctionLength(ObjectConstructor, 1);
LazyDefineBuiltinFunction(ObjectConstructor, "assign", 2, ObjectConstructor_assign);
LazyDefineBuiltinFunction(ObjectConstructor, "create", 0, ObjectConstructor_create);
LazyDefineBuiltinFunction(ObjectConstructor, "defineProperty", 0, ObjectConstructor_defineProperty);
LazyDefineBuiltinFunction(ObjectConstructor, "defineProperties", 0, ObjectConstructor_defineProperties);
LazyDefineBuiltinFunction(ObjectConstructor, "freeze", 1, ObjectConstructor_freeze);
LazyDefineBuiltinFunction(ObjectConstructor, "getOwnPropertyDescriptor", 2, ObjectConstructor_getOwnPropertyDescriptor);
LazyDefineBuiltinFunction(ObjectConstructor, "getOwnPropertyNames", 1, ObjectConstructor_getOwnPropertyNames);
LazyDefineBuiltinFunction(ObjectConstructor, "getOwnPropertySymbols", 1, ObjectConstructor_getOwnPropertySymbols);
LazyDefineBuiltinFunction(ObjectConstructor, "getPrototypeOf", 1, ObjectConstructor_getPrototypeOf);
LazyDefineBuiltinFunction(ObjectConstructor, "keys", 1, ObjectConstructor_keys);
LazyDefineBuiltinFunction(ObjectConstructor, "mixin", 2, ObjectConstructor_mixin);
LazyDefineBuiltinFunction(ObjectConstructor, "is", 1, ObjectConstructor_is);
LazyDefineBuiltinFunction(ObjectConstructor, "isExtensible", 1, ObjectConstructor_isExtensible);
LazyDefineBuiltinFunction(ObjectConstructor, "isSealed", 1, ObjectConstructor_isSealed);
LazyDefineBuiltinFunction(ObjectConstructor, "isFrozen", 1, ObjectConstructor_isFrozen);
LazyDefineBuiltinFunction(ObjectConstructor, "preventExtensions", 1, ObjectConstructor_preventExtensions);
LazyDefineBuiltinFunction(ObjectConstructor, "seal", 2, ObjectConstructor_seal);

function MixinProperties(target, source) {
    Assert(Type(target) === OBJECT);
    Assert(Type(source) === OBJECT);
    var keys = OwnPropertyKeys(source);
    if (isAbrupt(keys = ifAbrupt(keys))) return keys;
    var gotAllNames = false;
    var pendingException = undefined;
    var next, nextKey, desc, propValue, newFunc;
    var pendingException, getter, setter;
    while (!gotAllNames) {
        next = IteratorStep(next);
        if (isAbrupt(next = ifAbrupt(next))) return next;
        //    if ((=ifAbrupt()) && isAbrupt()) return ;
        if (!next) gotAllNames = true;
        else {
            nextKey = IteratorValue(next);
            if (isAbrupt(nextKey = ifAbrupt(nextKey))) return nextKey;
            var desc = GetOwnProperty(source, nextKey);
            if (isAbrupt(desc)) pendingException = desc;
            else if (desc !== undefined && desc.enumerable === true) {
                // possibly neccessary (if desc isnt fresh)
                // desc = assign({}, desc);
                if (IsDataDescriptor(desc)) {
                    propValue = desc.Value;
                    if (SameValue(GetSuperBinding(propValue), source)) {
                        newFunc = MixinProperties(RebindSuper(propValue, target), propValue);
                        if (isAbrupt(newFunc)) pendingException = newFunc;
                        else desc.Value = newFunc;
                    }
                } else {
                    getter = desc.get;
                    if (SameValue(GetSuperBinding(getter), source)) {
                        newFunc = MixinProperties(RebindSuper(propValue, target), getter);
                        if (isAbrupt(newFunc)) pendingException = newFunc;
                        else desc.get = newFunc;
                    }
                    setter = desc.set;
                    if (SameValue(GetSuperBinding(setter), source)) {
                        newFunc = MixinProperties(RebindSuper(propValue, target), setter);
                        if (isAbrupt(newFunc)) pendingException = newFunc;
                        else desc.set = newFunc;
                    }
                }
                var status = DefineOwnPropertyOrThrow(target, nextKey, desc);
                if (isAbrupt(status)) pendingException = status;
            }
        }
    }
    if (pendingException) return pendingException;
    return target;
}


/*
    What a mess for refactoring. 2 styles and both deprecated behind the next 
*/

var ObjectConstructor_getOwnPropertyDescriptors = function (thisArg, argList) {
    /*
	http://gist.github.com/WebReflection/9353781
	Object.getOwnPropertyDescriptors
    */
    var O = argList[0];
    var obj = ToObject(O);
    if (isAbrupt(obj = ifAbrupt(obj))) return obj;
    var keys = OwnPropertyKeys(obj);
    if (isAbrupt(keys = ifAbrupt(keys))) return keys;
    var descriptors = ObjectCreate(getIntrinsic(INTRINSICS.OBJECTPROTOTYPE));
    var gotAllNames = false;
    while (gotAllNames === false) {
	var next = IteratorStep(keys);
	if (isAbrupt(next=ifAbrupt(next))) return next;
	if (next === false) gotAllNames = true;
	else {
	    var nextKey = IteratorValue(next);
	    nextKey = ToPropertyKey(nextKey);
	    if (isAbrupt(nextKey=ifAbrupt(nextKey))) return nextKey;
	    var desc = callInternalSlot(SLOTS.GETOWNPROPERTY, obj, nextKey);
	    if (isAbrupt(desc=ifAbrupt(desc))) return desc;
	    var descriptor = FromPropertyDescriptor(desc);
	    if (isAbrupt(descriptor=ifAbrupt(descriptor))) return descriptor;
	    var status = CreateDataProperty(descriptors, nextKey, descriptor);
	    // Assert(!isAbrupt(status));
	    if (isAbrupt(status)) return status; 
	}
    }
    return descriptors;
};	

LazyDefineBuiltinFunction(ObjectConstructor, "getOwnPropertyDescriptors", 1, ObjectConstructor_getOwnPropertyDescriptors);

// ===========================================================================================================
// ObjectPrototype
// ===========================================================================================================

MakeConstructor(ObjectConstructor, true, ObjectPrototype);
setInternalSlot(ObjectPrototype, SLOTS.PROTOTYPE, null);

var ObjectPrototype_$$create = function (thisArg, argList) {
    var F = thisArg;
    var proto = GetPrototypeFromConstructor(F, INTRINSICS.OBJECTPROTOTYPE);
    if (isAbrupt(proto = ifAbrupt(proto))) return proto;
    return ObjectCreate(proto);
};

var ObjectPrototype_hasOwnProperty = function (thisArg, argList) {
    var P = ToPropertyKey(argList[0]);
    if (isAbrupt(P = ifAbrupt(P))) return P;
    var O = ToObject(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    return HasOwnProperty(O, P);
};

var ObjectPrototype_isPrototypeOf = function (thisArg, argList) {
    var V = argList[0];
    if (Type(O) !== OBJECT) return false;
    var O = ToObject(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    for (;;) {
        V = GetPrototypeOf(V);
        if (V == null) return false;
        if (SameValue(O, V)) return true;
    }

};


var ObjectPrototype_propertyIsEnumerable = function (thisArg, argList) {
    var V = argList[0];
    var P = ToString(V);
    if (isAbrupt(P = ifAbrupt(P))) return P;
    var O = ToObject(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var desc = GetOwnProperty(O, P);
    if (desc === undefined) return false;
    return desc.enumerable;
};

var OneOfTheseTags = {
    __proto__: null,
    "Arguments": true,
    "Array": true,
    "Boolean": true,
    "Date": true,
    "Error": true,
    "Function": true,
    "JSON": true,
    "Math": true,
    "Number": true,
    "RegExp": true,
    "String": true
};

var builtinTagsByToString = {
    "[object ArrayExoticObject]": "Array",
    "[object ProxyExoticObject]": "Proxy",
    "[object ArgumentsExoticObject]": "Arguments",
    "[object OrdinaryFunction]": "Function",
    "[object StringExoticObject]": "String"
};


var ObjectPrototype_toString = function toString(thisArg, argList) {
    var i = 0;
    if (thisArg === undefined) return "[object Undefined]";
    if (thisArg === null) return "[object Null]";

    var O = ToObject(thisArg);
    var builtinTag, tag;

    var intrToStr = O.toString();

    if (builtinTag = builtinTagsByToString[intrToStr]) {}
    else if (hasInternalSlot(O, SLOTS.SYMBOLDATA)) builtinTag = "Symbol";
    else if (hasInternalSlot(O, SLOTS.STRINGDATA)) builtinTag = "String";
    else if (hasInternalSlot(O, SLOTS.ERRORDATA)) builtinTag = "Error";
    else if (hasInternalSlot(O, SLOTS.BOOLEANDATA)) builtinTag = "Boolean";
    else if (hasInternalSlot(O, SLOTS.NUMBERDATA)) builtinTag = "Number";
    else if (hasInternalSlot(O, SLOTS.DATEVALUE)) builtinTag = "Date";
    else if (hasInternalSlot(O, SLOTS.REGEXPMATCHER)) builtinTag = "RegExp";
    else if (hasInternalSlot(O, SLOTS.MATHTAG)) builtinTag = "Math";
    else if (hasInternalSlot(O, SLOTS.JSONTAG)) builtinTag = "JSON";
    else builtinTag = "Object";

    var hasTag = HasProperty(O, $$toStringTag);
    if (isAbrupt(hasTag = ifAbrupt(hasTag))) return hasTag;
    if (!hasTag) tag = builtinTag;
    else {
        tag = Get(O, $$toStringTag);
        if (isAbrupt(tag)) tag = NormalCompletion("???");
        tag = unwrap(tag);
        if (Type(tag) !== STRING) tag = "???";
        if (OneOfTheseTags[tag] && (!SameValue(tag, builtinTag))) tag = "~" + tag;
    }
    return "[object " + tag + "]";
};

var ObjectPrototype_valueOf = function valueOf(thisArg, argList) {
    var O = ToObject(thisArg);
    return O;
};

// B.2.2.1  Object.prototype.__proto__

var ObjectPrototype_get_proto = function (thisArg, argList) {
    var O = ToObject(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    return callInternalSlot(SLOTS.GETPROTOTYPEOF, O);
};
var ObjectPrototype_set_proto = function (thisArg, argList) {
    var proto = argList[0];
    var O = CheckObjectCoercible(thisArg);
    if (isAbrupt(O = ifAbrupt(O))) return O;
    var protoType = Type(proto);
    if (protoType !== OBJECT && protoType !== null) return proto;
    if (Type(O) !== OBJECT) return proto;
    var status = callInternalSlot(SLOTS.SETPROTOTYPEOF, O, proto);
    if (isAbrupt(status = ifAbrupt(status))) return status;
    if (status === false) return newTypeError( "__proto__: SetPrototypeOf failed.");
    return proto;
};
var ObjectPrototype_proto_ = {
    __proto__:null,
    configurable: true,
    enumerable: false,
    get: CreateBuiltinFunction(realm, ObjectPrototype_get_proto, "get __proto__", 0),
    set: CreateBuiltinFunction(realm, ObjectPrototype_set_proto, "set __proto___", 0)
};
DefineOwnProperty(ObjectPrototype, "__proto__", ObjectPrototype_proto_);


LazyDefineBuiltinFunction(ObjectPrototype, $$create, 0, ObjectPrototype_$$create);
LazyDefineBuiltinFunction(ObjectPrototype, "hasOwnProperty", 0, ObjectPrototype_hasOwnProperty);
LazyDefineBuiltinFunction(ObjectPrototype, "isPrototypeOf", 0, ObjectPrototype_isPrototypeOf);
LazyDefineBuiltinFunction(ObjectPrototype, "propertyIsEnumerable", 0, ObjectPrototype_propertyIsEnumerable);
LazyDefineBuiltinFunction(ObjectPrototype, "toString", 0, ObjectPrototype_toString);
LazyDefineBuiltinFunction(ObjectPrototype, "valueOf", 0, ObjectPrototype_valueOf);
LazyDefineProperty(ObjectPrototype, $$toStringTag, "Object");

// ===========================================================================================================
// Object.observe
// ===========================================================================================================

// Object.observe
// http://wiki.ecmascript.org/doku.php?id=harmony:observe
// var NotifierPrototype is defined with all other intrinsics above

DefineOwnProperty(NotifierPrototype, "notify", {
    value: CreateBuiltinFunction(realm, function notify(thisArg, argList) {
        var changeRecord = argList[0];
        var notifier = thisArg;
        if (Type(notifier) !== OBJECT) return newTypeError( "Notifier is not an object.");
        var target = getInternalSlot(notifier, SLOTS.TARGET);
        var newRecord = ObjectCreate();
        var status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, newRecord, "object", {
            value: target,
            writable: false,
            enumerable: true,
            configurable: false
        });
        //if (isAbrupt(status)) return status;

        var bindings = getInternalSlot(changeRecord, SLOTS.BINDINGS);
        var value;
        for (var N in bindings) {
            if (Object.hasOwnProperty.call(bindings, N)) {
                if (N !== "object") {
                    value = callInternalSlot(SLOTS.GET, changeRecord, N, changeRecord);
                    if (isAbrupt(value = ifAbrupt(value))) return value;
                    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, newRecord, N, {
                        value: value,
                        writable: false,
                        enumerable: true,
                        configurable: false
                    });
                    //if (isAbrupt(status)) return status;
                }

            }
        }
        setInternalSlot(newRecord, SLOTS.EXTENSIBLE, false);
        status = EnqueueChangeRecord(target, newRecord);
        //if (isAbrupt(status)) return status;
        return NormalCompletion();
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(NotifierPrototype, "performChange", {
    value: CreateBuiltinFunction(realm, function notify(thisArg, argList) {
        var changeType = argList[0];
        var changeFn = argList[1];
        var notifier = thisArg;
        var status;
        if (Type(notifier) !== OBJECT) return newTypeError( "notifier is not an object");
        var target = getInternalSlot(notifier, SLOTS.TARGET);
        if (target === undefined) return NormalCompletion(undefined);
        if (Type(changeType) !== STRING) return newTypeError( "changeType has to be a string");
        if (!IsCallable(changeFn)) return newTypeError( "changeFn is not a callable");
        status = BeginChange(target, changeType);
        var changeRecord = callInternalSlot(SLOTS.CALL, changeFn, undefined, []);
        status = EndChange(target, changeType);
        var changeObservers = getInternalSlot(notifier, SLOTS.CHANGEOBSERVERS);
        if (!changeObservers.length) return NormalCompletion();
        var newRecord = ObjectCreate();
        status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, newRecord, "object", {
            value: target,
            writable: false,
            enumerable: true,
            configurable: false
        });
        status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, newRecord, "type", {
            value: changeType,
            writable: false,
            enumerable: true,
            configurable: false
        });
        var bindings = getInternalSlot(changeRecord, SLOTS.BINDINGS);
        var value;
        for (var N in bindings) {
            if (Object.hasOwnProperty.call(bindings, N)) {
                if (N !== "object" && N !== "type") {
                    value = callInternalSlot(SLOTS.GET, changeRecord, N, changeRecord);
                    if (isAbrupt(value = ifAbrupt(value))) return value;
                    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, newRecord, N, {
                        value: value,
                        writable: false,
                        enumerable: true,
                        configurable: false
                    });
                    //if (isAbrupt(status)) return status;
                }
            }
        }
        setInternalSlot(newRecord, SLOTS.EXTENSIBLE, false);
        status = EnqueueChangeRecord(target, newRecord);
        return NormalCompletion(undefined);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

function GetNotifier(O) {
    var proto;
    var notifier = getInternalSlot(O, SLOTS.NOTIFIER);
    if (notifier === undefined) {
        proto = Get(getIntrinsics(), "NotifierPrototype%");
        notifier = ObjectCreate(proto);
        setInternalSlot(notifier, SLOTS.TARGET, O);
        setInternalSlot(notifier, SLOTS.CHANGEOBSERVERS, []);
        setInternalSlot(notifier, SLOTS.ACTIVECHANGES, ObjectCreate(null));
        setInternalSlot(O, SLOTS.NOTIFIER, notifier);
    }
    return notifier;
}

function BeginChange(O, changeType) {
    var notifier = GetNotifier(O);
    var activeChanges = getInternalSlot(notifier, SLOTS.ACTIVECHANGES);
    var changeCount = Get(activeChanges, changeType);
    if (changeCount === undefined) changeCount = 1;
    else changeCount = changeCount + 1;
    CreateDataProperty(activeChanges, changeType, changeCount);
}

function EndChange(O, changeType) {
    var notifier = GetNotifier(O);
    var activeChanges = getInternalSlot(notifier, SLOTS.ACTIVECHANGES);
    var changeCount = Get(activeChanges, changeType);
    Assert(changeCount > 0, "changeCount has to be bigger than 0");
    changeCount = changeCount - 1;
    CreateDataProperty(activeChanges, changeType, changeCount);
}

function ShouldDeliverToObserver(activeChanges, acceptList, changeType) {
    var doesAccept = false;
    for (var i = 0, j = acceptList.length; i < j; i++) {
        var accept = acceptList[i];
        if (activeChanges[accept] > 0) return false;
        if (accept === changeType) doesAccept = true;
    }
    return doesAccept;
}

function EnqueueChangeRecord(O, changeRecord) {
    var notifier = GetNotifier(O);
    var changeType = Get(changeRecord, "type");
    var activeChanges = getInternalSlot(notifier, SLOTS.ACTIVECHANGES);
    var changeObservers = getInternalSlot(notifier, SLOTS.CHANGEOBSERVERS);
    var observerRecord;
    for (var i = 0, j = changeObservers.length; i < j; i++) {
        if (observerRecord = changeObservers[i]) {
            var acceptList = Get(oserverRecord, "accept");
            var deliver = ShouldDeliverToObserver(activeChanges, acceptList, changeType);
            if (deliver === false) continue;
            var observer = Get(observerRecord, "callback");
            var pendingRecords = getInternalSlot(observer, SLOTS.PENDINGCHANGERECORDS);
            pendingRecords.push(changeRecord);
        }
    }
}

function DeliverChangeRecords(C) {
    var changeRecords = getInternalSlot(C, SLOTS.PENDINGCHANGERECORDS);
    setInternalSlot(C, SLOTS.PENDINGCHANGERECORDS, []);
    var array = ArrayCreate(0);
    var n = 0;
    var status;
    var record;
    for (var i = 0, j = changeRecords.length; i < j; i++) {
        if (record = changeRecords[i]) {
            status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, array, ToString(n), {
                value: record,
                writable: true,
                enumerable: true,
                configurable: true
            });
            n = n + 1;
        }
    }
    if (Get(array, "length") === 0) return false;
    callInternalSlot(SLOTS.CALL, C, undefined, [array]);
    return true;
}

function DeliverAllChangeRecords() {
    var observers = ObserverCallbacks;
    var anyWorkDone = false;
    var observer;
    for (var i = 0, j = observers.length; i < j; i++) {
        if (observer = observers[i]) {
            var result = DeliverChangeRecords(observer);
            if (result === true) anyWorkDone = true;
        }
    }
    return anyWorkDone;
}

function CreateChangeRecord(type, object, name, oldDesc, newDesc) {
    var changeRecord = ObjectCreate();
    var status;
    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "type", {
        value: type,
        writable: false,
        enumerable: true,
        configurable: false
    });
    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "object", {
        value: object,
        writable: false,
        enumerable: true,
        configurable: false
    });
    if (Type(name) === STRING) {
        status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "name", {
            value: name,
            writable: false,
            enumerable: true,
            configurable: false
        });
    }
    if (IsDataDescriptor(oldDesc)) {
        if (!IsDataDescriptor(newDesc) || !SameValue(oldDesc.value, newDesc.value)) {
            status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "oldValue", {
                value: oldDesc,
                writable: false,
                enumerable: true,
                configurable: false
            });
        }
    }
    setInternalSlot(changeRecord, SLOTS.EXTENSIBLE, false);
    return changeRecord;
}

function CreateSpliceChanceRecord(object, index, removed, addedCount) {
    var changeRecord = ObjectCreate();
    var status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "type", {
        value: "splice",
        writable: false,
        enumerable: true,
        configurable: false
    });
    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "object", {
        value: object,
        writable: false,
        enumerable: true,
        configurable: false
    });
    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "index", {
        value: index,
        writable: false,
        enumerable: true,
        configurable: false
    });
    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "removed", {
        value: removed,
        writable: false,
        enumerable: true,
        configurable: false
    });
    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, changeRecord, "addedCount", {
        value: addedCount,
        writable: false,
        enumerable: true,
        configurable: false
    });
}

DefineOwnProperty(ObjectConstructor, "observe", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var O = argList[0];
        var callback = argList[1];
        var accept = argList[2];
        if (Type(O) !== OBJECT) return newTypeError( "first argument is not an object");
        if (!IsCallable(callback)) return newTypeError( "second argument is not callable");
        if (TestIntegrityLevel(callback, "frozen")) return newTypeError( "second argument is frozen");
        if (accept === undefined) {
            accept = ["add", "updata", "delete", "reconfigure", "setPrototype", "preventExtensions"];
        } else {
            accept = CreateListFromArray(accept);
        }
        var notifier = GetNotifier(O);
        var changeObservers = getInternalSlot(notifier, SLOTS.CHANGEOBSERVERS);
        var observer;
        for (var i = 0, j = changeObservers.length; i < j; i++) {
            if (observer = changeObservers[i]) {
                if (Get(observer, "callback") === callback) {
                    CreateDataProperty(record, "accept", acceptList);
                    return NormalCompletion(O);
                }
            }
        }
        var observerRecord = ObjectCreate();
        CreateDataProperty(observerRecord, "callback", callback);
        CreateDataProperty(observerRecord, "accept", acceptList);
        changeObservers.push(observerRecord);
        var observerCallbacks = ObserverCallbacks;
        if (observerCallbacks.indexOf(callback)) return NormalCompletion(O);
        observerCallbacks.push(calllback);
        return NormalCompletion(O);
    }),
    writable: true,
    enumerable: true,
    configurable: true
});

DefineOwnProperty(ObjectConstructor, "unobserve", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var O = argList[0];
        var callback = argList[1];
        if (Type(O) !== OBJECT) return newTypeError( "first argument is not an object");
        if (!IsCallable(callback)) return newTypeError( "second argument is not callable");
        var notifier = GetNotifier(O);
        var changeObservers = getInternalSlot(notifier, SLOTS.CHANGEOBSERVERS);
        changeObservers = changeObservers.filter(function (record) {
            return (Get(record, "callback") !== callback);
        });
        return NormalCompletion(O);
    }),
    writable: true,
    enumerable: true,
    configurable: true
});

DefineOwnProperty(ObjectConstructor, "deliverChangeRecords", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var callback = argList[0];
        if (!IsCallable(callback)) return newTypeError( "first argument is not callable.");
        var status;
        for (;;) {
            status = DeliverChangeRecords(callback);
            status = ifAbrupt(status);
            if (status === false || isAbrupt(status)) break;
        }
        if (isAbrupt(status)) return status;
        return NormalCompletion(undefined);
    }),
    writable: true,
    enumerable: true,
    configurable: true
});

DefineOwnProperty(ObjectConstructor, "getNotifier", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var O = argList[0];
        if (Type(O) !== OBJECT) return newTypeError( "first argument is not an object");
        if (TestIntegrityLevel(O, "frozen")) return NormalCompletion(null);
        return GetNotifier(O);
    }),
    writable: true,
    enumerable: true,
    configurable: true
});


// ==========================rc=================================================================================
// Function
// ===========================================================================================================

//
// Function
//

MakeConstructor(FunctionConstructor, true, FunctionPrototype);
setInternalSlot(FunctionPrototype, SLOTS.PROTOTYPE, ObjectPrototype);
LazyDefineProperty(FunctionPrototype, $$toStringTag, "Function");

LazyDefineBuiltinFunction(FunctionPrototype, "valueOf", 0, function valueOf(thisArg, argList) {
    return thisArg;
});

setInternalSlot(FunctionConstructor, SLOTS.CALL, function (thisArg, argList) {

    var argCount = argList.length;
    var P = "";
    var bodyText;
    var firstArg, nextArg;

    if (argCount === 0) bodyText = "";
    else if (argCount === 1) bodyText = argList[0];
    else if (argCount > 1) {
        firstArg = argList[0];
        P = ToString(firstArg);
        if (isAbrupt(firstArg = ifAbrupt(firstArg))) return firstArg;
        var k = 1;
        while (k < argCount - 1) {
            nextArg = argList[k];
            nextArg = ToString(nextArg);
            if (isAbrupt(nextArg = ifAbrupt(nextArg))) return nextArg;
            P = P + "," + nextArg;
            k += 1;
        }
        bodyText = argList[argCount - 1];
    }

    bodyText = ToString(bodyText);
    if (isAbrupt(bodyText = ifAbrupt(bodyText))) return bodyText;
    var parameters = parseGoal("FormalParameterList", P); // () sind fehlerhaft bei
    var funcBody = parseGoal("FunctionBody", bodyText);


    /* old and from july draf */
    var boundNames = BoundNames(parameters);
    if (!IsSimpleParameterList(parameters)) {
        if (dupesInTheTwoLists(boundNames, VarDeclaredNames(funcBody))) return newSyntaxError( "Duplicate Identifier in Parameters and VarDeclaredNames of funcBody");
    }
    if (dupesInTheTwoLists(boundNames, LexicallyDeclaredNames(funcBody))) return newSyntaxError( "Duplicate Identifier in Parameters and LexicallyDeclaredNames of funcBody");
    /* one of the few edge cases to recall static semantics */

    var scope = getRealm().globalEnv;
    var F = thisArg;
    if (F === undefined || !hasInternalSlot(F, SLOTS.CODE)) {
        var C = FunctionConstructor;
        var proto = GetPrototypeFromConstructor(C, INTRINSICS.FUNCTIONPROTOTYPE);
        if (isAbrupt(proto = ifAbrupt(proto))) return proto;
        F = FunctionAllocate(C);
    }

    if (getInternalSlot(F, SLOTS.FUNCTIONKIND) !== "normal") return newTypeError( "function object not a 'normal' function");
    FunctionInitialize(F, "normal", parameters, funcBody, scope, true);
    proto = ObjectCreate();
    var status = MakeConstructor(F);
    if (isAbrupt(status)) return status;
    SetFunctionName(F, "anonymous");
    return NormalCompletion(F);

});

setInternalSlot(FunctionConstructor, SLOTS.CONSTRUCT, function (argList) {
    var F = this;
    return OrdinaryConstruct(F, argList);
});

DefineOwnProperty(FunctionConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var F = thisArg;
        var proto = GetPrototypeFromConstructor(F, INTRINSICS.FUNCTIONPROTOTYPE);
        if (isAbrupt(proto = ifAbrupt(proto))) return proto;
        var obj = FunctionAllocate(proto);
        return obj;
    }),
    enumerable: false,
    writable: false,
    configurable: true
});

LazyDefineProperty(FunctionPrototype, $$create, CreateBuiltinFunction(realm, function $$create(thisArg, argList) {
    var F = thisArg;
    return OrdinaryCreateFromConstructor(F, INTRINSICS.OBJECTPROTOTYPE);
}));

DefineOwnProperty(FunctionPrototype, "constructor", {
    value: FunctionConstructor,
    enumerable: false,
    configurable: true,
    writable: true
});

// ===
// Function.prototype.toString uses codegen module ===>>> var codegen = require("js-codegen");
// ====

CreateDataProperty(FunctionPrototype, "toString", CreateBuiltinFunction(realm, function (thisArg, argList) {
    var codegen = require("js-codegen");
    var F = thisArg;
    if (!IsCallable(F)) return newTypeError( "Function.prototype.toString only applies to functions!");
    var name = Get(F, "name") || "anonymous";
    var P, C;
    P = getInternalSlot(F, SLOTS.FORMALPARAMETERS);
    C = getInternalSlot(F, SLOTS.CODE);
    var kind = getInternalSlot(F, SLOTS.FUNCTIONKIND);
    var star = kind === "generator" ? "*" : "";
    var callfn;
    if (!C && (callfn=getInternalSlot(F, SLOTS.CALL))) {
        var code = "// [[Builtin Function native JavaScript Code]]\r\n";
        // createbuiltin wraps the builtin
        if (callfn.steps) callfn = callfn.steps;
        // setinternalslot call has no wrapper
        // this requires a double check here
        code += callfn.toString();
        return code;
    }
    var paramString, bodyString;
    paramString = codegen.builder.formalParameters(P);
    if (kind === "arrow") {
        if (Array.isArray(C)) {
            bodyString = codegen.builder.functionBody(C);
        } else bodyString = codegen.callBuilder(C);
        return paramString + " => " + bodyString;
    } else {
        bodyString = codegen.builder.functionBody(C);
        return "function" + star + " " + name + " " + paramString + " " + bodyString;
    }
}));


DefineOwnProperty(FunctionPrototype, "apply", {
    value: CreateBuiltinFunction(realm, function apply(thisArg, argList) {
        var func = thisArg;
        if (!IsCallable(func)) return newTypeError( "fproto.apply: func is not callable");
        var T;
        if (T !== undefined && T !== null) T = ToObject(argList[0]);
        else T = argList[0];
        var argArray = argList[1] || ArrayCreate(0);
        var argList2 = CreateListFromArrayLike(argArray);
        if (isAbrupt(argList2 = ifAbrupt(argList2))) return argList2;
        return callInternalSlot(SLOTS.CALL, func, T, argList2);
    }),
    enumerable: false,
    configurable: true,
    writable: true
});
DefineOwnProperty(FunctionPrototype, "bind", {
    value: CreateBuiltinFunction(realm, function bind(thisArg, argList) {
        var boundTarget = thisArg;
        var thisArgument = argList[0];
        var listOfArguments = arraySlice(argList, 1, argList.length - 1);
        return BoundFunctionCreate(boundTarget, thisArgument, listOfArguments);
    }),
    writable: true,
    enumerable: false,
    configurable: true

});
DefineOwnProperty(FunctionPrototype, "call", {
    value: CreateBuiltinFunction(realm, function call(thisArg, argList) {
        var func = thisArg;
        if (!IsCallable(func)) return newTypeError( "fproto.call: func is not callable");
        var T = ToObject(argList[0]);
        var args = arraySlice(argList,1);
        return callInternalSlot(SLOTS.CALL, func, T, args);
    }),
    writable: true,
    enumerable: false,
    configurable: true
});

DefineOwnProperty(FunctionPrototype, $$hasInstance, {
    value: CreateBuiltinFunction(realm, function $$hasInstance(thisArg, argList) {
        var V = argList[0];
        var F = thisArg;
        return OrdinaryHasInstance(F, V);
    }, 1, "[Symbol.hasInstance]"),
    writable: true,
    enumerable: false,
    configurable: true

});

var FunctionPrototype_toMethod = function (thisArg, argList) {
    var superBinding = argList[0];
    var methodName = argList[1];
    if (!IsCallable(thisArg)) return newTypeError( "this value is not callable");
    if (Type(superBinding) !== OBJECT) return newTypeError( "superBinding is not an object");
    if (methodName !== undefined) {
        methodName = ToPropertyKey(methodName);
        if (isAbrupt(methodName = ifAbrupt(methodName))) return methodName;
    }
    return CloneMethod(thisArg, superBinding, methodName);
};

LazyDefineBuiltinFunction(FunctionPrototype, "toMethod", 1, FunctionPrototype_toMethod /*, realm  !!!*/);



LazyDefineProperty(GeneratorPrototype, $$iterator, CreateBuiltinFunction(realm, function (thisArg, argList) {
    return thisArg;
}));

LazyDefineProperty(GeneratorPrototype, $$toStringTag, "Generator");

// GeneratorFunction.[[Prototype]] = FunctionPrototype
setInternalSlot(GeneratorFunction, SLOTS.PROTOTYPE, FunctionConstructor);
MakeConstructor(GeneratorFunction, true, GeneratorObject);
// GeneratorFunction.prototype = %Generator%

DefineOwnProperty(GeneratorFunction, "prototype", {
    value: GeneratorPrototype,
    enumerable: false
});
// GeneratorFunction.prototype.constructor = GeneratorFunction
LazyDefineProperty(GeneratorPrototype, "constructor", GeneratorFunction);
LazyDefineProperty(GeneratorObject, "constructor", GeneratorFunction);
LazyDefineProperty(GeneratorObject, "prototype", GeneratorPrototype);

// GeneratorFunction.prototype.prototype = GeneratorPrototype
setInternalSlot(GeneratorObject, SLOTS.PROTOTYPE, GeneratorPrototype);

//    LazyDefineProperty(GeneratorPrototype, "constructor", GeneratorObject);

LazyDefineProperty(GeneratorPrototype, "next", CreateBuiltinFunction(realm, function (thisArg, argList) {
    var value = argList[0];
    var G = thisArg;
    return GeneratorResume(G, value);
}));

LazyDefineProperty(GeneratorPrototype, "throw", CreateBuiltinFunction(realm, function (thisArg, argList) {
    var g = thisArg;
    var exception = argList[0];
    if (Type(g) !== OBJECT) return newTypeError( "throw: Generator is not an object");
    if (!hasInternalSlot(g, SLOTS.GENERATORSTATE)) return newTypeError( "throw: generator has no GeneratorState property");
    var state = getInternalSlot(g, SLOTS.GENERATORSTATE);
    Assert(hasInternalSlot(g, SLOTS.GENERATORCONTEXT), "generator has to have a GeneratorContext property");
    if (state !== "suspendedStart" && state != "suspendedYield") return newTypeError( "GeneratorState is neither suspendedStart nor -Yield");
    var E = CompletionRecord("throw", exception);
    if (state === "suspendedStart") {
        setInternalSlot(g, SLOTS.GENERATORSTATE, "completed");
        setInternalSlot(g, SLOTS.GENERATORCONTEXT, undefined);
        return E;
    }
    var genContext = getInternalSlot(g, SLOTS.GENERATORCONTEXT);
    var methodContext = getCurrentExectionContext();
    setInternalSlot(g, SLOTS.GENERATORSTATE, "executing");
    getStack().push(genContext);
    var result = genContext.generatorCallback(E);
    Assert(genContext !== getContext());
    Assert(methodContext === getContext());
    return result;
}));

setInternalSlot(GeneratorFunction, SLOTS.CALL, function Call(thisArg, argList) {
    // GeneratorFunction(p1...pn, body)
    var argCount = argList.length;
    var P = "";
    var bodyText;
    var firstArg, nextArg;
    if (argCount === 0) bodyText = "";
    else if (argCount === 1) bodyText = argList[0];
    else if (argCount > 1) {
        firstArg = argList[0];
        P = ToString(firstArg);
        if (isAbrupt(firstArg = ifAbrupt(firstArg))) return firstArg;
        var k = 1;
        while (k < argCount - 1) {
            nextArg = argList[k];
            nextArg = ToString(nextArg);
            if (isAbrupt(nextArg = ifAbrupt(nextArg))) return nextArg;
            P = P + "," + nextArg;
            k += 1;
        }
        bodyText = argList[argCount - 1];
    }

    bodyText = ToString(bodyText);
    if (isAbrupt(bodyText = ifAbrupt(bodyText))) return bodyText;
    var parameters = parseGoal("FormalParameterList", P);

    var funcBody = parseGoal("GeneratorBody", bodyText);

    /*  this is very slow, asking for static semantics here with having to analyse the tree
    * this should be captured by the ecmascript compliant parser */

     if (!Contains(funcBody, "YieldExpression")) return newSyntaxError( "GeneratorFunctions require some yield expression");
    var boundNames = BoundNames(parameters);
    if (!IsSimpleParameterList(parameters)) {
        if (dupesInTheTwoLists(boundNames, VarDeclaredNames(funcBody))) return newSyntaxError( "Duplicate Identifier in Parameters and VarDeclaredNames of funcBody");
    }
    if (dupesInTheTwoLists(boundNames, LexicallyDeclaredNames(funcBody))) return newSyntaxError( "Duplicate Identifier in Parameters and LexicallyDeclaredNames of funcBody");



    var scope = getRealm().globalEnv;
    var F = thisArg;
    if (F == undefined || !hasInternalSlot(F, SLOTS.CODE)) {
        F = FunctionAllocate(GeneratorFunction, "generator");
    }
    if (getInternalSlot(F, SLOTS.FUNCTIONKIND) !== "generator") return newTypeError( "function object not a generator");
    FunctionInitialize(F, "generator", parameters, funcBody, scope, true);
    var proto = ObjectCreate(GeneratorPrototype);
    MakeConstructor(F, true, proto);
    SetFunctionLength(F, ExpectedArgumentCount(F.FormalParameters));
    return NormalCompletion(F);
});

setInternalSlot(GeneratorFunction, SLOTS.CONSTRUCT, function (argList) {
    var F = GeneratorFunction;
    return OrdinaryConstruct(F, argList);
});

LazyDefineProperty(GeneratorFunction, $$create, CreateBuiltinFunction(realm, function (thisArg, argList) {
    var F = thisArg;
    var proto = GetPrototypeFromConstructor(F, INTRINSICS.GENERATOR);
    if (isAbrupt(proto = ifAbrupt(proto))) return proto;
    var obj = FunctionAllocate(proto, "generator");
    return obj;
}));

LazyDefineProperty(GeneratorPrototype, $$create, CreateBuiltinFunction(realm, function (thisArg, argList) {
    var F = thisArg;
    var obj = OrdinaryCreateFromConstructor(F, INTRINSICS.GENERATOR, {
        GeneratorState: null,
        GeneratorContext: null
    });
    return obj;
}));


function Str(key, holder, _state) {
    var replacer = _state.ReplaceFunction;
    var value = Get(holder, key);
    if (isAbrupt(value=ifAbrupt(value))) return value;
    if (Type(value) === OBJECT) {
        var toJSON = Get(value, "toJSON");
        if (IsCallable(toJSON)) {
            value = callInternalSlot(SLOTS.CALL, toJSON, value, [key]);
        }
    }
    if (IsCallable(replacer)) {
        value = callInternalSlot(SLOTS.CALL, replacer, holder, [key, value]);
    }
    if (Type(value) === OBJECT) {
        if (hasInternalSlot(value, SLOTS.NUMBERDATA)) {
            value = ToNumber(value);
        } else if (hasInternalSlot(value, SLOTS.STRINGDATA)) {
            value = ToString(value);
        } else if (hasInternalSlot(value, SLOTS.BOOLEANDATA)) {
            value = ToBoolean(value);
        }
    }
    if (value === null) return "null";
    if (value === true) return "true";
    if (value === false) return "false";
    if (Type(value) === STRING) return Quote(value);
    if (Type(value) === NUMBER) {
        if (value <= Math.pow(2, 53) - 1) return ToString(value);
        else return "null";
    }
    if (Type(value) === OBJECT && !IsCallable(value)) {
        if (IsArray(value)) return JA(value, _state);
        return JO(value, _state);
    }
    return undefined;
}

function Quote(value) {
    var ch;
    var product = "\"";
    for (var i = 0, j = value.length; i < j; i++) {
        ch = value[i];
        product += ch;
    }
    return product + "\"";
}

function JA(value, _state) {
    var stack = _state.stack;
    var indent = _state.indent;
    var gap = _state.gap;
    if (stack.indexOf(value) > -1) {
        return newTypeError( "Because the structure is cyclical!");
    }
    stack.push(value);
    var stepback = indent;
    var len = Get(value, "length");
    if (isAbrupt(len=ifAbrupt(len))) return len;
    var index = 0;
    var partial = [];

    while (index < len) {
        var strP = Str(ToString(index), value, _state);
        if (isAbrupt(strP = ifAbrupt(strP))) return strP;
        if (strP == undefined) {
            partial.push("null");
        } else {
            partial.push(strP);
        }
        index = index + 1;
    }
    var final = "";
    var properties;
    if (!partial.length) {
        final = "[]";
    } else {
        if (gap === "") {
            properties = partial.join(",");
            final = "[" + properties + "]";
        } else {
            var separator = ",\u000A" + indent;
            properties = partial.join(separator);
            final = "[\u000A" + indent + properties + "\u000A" + stepback + "]";
        }
    }
    stack.pop();
    _state.indent = stepback;
    return final;
}

function JO(value, _state) {
    var stack = _state.stack;
    var indent = _state.indent;
    var gap = _state.gap;
    var PropertyList = _state.PropertyList;
    if (stack.indexOf(value) > -1) {
        return newTypeError( "Because the structure is cyclical!");
    }
    stack.push(value);
    var stepback = indent;
    var K;
    if (PropertyList && PropertyList.length) {
        K = MakeListIterator(PropertyList);
    } else {
        K = OwnPropertyKeys(value);
    }
    var partial = [];
    var done, nextResult, P;
    while (!done) {
        nextResult = IteratorNext(K);
        if (isAbrupt(nextResult = ifAbrupt(nextResult))) return nextResult;
        P = IteratorValue(nextResult);
        if (isAbrupt(P = ifAbrupt(P))) return P;
        var strP = Str(P, value, _state);
        if (isAbrupt(strP = ifAbrupt(strP))) return strP;
        if (strP !== undefined) {
            var member = Quote(P);
            member = member + ":";
            if (gap != "") {
                member = member + " ";
            }
            member = member + strP;
            partial.push(member);
        }
        done = IteratorComplete(nextResult);
    }
    var final = "";
    var properties;
    if (!partial.length) {
        final = "{}";
    } else {
        if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
        } else {
            var separator = ",\u000A" + indent;
            properties = partial.join(separator);
            final = "{\u000A" + indent + properties + "\u000A" + stepback + "}";
        }
    }
    stack.pop();
    _state.indent = stepback;
    return final;
}

function Walk(holder, name, reviver) {
    var val = Get(holder, name);
    var done;
    var status;
    var newElement;
    if (isAbrupt(val = ifAbrupt(val))) return val;
    if (Type(val) === OBJECT) {
    
        if (IsArray(val)) {
            var I = 0;
            var len = Get(val, "length");
            if (isAbrupt(len = ifAbrupt(len))) return len;
            while (I < len) {
                newElement = Walk(val, ToString(I));
                if (newElement === undefined) {
                    status = Delete(val, I);
                } else {
                    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, val, ToString(I), {
                        value: newElement,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
                if (isAbrupt(status = ifAbrupt(status))) return status;
                I = I + 1;
            }
        } else {
            var keys = OwnPropertyKeys(val);
            while (!done) {
                var nextResult = IteratorNext(keys);
                if (isAbrupt(nextResult = ifAbrupt(nextResult))) return nextResult;
                var P = IteratorResult(nextResult);
                if (isAbrupt(P=ifAbrupt(P))) return P;
                newElement = Walk(val, P);
                if (newElement === undefined) {
                    status = Delete(val, P);
                } else {
                    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, val, P, {
                        value: newElement,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
                if (isAbrupt(status = ifAbrupt(status))) return status;
                done = IteratorComplete(nextResult);
                if (isAbrupt(done=ifAbrupt(done))) return done;
            }
        }
    }
    return callInternalSlot(SLOTS.CALL, reviver, holder, [name, val]);
}

DefineOwnProperty(JSONObject, "parse", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var text = argList[0];
        var reviver = argList[1];
        var JText = ToString(text);
        var tree = parseGoal("JSONText", JText /* , "JSONparse" */);
        if (isAbrupt(tree = ifAbrupt(tree))) return tree;
        var scriptText = parseGoal("ParenthesizedExpression", JText);
        var exprRef = require("runtime").Evaluate(scriptText);
        var unfiltered = GetValue(exprRef);
        if (isAbrupt(unfiltered = ifAbrupt(unfiltered))) return unfiltered;
        if (IsCallable(reviver) === true) {
            var proto = getIntrinsic(INTRINSICS.OBJECTPROTOTYPE);
            var root = ObjectCreate(proto);
            CreateDataProperty(root, "", unfiltered);
            return Walk(root, "", reviver);
        }
        return NormalCompletion(unfiltered);
    }, 2),
    enumerable: false,
    configurable: false,
    writable: false
});
DefineOwnProperty(JSONObject, "stringify", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var value = argList[0];
        var replacer = argList[1];
        var space = argList[2];
        var stack = [];
        var indent = "";
        var ReplacerFunction, PropertyList = [];
        var _state = {
            stack: stack,
            indent: indent,
            ReplacerFunction: undefined,
            PropertyList: undefined
        };
        var gap = "", i;
        if (Type(replacer) === OBJECT) {
            if (IsCallable(replacer)) {
                _state.ReplacerFunction = ReplacerFunction = replacer;
            } else if (IsArray(replacer)) {
                var len = Get(replacer, "length");
                if (isAbrupt(len=ifAbrupt(len))) return len;
                var item, v;
                for (i = 0; i < len; i++) {
                    item = undefined;
                    v = Get(replacer, ToString(i));
                    if (isAbrupt(v=ifAbrupt(v))) return v;
                    if (Type(v) === STRING) item = v;
                    else if (Type(v) === NUMBER) item = ToString(v);
                    else if (Type(v) === OBJECT) {
                        if (hasInternalSlot(v, SLOTS.NUMBERDATA) || hasInternalSlot(v, SLOTS.STRINGDATA)) item = ToString(v);

                        if (item != undefined && PropertyList.indexOf(item) < 0) {
                            _state.PropertyList = PropertyList;
                            PropertyList.push(item);
                        }
                    }
                }
            }
        }
        if (Type(space) === OBJECT) {
            if (hasInternalSlot(space, SLOTS.NUMBERDATA)) space = ToNumber(space);
            else if (hasInternalSlot(space, SLOTS.STRINGDATA)) space = ToString(space);
        }
        if (Type(space) === NUMBER) {
            space = min(10, ToInteger(space));
            gap = "";
            for (i = 0; i < space; i++) {
                gap += " ";
            }
        } else if (Type(space) === STRING) {
            if (space.length < 11) gap = space;
            else {
                for (i = 0; i < 10; i++) {
                    gap += space[i];
                }
            }
        } else gap = "";
        _state.gap = gap;
        var proto = getIntrinsic(INTRINSICS.OBJECTPROTOTYPE);
        var wrapper = ObjectCreate(proto);
        var status = CreateDataProperty(wrapper, "", value);
        if (isAbrupt(status=ifAbrupt(status))) return status;
        if (status === false) return newTypeError( "status may not be wrong here");
        var result = Str("", wrapper, _state);
        if (isAbrupt(result=ifAbrupt(result))) return result;
        return NormalCompletion(result);
    }),
    enumerable: false,
    configurable: false,
    writable: false
});

DefineOwnProperty(JSONObject, $$toStringTag, {
    value: "JSON",
    enumerable: false,
    configurable: false,
    writable: false
});

setInternalSlot(JSONObject, SLOTS.PROTOTYPE, ObjectPrototype);
setInternalSlot(JSONObject, SLOTS.JSONTAG, true);


var PromiseConstructor_call = function (thisArg, argList) {
    var executor = argList[0];
    var promise = thisArg;
    if (Type(promise) !== OBJECT) return newTypeError( "promise is not an object");
    if (!IsCallable(executor)) return newTypeError( "executor argument is not a callable");
    if (!hasInternalSlot(promise, SLOTS.PROMISESTATE)) return newTypeError( "promise has no PromiseState Property");
    if (getInternalSlot(promise, SLOTS.PROMISESTATE) !== undefined) return newTypeError( "promise´s PromiseState is not undefined");
    return InitializePromise(promise, executor);
};
var PromiseConstructor_Construct = function (argList) {
    return Construct(this, argList);
};
var PromiseConstructor_$$create = function (thisArg, argList) {
    return AllocatePromise(thisArg);
};
var PromiseConstructor_resolve = function (thisArg, argList) {
    var x = argList[0];
    var C = thisArg;
    if (IsPromise(x)) {
        var constructor = getInternalSlot(x, SLOTS.PROMISECONSTRUCTOR);
        if (SameValue(x, C)) return x;
    }
    var promiseCapability = NewPromiseCapability(C);
    if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;
    var resolveResult = callInternalSlot(SLOTS.CALL, promiseCapability.Resolve, undefined, [x]);
    if (isAbrupt(resolveResult = ifAbrupt(resolveResult))) return resolveResult;
    return NormalCompletion(promiseCapability.Promise);
};
var PromiseConstructor_reject = function (thisArg, argList) {
    var r = argList[0];
    var C = thisArg;
    var promiseCapability = NewPromiseCapability(C);
    if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;
    var rejectResult = callInternalSlot(SLOTS.CALL, promiseCapability.Reject, undefined, [r]);
    if (isAbrupt(rejectResult = ifAbrupt(rejectResult))) return rejectResult;
    return NormalCompletion(promiseCapability.Promise)
};
var PromiseConstructor_cast = function (thisArg, argList) {
    var x = argList[0];
    var C = thisArg;
    if (IsPromise(x)) {
        var constructor = getInternalSlot(x, SLOTS.PROMISECONSTRUCTOR);
        if (SameValue(constructor, C)) return NormalCompletion(x);
    }
    var promiseCapability = NewPromiseCapability(C);
    if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;
    var resolveResult = callInternalSlot(SLOTS.CALL, promiseCapability.Resolve, undefined, [x]);
    if (isAbrupt(resolveResult = ifAbrupt(resolveResult))) return resolveResult;
    return NormalCompletion(promiseCapability.Promise);
};
var PromiseConstructor_race = function (thisArg, argList) {
    var iterable = argList[0];
    var C = thisArg;
    var promiseCapability = NewPromiseCapability(C);
    if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;
    var iterator = GetIterator(iterable);
    iterator = IfAbruptRejectPromise(iterator, promiseCapability);
    if (isAbrupt(iterator)) return iterator;
    for (;;) {
        var next = IteratorStep(iterator);
        if (isAbrupt(next = ifAbrupt(next))) return next;
        if ((next = IfAbruptRejectPromise(next, promiseCapability)) &&isAbrupt(next)) return next;
        if (next === false) return NormalCompletion(promiseCapability.Promise);
        var nextValue = IteratorValue(next);
        if ((nextValue=IfAbruptRejectPromise(nextValue, promiseCapability)) && isAbrupt(nextValue)) return nextValue;
        var nextPromise = Invoke(C, "cast", [nextValue]);
        if ((nextPromise=IfAbruptRejectPromise(nextPromise, promiseCapability)) && isAbrupt(nextPromise)) return nextPromise;
        var result = Invoke(nextPromise, "then", [promiseCapability.Resolve, promiseCapability.Reject]);
        if ((result = IfAbruptRejectPromise(result, promiseCapability)) && isAbrupt(result)) return result;
    }

};
function makePromiseAllResolveElementsFunction () {
    var PromiseAllResolveElements_call = function (thisArg, argList) {
        var x = argList[0];
        var index = getInternalSlot(F, SLOTS.INDEX);
        var values = getInternalSlot(F, SLOTS.VALUES);
        var promiseCapability = getInternalSlot(F, SLOTS.CAPABILITY);
        var remainingElementsCount = getInternalSlot(F, SLOTS.REMAININGELEMENTS);
        var result = CreateDataProperty(values, ToString(index), x);
        if ((result = IfAbruptRejectPromise(result, promiseCapability)) && isAbrupt(result)) return result;
        remainingElementsCount.value -= 1;
        if (remainingElementsCount.value === 0) {
            return callInternalSlot(SLOTS.CALL, promiseCapability.Resolve, undefined, [values]);
        }
        return NormalCompletion(undefined);
    };
    //var F = CreateBuiltinFunction(getRealm(), "Promise.all Resolve Elements", 1, PromiseAllResolveElements_call);
    var F = OrdinaryFunction();
    setInternalSlot(F, SLOTS.CALL, PromiseAllResolveElements_call);
    return F;
}
var PromiseConstructor_all = function (thisArg, argList) {
    var iterable = argList[0];
    var C = thisArg;
    var promiseCapability = NewPromiseCapability(C);
    if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;
    var iterator = GetIterator(iterable);
    if ((iterator=IfAbruptRejectPromise(iterator, promiseCapability)) && isAbrupt(iterator)) return iterator;
    var values = ArrayCreate(0);
    var remainingElementsCount = { value: 0 };
    var index = 0;
    for (;;) {
        var next = IteratorStep(iterator);
        if (isAbrupt(next = ifAbrupt(next))) return next;
        if ((next=IfAbruptRejectPromise(next, promiseCapability)) && isAbrupt(next)) return next;
        if (next === false) {
            if (index == 0) {
                var resolveResult = callInternalSlot(SLOTS.CALL, promiseCapability.Resolve, undefined, [values]);
                if (isAbrupt(resolveResult = ifAbrupt(resolveResult))) return resolveResult;
            }
            return NormalCompletion(promiseCapability.Promise)
        }
        var nextValue = IteratorValue(next);
        if (isAbrupt(nextValue = IfAbruptRejectPromise(nextValue, promiseCapability)))  return nextValue;
        var nextPromise = Invoke(C, "cast", [nextValue]);
        if (isAbrupt(nextPromise=IfAbruptRejectPromise(nextPromise, promiseCapability))) return nextPromise;
        var resolveElement = makePromiseAllResolveElementsFunction();
        setInternalSlot(resolveElement, SLOTS.INDEX, index);
        setInternalSlot(resolveElement, SLOTS.VALUES, values);
        setInternalSlot(resolveElement, SLOTS.CAPABILITY, resolveElement, promiseCapability);
        setInternalSlot(resolveElement, SLOTS.REMAININGELEMENTS, remainingElementsCount);
        var result = Invoke(nextPromise, "then", [resolveElement, promiseCapability.Reject]);
        if (isAbrupt(result = IfAbruptRejectPromise(result, promiseCapability))) return result;
        index = index + 1;
        remainingElementsCount.value += 1;
    }
};
var PromisePrototype_then = function (thisArg, argList) {
    var onFulfilled = argList[0];
    var onRejected = argList[1];
    var promise = thisArg;
    if (!IsPromise(promise)) return newTypeError( "then: this is not a promise object");
    if (onFulfilled === undefined || onFulfilled === null) onFulfilled = makeIdentityFunction();
    if (onRejected === undefined || onRejected === null) onRejected = makeThrowerFunction();
    var C = Get(promise, "constructor");
    if (isAbrupt(C = ifAbrupt(C))) return C;

    var promiseCapability = NewPromiseCapability(C);
    if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;

    var resolveReaction = PromiseReaction(promiseCapability, onFulfilled);
    var rejectReaction = PromiseReaction(promiseCapability, onRejected);

    var PromiseState = getInternalSlot(promise, SLOTS.PROMISESTATE);
    if (PromiseState === "pending") {
        getInternalSlot(promise, SLOTS.PROMISERESOLVEREACTIONS).push(resolveReaction);
        getInternalSlot(promise, SLOTS.PROMISEREJECTREACTIONS).push(rejectReaction);

    } else if (PromiseState === "fulfilled") {
        var resolution = getInternalSlot(promise, SLOTS.PROMISERESULT);
        EnqueueTask("PromiseTasks", PromiseReactionTask(), [resolveReaction, resolution]);
    } else if (PromiseState === "rejected") {
        var reason = getInternalSlot(promise, SLOTS.PROMISERESULT);
        EnqueueTask("PromiseTasks", PromiseReactionTask(), [rejectReaction, reason]);
    }
    return NormalCompletion(promiseCapability.Promise);
};
var PromisePrototype_catch = function (thisArg, argList) {
    var onRejected = argList[0];
    return Invoke(thisArg, "then", [undefined, onRejected]);
};
//SetFunctionName(PromiseConstructor, SLOTS.PROMISE);
MakeConstructor(PromiseConstructor, true, PromisePrototype);
setInternalSlot(PromiseConstructor, SLOTS.CALL, PromiseConstructor_call);
setInternalSlot(PromiseConstructor, SLOTS.CONSTRUCT, PromiseConstructor_Construct);
LazyDefineProperty(PromiseConstructor, $$create, CreateBuiltinFunction(realm, PromiseConstructor_$$create, 0, "[Symbol.create]"));
LazyDefineBuiltinFunction(PromiseConstructor, "resolve", 1, PromiseConstructor_resolve);
LazyDefineBuiltinFunction(PromiseConstructor, "reject", 1, PromiseConstructor_reject);
LazyDefineBuiltinFunction(PromiseConstructor, "cast", 1, PromiseConstructor_cast);
LazyDefineBuiltinFunction(PromiseConstructor, "race", 1, PromiseConstructor_race);
LazyDefineProperty(PromiseConstructor, "all", CreateBuiltinFunction(realm, PromiseConstructor_all, 0, "all"));
LazyDefineProperty(PromisePrototype, "then", CreateBuiltinFunction(realm, PromisePrototype_then, 2, "then"));
LazyDefineProperty(PromisePrototype, "catch", CreateBuiltinFunction(realm, PromisePrototype_catch, 1, "catch"));
LazyDefineProperty(PromisePrototype, "constructor", PromiseConstructor);
LazyDefineProperty(PromisePrototype, $$toStringTag, SLOTS.PROMISE);


/*
    move into lib/api/promise.js
 */

function PromiseNew (executor) {
    var promise = AllocatePromise(getIntrinsic(INTRINSICS.PROMISE));
    return InitializePromise(promise, executor);
}
function PromiseBuiltinCapability() {
    var promise = AllocatePromise(getIntrinsic(INTRINSICS.PROMISE));
    return CreatePromiseCapabilityRecord(promise, getIntrinsic(INTRINSICS.PROMISE));
}
function PromiseOf(value) {
    var capability = NewPromiseCapability();
    if (isAbrupt(capability = ifAbrupt(capability))) return capability;
    var resolveResult = callInternalSlot(SLOTS.CALL, capability.Resolve, undefined, [value]);
    if (isAbrupt(resolveResult = ifAbrupt(resolveResult))) return resolveResult;
    return NormalCompletion(capability.Promise);
}
function PromiseCapability(promise, resolve, reject) {
    var pc = Object.create(PromiseCapability.prototype);
    pc.Promise = promise;
    pc.Resolve = resolve;
    pc.Reject = reject;
    return pc;
}
PromiseCapability.prototype.toString = function () {
    return "[object PromiseCapability]";
};
function makePromiseReaction(capabilites, handler) {
    return PromiseReaction(capabilites, handler);
}
function PromiseReaction(caps, hdl) {
    var pr = Object.create(PromiseReaction.prototype);
    pr.Capability = caps;
    pr.Handler = hdl;
    return pr;
}
PromiseReaction.prototype.toString = function () {
    return "[object PromiseReaction]";
};
function UpdatePromiseFromPotentialThenable(x, promiseCapability) {
    if (Type(x) !== OBJECT) return NormalCompletion("not a thenable");
    var then = Get(x, "then");
    if (isAbrupt(then = ifAbrupt(then))) {
        var rejectResult = callInternalSlot(SLOTS.CALL, promiseCapability.Reject, undefined, [then.value]);
        if (isAbrupt(rejectResult = ifAbrupt(rejectResult))) return rejectResult;
        return NormalCompletion(null);
    }
    if (!IsCallable(then)) return NormalCompletion("not a thenable");
    var thenCallResult = callInternalSlot(SLOTS.CALL, then, x, [promiseCapability.Resolve, promiseCapability.Reject]);
    if (isAbrupt(thenCallResult = ifAbrupt(thenCallResult))) {
        rejectResult = callInternalSlot(SLOTS.CALL, promiseCapability.Reject, undefined, [thenCallResult.value]);
        if (isAbrupt(rejectResult = ifAbrupt(rejectResult))) return rejectResult;
    }
    return NormalCompletion(null);
}
function TriggerPromiseReactions(reactions, argument) {
    if (Array.isArray(reactions)) {
        for (var i = 0, j = reactions.length; i < j; i++) {
            var reaction = reactions[i];
            EnqueueTask("PromiseTasks", PromiseReactionTask(), [reaction, argument])
        }
	}
    return NormalCompletion(undefined);
}
function PromiseReactionTask() {
    var F;
    var PromiseReactionTask_call = function (thisArg, argList) {
        var reaction = argList[0];
        var argument = argList[1];
        Assert(reaction && reaction.Capability && reaction.Handler, "reaction must be a PromiseReaction record");
        var promiseCapability = reaction.Capability;
        var handler = reaction.Handler;
        var PromiseTaskQueue = getTasks(getRealm(), SLOTS.PROMISE);
        var handlerResult = callInternalSlot(SLOTS.CALL, handler, undefined, [argument]);
        if (isAbrupt(handlerResult = ifAbrupt(handlerResult))) {
            var status = callInternalSlot(SLOTS.CALL, promiseCapability.Reject, undefined, [handlerResult.value]);
            return NextTask(status, PromiseTaskQueue);
        }
        status = callInternalSlot(SLOTS.CALL, promiseCapability.Resolve, undefined, [handlerResult]);
        return NextTask(status, PromiseTaskQueue);
    };
    F = CreateBuiltinFunction(getRealm(), PromiseReactionTask_call, "PromiseReactionTask", 2);
    return F;
}
function IfAbruptRejectPromise(value, capability) {
    if (isAbrupt(value=ifAbrupt(value))) {
        var rejectedResult = callInternalSlot(SLOTS.CALL, capability.Reject, undefined, [value.value]);
        if (isAbrupt(rejectedResult = ifAbrupt(rejectedResult))) return rejectedResult;
        return NormalCompletion(capability.Promise);
    }
    return value;
}
function makePromiseRejectFunction() {
    var F = OrdinaryFunction();
    SetFunctionName(F, "reject");
    SetFunctionLength(F, 1);
    var PromiseRejectFunction_call = function (thisArg, argList) {
        Assert(Type(getInternalSlot(F, SLOTS.PROMISE)) === OBJECT, "[[Promise]] has to be an object");
        var reason = argList[0];
        var promise = getInternalSlot(F, SLOTS.PROMISE);
        var alreadyResolved = getInternalSlot(F, SLOTS.ALREADYRESOLVED);
        if (alreadyResolved.value === true) return NormalCompletion(undefined);
        alreadyResolved.value = true;
        return RejectPromise(promise, reason);
    };
    setInternalSlot(F, SLOTS.CALL, PromiseRejectFunction_call);
    return F;
}
function makePromiseResolveFunction() {
    var F = OrdinaryFunction();
    SetFunctionName(F, "resolve");
    SetFunctionLength(F, 1);

    var PromiseResolveFunction_call = function (thisArg, argList) {
        Assert(Type(getInternalSlot(F, SLOTS.PROMISE)) === OBJECT, "[[Promise]] has to be an object");
        var resolution = argList[0];
        var promise = getInternalSlot(F, SLOTS.PROMISE);
        var alreadyResolved = getInternalSlot(F, SLOTS.ALREADYRESOLVED);
        alreadyResolved.value = true;
        if (SameValue(resolution, promise)) {
            var selfResolutionError = newTypeError( "self resolution handler");
            return RejectPromise(promise, selfResolutionError);
        }
        if (Type(resolution) !== OBJECT) {
            return FulfillPromise(promise, resolution);
        }
        var then = Get(resolution, "then");
        if (isAbrupt(then=ifAbrupt(then))) {
            return RejectPromise(promise, then.value);
        }
        if (!IsCallable(then)) {
            return FulfillPromise(promise, resolution);
        }
        var resolvingFunctions = CreateResolvingFunctions(promise);
        var thenCallResult = callInternalSlot(SLOTS.CALL, then, resolution, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);

        if (isAbrupt(thenCallResult=ifAbrupt(thenCallResult))) {
            return callInternalSlot(SLOTS.CALL, resolvingFunctions.Reject, undefined, [thenCallResult.value]);
        }

        return NormalCompletion(thenCallResult);

    };
    setInternalSlot(F, SLOTS.CALL, PromiseResolveFunction_call);
    return F;
}
function CreateResolvingFunctions (promise) {
    var alreadyResolved = {value:false};
    var resolve = makePromiseResolveFunction();
    setInternalSlot(resolve, SLOTS.PROMISE, promise);
    setInternalSlot(resolve, SLOTS.ALREADYRESOLVED, alreadyResolved);
    var reject = makePromiseRejectFunction();
    setInternalSlot(reject, SLOTS.PROMISE, promise);
    setInternalSlot(reject, SLOTS.ALREADYRESOLVED, alreadyResolved);
    return { Resolve: resolve, Reject: reject };
}
function FulfillPromise (promise, value) {
    Assert(getInternalSlot(promise, SLOTS.PROMISESTATE) === "pending", "[[PromiseState]] must be pending");
    var reactions = getInternalSlot(promise, SLOTS.PROMISERESOLVEREACTIONS);
    setInternalSlot(promise, SLOTS.PROMISERESULT, value);
    setInternalSlot(promise, SLOTS.PROMISERESOLVEREACTIONS, []);
    setInternalSlot(promise, SLOTS.PROMISEREJECTREACTIONS, []);
    setInternalSlot(promise, SLOTS.PROMISESTATE, "fulfilled");
    return TriggerPromiseReactions(reactions, value);
}
function RejectPromise (promise, reason) {
    Assert(getInternalSlot(promise, SLOTS.PROMISESTATE) === "pending", "[[PromiseState]] must not be pending");
    var reactions = getInternalSlot(promise, SLOTS.PROMISEREJECTREACTIONS);
    setInternalSlot(promise, SLOTS.PROMISERESULT, reason);
    setInternalSlot(promise, SLOTS.PROMISERESOLVEREACTIONS, []);
    setInternalSlot(promise, SLOTS.PROMISEREJECTREACTIONS, []);
    setInternalSlot(promise, SLOTS.PROMISESTATE, "rejected");
    return TriggerPromiseReactions(reactions, reason);
}
function NewPromiseCapability(C) {
    if (!IsConstructor(C)) return newTypeError( "C is no constructor");
    // Assertion Step 2 missing 25.4.3.1
    var promise = CreateFromConstructor(C);
    if (isAbrupt(promise = ifAbrupt(promise))) return promise;
    return CreatePromiseCapabilityRecord(promise, C);
}
function CreatePromiseCapabilityRecord(promise, constructor) {
    var promiseCapability = PromiseCapability(promise, undefined, undefined);
    var executor = GetCapabilitiesExecutor();
    setInternalSlot(executor, SLOTS.CAPABILITY, promiseCapability);
    var constructorResult = callInternalSlot(SLOTS.CALL, constructor, promise, [executor]);
    if (isAbrupt(constructorResult = ifAbrupt(constructorResult))) return constructorResult;
    if (!IsCallable(promiseCapability.Resolve)) return newTypeError( "capability.[[Resolve]] is not a function");
    if (!IsCallable(promiseCapability.Reject)) return newTypeError( "capability.[[Reject]] is not a function");
    if (Type(constructorResult) === OBJECT && (SameValue(promise, constructorResult) === false)) return newTypeError("constructorResult is not the same as promise");
    return promiseCapability;
}
function GetCapabilitiesExecutor () {
    var F = OrdinaryFunction();
    var GetCapabilitiesExecutor_call = function (thisArg, argList) {
        var resolve = argList[0];
        var reject = argList[1];
        var promiseCapability = getInternalSlot(F, SLOTS.CAPABILITY);
        Assert(promiseCapability !== undefined, "executor has to have a capability slot");
        if (promiseCapability.Resolve !== undefined) return newTypeError( "promiseCapability has to have some undefined fields");
        if (promiseCapability.Reject !== undefined) return newTypeError( "promiseCapability has to have some undefined fields");
        promiseCapability.Resolve = resolve;
        promiseCapability.Reject = reject;
        return NormalCompletion(undefined);
    };
    setInternalSlot(F, SLOTS.CALL, GetCapabilitiesExecutor_call);
    return F;
}
function InitializePromise(promise, executor) {
    Assert(hasInternalSlot(promise, SLOTS.PROMISESTATE) && (getInternalSlot(promise, SLOTS.PROMISESTATE) === undefined), "InitializePromise: PromiseState doesnt exist or isnt undefined");
    Assert(IsCallable(executor), "executor has to be callable");
    setInternalSlot(promise, SLOTS.PROMISESTATE, "pending");
    setInternalSlot(promise, SLOTS.PROMISERESOLVEREACTIONS, []);
    setInternalSlot(promise, SLOTS.PROMISEREJECTREACTIONS, []);
    var resolvingFunctions = CreateResolvingFunctions(promise);
    var completion = callInternalSlot(SLOTS.CALL, executor, undefined, [resolvingFunctions.Resolve, resolvingFunctions.Reject]);
    if (isAbrupt(completion=ifAbrupt(completion))) {
        var status = callInternalSlot(SLOTS.CALL, resolvingFunctions.Reject, undefined, [completion.value]);
        if (isAbrupt(status)) return status;
    }
    return NormalCompletion(promise);
}
function AllocatePromise(constructor) {
    var obj = OrdinaryCreateFromConstructor(constructor, INTRINSICS.PROMISEPROTOTYPE, [
        SLOTS.PROMISESTATE,
        SLOTS.PROMISECONSTRUCTOR,
        SLOTS.PROMISERESULT,
        SLOTS.PROMISERESOLVEREACTIONS,
        SLOTS.PROMISEREJECTREACTIONS
    ]);
    setInternalSlot(obj, "toString", function () {
            return "[object PromiseExoticObject]";
    }); // all tostrings will be removed when typed memory comes (there is no tostring but a serialisation)
    setInternalSlot(obj, SLOTS.PROMISECONSTRUCTOR, constructor);
    return obj;
}
function IsPromise(x) {
    if (Type(x) !== OBJECT) return false;
    if (!hasInternalSlot(x, SLOTS.PROMISESTATE)) return false;
    return getInternalSlot(x, SLOTS.PROMISESTATE) !== undefined;
}
function makeIdentityFunction () {
    var F = OrdinaryFunction();
    var Identity_call = function (thisArg, argList) {
        var x = argList[0];
        return NormalCompletion(x);
    };
    setInternalSlot(F, SLOTS.CALL, Identity_call);
    SetFunctionName(F, "IdentityFunction");
    SetFunctionLength(F, 1);
    return F;
}
function makeResolutionHandlerFunction () {
    var handler = OrdinaryFunction();
    var handler_call = function (thisArg, argList) {
        var x = argList[0];
        var promise = getInternalSlot(handler, SLOTS.PROMISE);
        var fulfillmentHandler = getInternalSlot(handler, SLOTS.FULFILLMENTHANDLER);
        var rejectionHandler = getInternalSlot(handler, SLOTS.REJECTIONHANDLER);
        if (SameValue(x, promise)) {
            var selfResolutionError = newTypeError( "selfResolutionError");
            return callInternalSlot(SLOTS.CALL, rejectionHandler, undefined, [selfResolutionError]);
        }
        var C = getInternalSlot(promise, SLOTS.PROMISECONSTRUCTOR);
        var promiseCapability = NewPromiseCapability(C);
        if (isAbrupt(promiseCapability = ifAbrupt(promiseCapability))) return promiseCapability;
        var updateResult = UpdatePromiseFromPotentialThenable(x, promiseCapability);
        if (isAbrupt(updateResult = ifAbrupt(updateResult))) return updateResult;
        if (updateResult !== "not a thenable") {
            return Invoke(promiseCapability.Promise, "then", [fulfillmentHandler, rejectionHandler]);
        }
        return callInternalSlot(SLOTS.CALL, fulfillmentHandler, undefined, [x]);
    };
    setInternalSlot(handler, SLOTS.CALL, handler_call);
    return handler;
}
function makeThrowerFunction () {
    var F = OrdinaryFunction();
    var ThrowerFunction_call = function (thisArg, argList) {
        var e = argList[0];
        return Completion("throw", e, empty);
    };
    setInternalSlot(F, SLOTS.CALL, ThrowerFunction_call);
    SetFunctionName(F, "ThrowerFunction");
    SetFunctionLength(F, 1);
    return F;
}
function PromiseAll(promiseList) {
}
function PromiseCatch(promise, rejectedAction) {
}
function PromiseThen(promise, resolvedAction, rejectedAction) {
}
// ===========================================================================================================
// Regular Expressiong	
// ===========================================================================================================

MakeConstructor(RegExpConstructor, true, RegExpPrototype);

var RegExp_$$create = function (thisArg, argList) {
    return RegExpAllocate(thisArg);
};
var RegExp_Call = function (thisArg, argList) {
    var func = RegExpConstructor;
    var pattern = argList[0];
    var flags = argList[1];
    var O = thisArg;
    var P, F, testP;
    if (!hasInternalSlot(O, SLOTS.REGEXPMATCHER) || getInternalSlot(O, SLOTS.REGEXPMATCHER) !== undefined) {
        if (testP=(Type(pattern) === OBJECT && hasInternalSlot(pattern, SLOTS.REGEXPMATCHER))) return pattern;
        O = RegExpAllocate(func);
        if (isAbrupt(O = ifAbrupt(O))) return O;
    }
    if (testP) {
        if (getInternalSlot(pattern, SLOTS.REGEXPMATCHER) !== undefined) return newTypeError( "patterns [[RegExpMatcher]] isnt undefined");
        if (flags != undefined) return newTypeError( "flag should be undefined for this call");
        P = getInternalSlot(pattern, SLOTS.ORIGINALSOURCE);
        F = getInternalSlot(pattern, SLOTS.ORIGINALFLAGS);
    } else {
        P = pattern;
        F = flags;
    }
    return RegExpInitialize(O, P, F);
};
var RegExp_Construct = function (argList) {
    return Construct(this, argList);
};
var RegExpPrototype_get_global = function (thisArg, argList) {
    var R = thisArg;
    if (Type(R) !== OBJECT) return newTypeError( "this value is no object");
    if (!hasInternalSlot(R, SLOTS.ORIGINALFLAGS)) return newTypeError( "this value has no [[OriginalFlags]]");
    var flags = getInternalSlot(R, SLOTS.ORIGINALFLAGS);
    return NormalCompletion(flags.indexOf("g") > -1);
};
var RegExpPrototype_get_multiline = function (thisArg, argList) {
    var R = thisArg;
    if (Type(R) !== OBJECT) return newTypeError( "this value is no object");
    if (!hasInternalSlot(R, SLOTS.ORIGINALFLAGS)) return newTypeError( "this value has no [[OriginalFlags]]");
    var flags = getInternalSlot(R, SLOTS.ORIGINALFLAGS);
    return NormalCompletion(flags.indexOf("m") > -1);
};
var RegExpPrototype_get_ignoreCase = function (thisArg, argList) {
    var R = thisArg;
    if (Type(R) !== OBJECT) return newTypeError( "this value is no object");
    if (!hasInternalSlot(R, SLOTS.ORIGINALFLAGS)) return newTypeError( "this value has no [[OriginalFlags]]");
    var flags = getInternalSlot(R, SLOTS.ORIGINALFLAGS);
    return NormalCompletion(flags.indexOf("i") > -1);
};
var RegExpPrototype_get_sticky = function (thisArg, argList) {
    var R = thisArg;
    if (Type(R) !== OBJECT) return newTypeError( "this value is no object");
    if (!hasInternalSlot(R, SLOTS.ORIGINALFLAGS)) return newTypeError( "this value has no [[OriginalFlags]]");
    var flags = getInternalSlot(R, SLOTS.ORIGINALFLAGS);
    return NormalCompletion(flags.indexOf("y") > -1);
};

var RegExpPrototype_get_unicode = function (thisArg, argList) {
    var R = thisArg;
    if (Type(R) !== OBJECT) return newTypeError( "this value is no object");
    if (!hasInternalSlot(R, SLOTS.ORIGINALFLAGS)) return newTypeError( "this value has no [[OriginalFlags]]");
    var flags = getInternalSlot(R, SLOTS.ORIGINALFLAGS);
    return NormalCompletion(flags.indexOf("u") > -1);
};

var RegExpPrototype_get_source = function (thisArg, argList) {
    var R = thisArg;
    if (Type(R) !== OBJECT) return newTypeError( "this value is no object");
    if (!hasInternalSlot(R, SLOTS.ORIGINALSOURCE)) return newTypeError( "this value has no [[OriginalSource]]");
    if (!hasInternalSlot(R, SLOTS.ORIGINALFLAGS)) return newTypeError( "this value has no [[OriginalFlags]]");
    var source =getInternalSlot(R, SLOTS.ORIGINALSOURCE);
    var flags = getInternalSlot(R, SLOTS.ORIGINALFLAGS);
    if (source === undefined || flags === undefined) return newTypeError( "source and flags may not be undefined");
    return EscapeRegExpPattern(source, flags);
};


var RegExpPrototype_exec = function (thisArg, argList) {
    var R = thisArg;
    var string = argList[0];
    var S;
    if (Type(R) !== OBJECT) return newTypeError( "this value is not an object");
    if (!hasInternalSlot(R, SLOTS.REGEXPMATCHER)) return newTypeError( "this value has not [[RegExpMatcher]] internal slot");
    if (getInternalSlot(R, SLOTS.REGEXPMATCHER) === undefined) return newTypeError( "this value has not [[RegExpMatcher]] internal slot defined");
    S = ToString(string);
    if (isAbrupt(S=ifAbrupt(S))) return S;
    return RegExpExec(R,S);
};

var RegExpPrototype_search = function (thisArg, argList) {
    var rx = thisArg;
    var S = argList[0];
    if (Type(rx) !== OBJECT) return newTypeError( "this value is not an obect");
    if (!hasInternalSlot(rx, SLOTS.REGEXPMATCHER)) return newTypeError( "this value has no [[RegExpMatcher]] internal slot");
    var matcher = getInternalSlot(rx, SLOTS.REGEXPMATCHER);
    var string = ToString(S);
    if (isAbrupt(string=ifAbrupt(string))) return string;
    var result = RegExpExec(rx, string, true);
    if (isAbrupt(result=ifAbrupt(result))) return result;
    if (result == null) return -1;
    return Get(result, "index");
};
var RegExpPrototype_match = function (thisArg, argList) {
    var rx = thisArg;
    var string = argList[0];
    var S;
    if (Type(rx) !== OBJECT) return newTypeError( "this value is not an object");
    if (!hasInternalSlot(rx, SLOTS.REGEXPMATCHER)) return newTypeError( "this value has not [[RegExpMatcher]] internal slot");
    if (getInternalSlot(rx, SLOTS.REGEXPMATCHER) === undefined) return newTypeError( "this value has not [[RegExpMatcher]] internal slot defined");
    S = ToString(string);
    if (isAbrupt(S=ifAbrupt(S))) return S;
    var global = ToBoolean(Get(rx, "global"));
    if (isAbrupt(global=ifAbrupt(global))) return global;
    if (!global) {
        return RegExpExec(rx, S);
    } else {
        var putStatus = Put(rx, "lastIndex", 0, true);
        if (isAbrupt(putStatus)) return putStatus;
        var A = ArrayCreate(0);
        var previousLastIndex = 0;
        var n = 0;
        var lastMatch = true;
        while (lastMatch) {
            var result = RegExpExec(rx, S);
            if (isAbrupt(result=ifAbrupt(result))) return result;
            if (result === null) lastMatch = false;
            else {
                var thisIndex = ToInteger(Get(rx, "lastIndex"));
                if (isAbrupt(thisIndex=ifAbrupt(thisIndex))) return thisIndex;
                if (thisIndex === previousLastIndex) {
                    putStatus = Put(rx, "lastIndex", thisIndex + 1, true);
                    if (isAbrupt(putStatus)) return putStatus;
                    previousLastIndex = thisIndex + 1;
                } else {
                    previousLastIndex = thisIndex;
                }
                var matchStr = Get(result, "0");
                var defineStatus = CreateDataPropertyOrThrow(A, ToString(n), matchStr);
                if (isAbrupt(defineStatus)) return defineStatus;
                n =  n + 1;
            }
        }
        if (n === 0) return NormalCompletion(null);
        return NormalCompletion(A);
    }
};

var RegExpPrototype_test = function (thisArg, argList) {
    var R = thisArg;
    var string = argList[0];
    if (Type(R) !== OBJECT) return newTypeError( "this value is no object");
    var match = Invoke(R, "exec", [string]);
    if (isAbrupt(match=ifAbrupt(match))) return match;
    return NormalCompletion(match !== null);
};


var RegExpPrototype_compile = function (thisArg, argList) {



};
var RegExpPrototype_split = function (thisArg, argList) {

};

var RegExpPrototype_replace = function (thisArg, argList) {
    var string = argList[0];
    var replaceValue = argList[1];
    var rx = thisArg;
    var S;
    if (Type(rx) !== OBJECT) return newTypeError( "this value is not an object");
    if (!hasInternalSlot(rx, SLOTS.REGEXPMATCHER)) return newTypeError( "this value has not [[RegExpMatcher]] internal slot");
    if (getInternalSlot(rx, SLOTS.REGEXPMATCHER) === undefined) return newTypeError( "this value has not [[RegExpMatcher]] internal slot defined");

    var nCaptures = rx.NCapturingParens;
    S = ToString(string);
    if (isAbrupt(S=ifAbrupt(S))) return S;
    var functionalReplace = IsCallable(replaceValue);
    var global = ToBoolean(Get(rx, "global"));
    if (isAbrupt(global=ifAbrupt(global))) return global;
    var accumulatedResult = "";
    var nextSrcPosition = 0;
    if (global) {
        var putStatus = Put(rx, "lastIndex", 0, true);
        if (isAbrupt(putStatus)) return putStatus;
    }
    previousLastIndex = 0;
    var done = false;
    accumulatedResult = "";
    nextSrcPosition = 0;
    var previousLastIndex;
    while (!done) {
        var result = RegExpExec(rx, S);
        if (isAbrupt(result=ifAbrupt(result))) return result;
        if (result === null) done = true;
        else {
            if (global) {
                var thisIndex = ToInteger(Get(rx, "lastIndex"));
                if (isAbrupt(thisIndex = ifAbrupt(thisIndex))) return thisIndex;
                if (thisIndex === previousLastIndex) {
                    putStatus = Put(rx, "lastIndex", thisIndex + 1, true);
                    if (isAbrupt(putStatus)) return putStatus;
                    previousLastIndex = thisIndex + 1;
                } else {
                    previousLastIndex = thisIndex;
                }
            }
            var sub = GetRegExpSubstitution(result);
            var matched = Get(result, "0");
            if (isAbrupt(matched=ifAbrupt(matched))) return matched;
            var position = Get(result, "index");
            if (isAbrupt(position = ifAbrupt(position))) return position;
            var n = 0;
            var captures = [];
            while (n < nCaptures) {
                var capN = Get(result, ToString(n));
                if(isAbrupt(capN=ifAbrupt(capN))) return capN;
                captures.push(capN);
                n = n + 1;
            }
            if (functionalReplace === true) {
                var replacerArgs = [matched];
                replacerArgs = replacerArgs.concat(captures);
                var replValue = callInternalSlot(SLOTS.CALL, replaceValue, undefined, replacerArgs);
                var replacement = ToString(replValue);
            } else {
                replacement = GetReplaceSubstitution(matched, string, position, captures);
            }
            if (isAbrupt(replacement=ifAbrupt(replacement))) return replacement;
            var matchLength = matched.length;
            var replStr = ToString(replacement);
            if (isAbrupt(replStr=ifAbrupt(replStr))) return replStr;


            /*

             Achtung: Dokument pruefen

             Steps verschoben ???


             */
        /*
            return {
                position: position,
                matchLength: matchLength,
                replacement: replString
            }; */

            accumulatedResult = accumulatedResult + S.substr(nextSrcPosition, position - nextSrcPosition);
            nextSrcPosition = position + matchLength;
        }

    }

    return NormalCompletion( accumulatedResult + S.substr(nextSrcPosition, S.length - nextSrcPosition) );
};


var RegExpPrototype_toString = function (thisArg, argList) {
    var R = thisArg;
    if (Type(R) !== OBJECT) return newTypeError( "this value is not an object");
    if (!hasInternalSlot(R, SLOTS.REGEXPMATCHER)) return newTypeError( "this value has not [[RegExpMatcher]] internal slot");
    if (getInternalSlot(R, SLOTS.REGEXPMATCHER) === undefined) return newTypeError( "this value has not [[RegExpMatcher]] internal slot defined");
    var pattern = ToString(Get(R, "source"));
    if (isAbrupt(pattern=ifAbrupt(pattern))) return pattern;
    var result = "/" + pattern + "/";
    var global = ToBoolean(Get(R, "global"));
    if (isAbrupt(global=ifAbrupt(global))) return global;
    if (global) result += "g";

    var ignoreCase = ToBoolean(Get(R, "ignoreCase"));
    if (isAbrupt(ignoreCase=ifAbrupt(ignoreCase))) return ignoreCase;
    if (ignoreCase) result += "i";

    var multiline = ToBoolean(Get(R, "multiline"));
    if (isAbrupt(multiline=ifAbrupt(multiline))) return multiline;
    if (multiline) result += "m";

    var unicode = ToBoolean(Get(R, "unicode"));
    if (isAbrupt(unicode=ifAbrupt(unicode))) return unicode;
    if (unicode) result += "u";

    var sticky = ToBoolean(Get(R, "sticky"));
    if (isAbrupt(sticky=ifAbrupt(sticky))) return sticky;
    if (sticky) result += "y";
    return NormalCompletion(result);
};


setInternalSlot(RegExpConstructor, SLOTS.CALL, RegExp_Call);
setInternalSlot(RegExpConstructor, SLOTS.CONSTRUCT, RegExp_Construct);

LazyDefineBuiltinConstant(RegExpConstructor, "prototype", RegExpPrototype);
LazyDefineBuiltinConstant(RegExpPrototype, "constructor", RegExpConstructor);

LazyDefineBuiltinConstant(RegExpPrototype, $$isRegExp, true);
LazyDefineBuiltinConstant(RegExpPrototype, $$toStringTag, "RegExp");
LazyDefineBuiltinFunction(RegExpConstructor, $$create, 1, RegExp_$$create);

LazyDefineAccessorFunction(RegExpPrototype, "ignoreCase",  0, RegExpPrototype_get_ignoreCase);
LazyDefineAccessorFunction(RegExpPrototype, "global",  0, RegExpPrototype_get_global);
LazyDefineAccessorFunction(RegExpPrototype, "multiline",  0, RegExpPrototype_get_multiline);
LazyDefineAccessorFunction(RegExpPrototype, "source",  0, RegExpPrototype_get_source);
LazyDefineAccessorFunction(RegExpPrototype, "sticky",  0, RegExpPrototype_get_sticky);
LazyDefineAccessorFunction(RegExpPrototype, "unicode", 0, RegExpPrototype_get_unicode);

LazyDefineProperty(RegExpPrototype, "lastIndex", 0);

LazyDefineBuiltinFunction(RegExpPrototype, "compile", 1, RegExpPrototype_compile);
LazyDefineBuiltinFunction(RegExpPrototype, "exec", 1, RegExpPrototype_exec);
LazyDefineBuiltinFunction(RegExpPrototype, "match", 1, RegExpPrototype_match);
LazyDefineBuiltinFunction(RegExpPrototype, "replace", 1, RegExpPrototype_replace);
LazyDefineBuiltinFunction(RegExpPrototype, "search", 1, RegExpPrototype_search);
LazyDefineBuiltinFunction(RegExpPrototype, "split", 1, RegExpPrototype_split);
LazyDefineBuiltinFunction(RegExpPrototype, "test", 1, RegExpPrototype_test);
LazyDefineBuiltinFunction(RegExpPrototype, "toString", 1, RegExpPrototype_toString);





// ===========================================================================================================
// ArrayBuffer
// ===========================================================================================================

setInternalSlot(ArrayBufferConstructor, SLOTS.CALL, function (thisArg, argList) {
    var length = argList[0];
    var O = thisArg;
    if (Type(O) !== OBJECT || (!hasInternalSlot(O, SLOTS.ARRAYBUFFERDATA)) || (getInternalSlot(O, SLOTS.ARRAYBUFFERDATA) !== undefined)) {
        return newTypeError( "Can not initialize the this argument as an ArrayBuffer or it is already initialized!");
    }
    Assert(getInternalSlot(O, SLOTS.ARRAYBUFFERDATA) === undefined, "ArrayBuffer has already to be initialized here but it is not.");
    var numberLength = ToNumber(length);
    var byteLength = ToInteger(numberLength);
    if (isAbrupt(byteLength = ifAbrupt(byteLength))) return byteLength;
    if ((numberLength != byteLength) || (byteLength < 0)) return newRangeError( "invalid byteLength");
    return SetArrayBufferData(O, byteLength);
});

setInternalSlot(ArrayBufferConstructor, SLOTS.CONSTRUCT, function (argList) {
    var F = ArrayBufferConstructor;
    return OrdinaryConstruct(F, argList);
});


setInternalSlot(ArrayBufferConstructor, SLOTS.PROTOTYPE, FunctionPrototype);
DefineOwnProperty(ArrayBufferConstructor, "prototype", {
    value: ArrayBufferPrototype,
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(ArrayBufferConstructor, "isView", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var arg = argList[0];
        if (Type(arg) !== OBJECT) return false;
        return hasInternalSlot(arg, SLOTS.VIEWEDARRAYBUFFER);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(ArrayBufferConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var F = thisArg;
        return AllocateArrayBuffer(F);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(ArrayBufferPrototype, "constructor", {
    value: ArrayBufferConstructor,
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(ArrayBufferPrototype, $$toStringTag, {
    value: "ArrayBuffer",
    writable: false,
    enumerable: false,
    configurable: false
});
setInternalSlot(ArrayBufferPrototype, SLOTS.PROTOTYPE, ObjectPrototype);
DefineOwnProperty(ArrayBufferPrototype, "byteLength", {
    get: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var O = thisArg;
        if (!hasInternalSlot(O, SLOTS.ARRAYBUFFERDATA)) return newTypeError( "The this argument hasnÂ´t [[ArrayBufferData]]");
        if (getInternalSlot(O, SLOTS.ARRAYBUFFERDATA) === undefined) return newTypeError( "The this arguments [[ArrayBufferData]] is not initialized");
        var length = getInternalSlot(O, SLOTS.ARRAYBUFFERBYTELENGTH);
        return length;
    }),
    set: undefined,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(ArrayBufferPrototype, "slice", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var start = argList[0];
        var end = argList[1];
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

var DataViewConstructor_Call= function (thisArg, argList) {
    var O = thisArg;
    var buffer = argList[0];
    var byteOffset = argList[1];
    var byteLength = argList[2];
    if (byteOffset === undefined) byteOffset = 0;
    if (Type(O) !== OBJECT || !hasInternalSlot(O, SLOTS.DATAVIEW)) return newTypeError( "DataView object expected");
    Assert(hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER), "O has to have a ViewedArrayBuffer slot.");
    var viewedArrayBuffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (viewedArrayBuffer !== undefined) return newTypeError( "ViewedArrayBuffer of DataView has to be undefined.");
    if (Type(buffer) !== OBJECT) return newTypeError( "buffer has to be an arraybuffer object");
    var arrayBufferData;
    if (!hasInternalSlot(buffer, SLOTS.ARRAYBUFFERDATA)) return newTypeError( "In DataView(buffer), buffer has to have ArrayBufferData slot");
    arrayBufferData = getInternalSlot(buffer, SLOTS.ARRAYBUFFERDATA);
    if (arrayBufferData === undefined) return newTypeError( "arrayBufferData of buffer may not be undefined");
    var numberOffset = ToNumber(byteOffset);
    var offset = ToInteger(numberOffset);
    if (isAbrupt(offset=ifAbrupt(offset))) return offset;
    if (numberOffset !== offset || offset < 0) return newRangeError( "numberOffset is not equal to offset or is less than 0.");
    var byteBufferLength = getInternalSlot(buffer, SLOTS.ARRAYBUFFERBYTELENGTH);
    if (offset > byteBufferLength) return newRangeError( "offset > byteBufferLength");
    if (byteLength === undefined) {
        var viewByteLength = byteBufferLength - offset;
    } else {
        var numberLength = ToNumber(byteLength);
        var viewLength = ToInteger(numberLength);
        if (isAbrupt(viewLength=ifAbrupt(viewLength))) return viewLength;
        if ((numberLength != viewLength) || viewLength < 0) return newRangeError("numberLength != viewLength or viewLength < 0");
        var viewByteLength = viewLength;
        if ((offset+viewByteLength) > byteBufferLength) return newRangeError("offset + viewByteLength > byteBufferLength");
    }
    if (getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER) !== undefined) return newTypeError( "ViewedArrayBuffer of O has to be undefined here");
    setInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER, buffer);
    setInternalSlot(O, SLOTS.BYTELENGTH, viewByteLength);
    setInternalSlot(O, SLOTS.BYTEOFFSET, offset);
    return NormalCompletion(O);
};

var DataViewConstructor_Construct = function (argList) {
    return OrdinaryConstruct(this, argList);
};

var DataViewConstructor_$$create = function (thisArg, argList) {
    var F = thisArg;
    var obj = OrdinaryCreateFromConstructor(F, INTRINSICS.DATAVIEWPROTOTYPE, [
        SLOTS.DATAVIEW,
        SLOTS.VIEWEDARRAYBUFFER,
        SLOTS.BYTELENGTH,
        SLOTS.BYTEOFFSET
    ]);
    setInternalSlot(obj, SLOTS.DATAVIEW, true);
    return obj;
};

var DataViewPrototype_get_buffer = function (thisArg, argList) {
    var O = thisArg;
    if (Type(O) !== OBJECT) return newTypeError( "O is not an object");
    if (!hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER)) return newTypeError( "O has no ViewedArrayBuffer slot");
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError( "buffer is undefined but must not");
    return NormalCompletion(buffer);
};

var DataViewPrototype_get_byteLength = function (thisArg, argList) {
    var O = thisArg;
    if (Type(O) !== OBJECT) return newTypeError( "O is not an object");
    if (!hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER)) return newTypeError( "O has no ViewedArrayBuffer property");
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError( "buffer is undefined");
    var size = getInternalSlot(O, SLOTS.BYTELENGTH);
    return NormalCompletion(size);
};

var DataViewPrototype_get_byteOffset = function (thisArg, argList) {
    var O = thisArg;
    if (Type(O) !== OBJECT) return newTypeError( "O is not an object");
    if (!hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER)) return newTypeError( "O has no ViewedArrayBuffer property");
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError( "buffer is undefined");
    var offset = getInternalSlot(O, SLOTS.BYTEOFFSET);
    return NormalCompletion(offset);
};


var DataViewPrototype_getFloat32 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var littleEndian = argList[1];
    if (littleEndian == undefined) littleEndian = false;
    return GetViewValue(v, byteOffset, littleEndian, "Float32");
};

var DataViewPrototype_getFloat64 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var littleEndian = argList[1];
    if (littleEndian == undefined) littleEndian = false;
    return GetViewValue(v, byteOffset, littleEndian, "Float64");
};

var DataViewPrototype_getInt8 = function (thisArg, argList) {
    var byteOffset = argList[0];
    var v = thisArg;
    return GetViewValue(v, byteOffset, undefined, "Int8");
};

var DataViewPrototype_getInt16 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var littleEndian = argList[1];
    if (littleEndian == undefined) littleEndian = false;
    return GetViewValue(v, byteOffset, littleEndian, "Int16");
};


var DataViewPrototype_getInt32 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var littleEndian = argList[1];
    if (littleEndian == undefined) littleEndian = false;
    return GetViewValue(v, byteOffset, littleEndian, "Int32");
};


var DataViewPrototype_getUint8 = function (thisArg, argList) {
    var byteOffset = argList[0];
    var v = thisArg;
    return GetViewValue(v, byteOffset, undefined, "Uint8");
};

var DataViewPrototype_getUint16 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var littleEndian = argList[1];
    if (littleEndian == undefined) littleEndian = false;
    return GetViewValue(v, byteOffset, littleEndian, "Uint16");
};
var DataViewPrototype_getUint32 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var littleEndian = argList[1];
    if (littleEndian == undefined) littleEndian = false;
    return GetViewValue(v, byteOffset, littleEndian, "Uint32");
};

var DataViewPrototype_setFloat32 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    var littleEndian = argList[2];
    if (littleEndian == undefined) littleEndian = false;
    return SetViewValue(v, byteOffset, littleEndian, "Float32", value);
};

var DataViewPrototype_setFloat64 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    var littleEndian = argList[2];
    if (littleEndian == undefined) littleEndian = false;
    return SetViewValue(v, byteOffset, littleEndian, "Float64", value);
};

var DataViewPrototype_setInt8 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    return SetViewValue(v, byteOffset, undefined, "Int8", value);
};
var DataViewPrototype_setInt16 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    var littleEndian = argList[2];
    if (littleEndian == undefined) littleEndian = false;
    return SetViewValue(v, byteOffset, littleEndian, "Int16", value);
};

var DataViewPrototype_setInt32 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    var littleEndian = argList[2];
    if (littleEndian == undefined) littleEndian = false;
    return SetViewValue(v, byteOffset, littleEndian, "Int32", value);
};

var DataViewPrototype_setUint8 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    return SetViewValue(v, byteOffset, undefined, "Uint8", value);
};
var DataViewPrototype_setUint16 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    var littleEndian = argList[2];
    if (littleEndian == undefined) littleEndian = false;
    return SetViewValue(v, byteOffset, littleEndian, "Uint16", value);
};

var DataViewPrototype_setUint32 = function (thisArg, argList) {
    var v = thisArg;
    var byteOffset = argList[0];
    var value = argList[1];
    var littleEndian = argList[2];
    if (littleEndian == undefined) littleEndian = false;
    return SetViewValue(v, byteOffset, littleEndian, "Uint32", value);
};



MakeConstructor(DataViewConstructor, true, DataViewPrototype);
setInternalSlot(DataViewConstructor, SLOTS.CALL, DataViewConstructor_Call);
setInternalSlot(DataViewConstructor, SLOTS.CONSTRUCT, DataViewConstructor_Construct);
LazyDefineBuiltinFunction(DataViewConstructor, $$create, 1, DataViewConstructor_$$create);
LazyDefineAccessorFunction(DataViewPrototype, "buffer", 0, DataViewPrototype_get_buffer);
LazyDefineAccessorFunction(DataViewPrototype, "byteLength", 0, DataViewPrototype_get_byteLength);
LazyDefineAccessorFunction(DataViewPrototype, "byteOffset", 0, DataViewPrototype_get_byteOffset);
LazyDefineBuiltinFunction(DataViewPrototype, "getFloat32", 1, DataViewPrototype_getFloat32);
LazyDefineBuiltinFunction(DataViewPrototype, "getFloat64", 1, DataViewPrototype_getFloat64);
LazyDefineBuiltinFunction(DataViewPrototype, "getInt8", 1, DataViewPrototype_getInt8);
LazyDefineBuiltinFunction(DataViewPrototype, "getInt16", 1, DataViewPrototype_getInt16);
LazyDefineBuiltinFunction(DataViewPrototype, "getInt32", 1, DataViewPrototype_getInt32);
LazyDefineBuiltinFunction(DataViewPrototype, "getUint8", 1, DataViewPrototype_getUint8);
LazyDefineBuiltinFunction(DataViewPrototype, "getUint16", 1, DataViewPrototype_getUint16);
LazyDefineBuiltinFunction(DataViewPrototype, "getUint32", 1, DataViewPrototype_getUint32);
LazyDefineBuiltinFunction(DataViewPrototype, "setFloat32", 2, DataViewPrototype_setFloat32);
LazyDefineBuiltinFunction(DataViewPrototype, "setFloat64", 2, DataViewPrototype_setFloat64);
LazyDefineBuiltinFunction(DataViewPrototype, "setInt8", 2, DataViewPrototype_setInt8);
LazyDefineBuiltinFunction(DataViewPrototype, "setInt16", 2, DataViewPrototype_setInt16);
LazyDefineBuiltinFunction(DataViewPrototype, "setInt32", 2, DataViewPrototype_setInt32);
LazyDefineBuiltinFunction(DataViewPrototype, "setUint8", 2, DataViewPrototype_setUint8);
LazyDefineBuiltinFunction(DataViewPrototype, "setUint16", 2, DataViewPrototype_setUint16);
LazyDefineBuiltinFunction(DataViewPrototype, "setUint32", 2, DataViewPrototype_setUint32);
LazyDefineBuiltinConstant(DataViewConstructor, $$toStringTag, SLOTS.DATAVIEW);

var TypedArrayConstructor_Call = function (thisArg, argList) {
    var array, typedArray, length;
    array = argList[0];
    var O;
    var elementType;
    var numberLength;
    var elementLength;
    var elementSize;
    var byteLength;
    var status;
    var data;
    var constructorName;
    if (Type(array) === OBJECT) {
        if (IsArray(array)) {
            Assert((Type(array) === OBJECT) && !hasInternalSlot(array, SLOTS.TYPEDARRAYNAME) && !hasInternalSlot(array, SLOTS.ARRAYBUFFERDATA),
                "array has to be an object without [[TypedArrayName]] or [[ArrayBufferData]] slots");
            O = thisArg;
            var srcArray = array;
            if (Type(O) != OBJECT || !hasInternalSlot(O, SLOTS.TYPEDARRAYNAME)) return withError(
                "Type", "this value is no object or has no [[TypedArrayName]] slot"
            );
            Assert(hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER), "this value has no [[ViewedArrayBuffer]] slot");
            var constructorName = getInternalSlot(O, SLOTS.TYPEDARRAYNAME);
            var elementType = TypedArrayElementType[constructorName];
            var arrayLength = Get(srcArray, "length");
            if (isAbrupt(arrayLength=ifAbrupt(arrayLength))) return arrayLength;
            var elementLength = ToLength(arrayLength);
            if (isAbrupt(elementLength=ifAbrupt(elementLength))) return elementLength;
            var data = AllocateArrayBuffer(getIntrinsic(INTRINSICS.ARRAYBUFFER));
            if (isAbrupt(data=ifAbrupt(data))) return data;
            var elementSize = typedArrayElementSize[elementType];
            var byteLength = elementSize * elementLength;
            var status = SetArrayBufferData(data, byteLength);
            if (isAbrupt(status)) return status;
            var k = 0;
            while (k < elementLength) {
                var Pk = ToString(k);
                var kValue = Get(srcArray, Pk);
                var kNumber = ToNumber(k);
                if (isAbrupt(kNumber=ifAbrupt(kNumber))) return kNumber;
                SetValueInBuffer(data, k * elementSize, elementType, kNumber);
                k = k + 1;
            }
            if (getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER) !== undefined) return newTypeError( "the this values [[ViewedArrayBuffer]] may not be initialized here");
            setInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER, data);
            setInternalSlot(O, SLOTS.BYTELENGTH, byteLength);
            setInternalSlot(O, SLOTS.BYTEOFFSET, 0);
            setInternalSlot(O, SLOTS.ARRAYLENGTH, elementLength);
            return NormalCompletion(O);
        } else if ((typedArray = array) instanceof IntegerIndexedExoticObject) {
            Assert((Type(typedArray) === OBJECT) && hasInternalSlot(typedArray, SLOTS.TYPEDARRAYNAME), "typedArray has to be an object and to have a TypedArrayName slot");
            var srcArray = typedArray;
            O = thisArg;
            if ((Type(O) !== OBJECT) || getInternalSlot(O, SLOTS.TYPEDARRAYNAME)===undefined) return newTypeError( "this value has to be object and to have a defined TypedArrayName slot");
            Assert(hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER), "this value has to have a ViewedArrayBuffer slot");
            if (getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER) === undefined) return newTypeError( "ViewedArrayBuffer may not be undefined");
            var constructorName = getInternalSlot(O, SLOTS.TYPEDARRAYNAME);
            var elementType = TypedArrayElementType[constructorName];
            var elementLength = getInternalSlot(srcArray, SLOTS.ARRAYLENGTH);
            var srcName = getInternalSlot(srcArray, SLOTS.TYPEDARRAYNAME);
            var srcType = TypedArrayElementType[srcName];
            var srcElementSize = typedArrayElementSize[srcType];
            var srcData = getInternalSlot(srcArray, SLOTS.VIEWEDARRAYBUFFER);
            var srcByteOffset = getInternalSlot(srcArray, SLOTS.BYTEOFFSET);
            var elementSize = typedArrayElementSize[constructorName];
            var byteLength = elementSize * elementLength;
            if (SameValue(elementType, srcType)) {
                var data = CloneArrayBuffer(srcData, srcByteOffset);
                if (isAbrupt(data=ifAbrupt(data))) return data;
            } else {
                var bufferConstructor = Get(srcBuffer, "constructor");
                if (isAbrupt(bufferConstructor=ifAbrupt(bufferConstructor))) return bufferConstructor;
                if (bufferConstructor === undefined) bufferConstructor = getIntrinsic(INTRINSICS.ARRAYBUFFER);
                var data = AllocateArrayBuffer(bufferConstructor);
                var status = SetArrayBufferData(data, byteLength);
                if (isAbrupt(status=ifAbrupt(status))) return status;
                var srcByteIndex = srcByteOffset;
                var targetByteIndex = 0;
                var count = elementLength;
                while (count > 0) {
                    var value = GetValueFromBuffer(srcData, srcByteIndex, srcType);
                    status = SetValueInBuffer(data, targetByteIndex, elementType, value);
                    srcByteIndex = srcByteIndex + srcElementSize;
                    targetByteIndex = targetByteIndex + elementSize;
                    count = count - 1;
                }
            }
            if (getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER) !== undefined) return newTypeError( "ViewedArrayBuffer may not be defined at this point");
            setInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER, data);
            setInternalSlot(O, SLOTS.BYTELENGTH, byteLength);
            setInternalSlot(O, SLOTS.BYTEOFFSET, 0);
            setInternalSlot(O, SLOTS.ARRAYLENGTH, elementLength);
            return NormalCompletion(O);
        }
    } else if (typeof (length = array) == "number") {
        O = thisArg;
        if (Type(O) !== OBJECT) return newTypeError( "this value is not an object");
        if (!hasInternalSlot(O, SLOTS.TYPEDARRAYNAME)) return newTypeError( "object has no TypedArrayName property");
        Assert(hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER), "object has to have a ViewedArrayBuffer property");
        if (getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER) === undefined) return newTypeError( "object has to have a well defined ViewedArrayBuffer property");
        constructorName = getInternalSlot(O, SLOTS.TYPEDARRAYNAME);
        elementType = TypedArrayElementType[constructorName];
        numberLength = ToNumber(length);
        elementLength = ToLength(numberLength);
        if (isAbrupt(elementLength = ifAbrupt(elementLength))) return elementLength;
        if (SameValueZero(numberLength, elementLength) === false) return newRangeError( "TypedArray: numberLength and elementLength are not equal");
        data = AllocateArrayBuffer(getIntrinsic(INTRINSICS.ARRAYBUFFER));
        if (isAbrupt(data = ifAbrupt(data))) return data;
        elementSize = typedArrayElementSize[elementType];
        byteLength = elementSize * elementLength;
        status = SetArrayBufferData(data, byteLength);
        if (isAbrupt(status = ifAbrupt(status))) return status;
        setInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER, data);
        setInternalSlot(O, SLOTS.BYTELENGTH, byteLength);
        setInternalSlot(O, SLOTS.BYTEOFFSET, 0);
        setInternalSlot(O, SLOTS.ARRAYLENGTH, elementLength);
        return NormalCompletion(O);
    } else {
        Assert(hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER), "O has to have [[ViewedArrayBuffer]]");
        var buffer = argList[0];
        var byteOffset = argList[1];
        if (byteOffset === undefined) byteOffset = 0;
        length = argList[2];
        Assert((Type(buffer) === OBJECT) && hasInternalSlot(buffer, SLOTS.ARRAYBUFFERDATA), "buffer has to be an object and to have [[ArrayBufferData]]");
        O = thisArg;
        var arrayBufferData = getInternalSlot(buffer, SLOTS.ARRAYBUFFERDATA);
        if (arrayBufferData === undefined) return newTypeError( "[[ArrayBufferData]] is undefined");
        if (Type(O) !== OBJECT || !hasInternalSlot(O, SLOTS.TYPEDARRAYNAME)) return newTypeError( "O has to be object and to have [[TypedArrayName]]");
        var viewedArrayBuffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
        var typedArrayName = getInternalSlot(O, SLOTS.TYPEDARRAYNAME);
        if (typedArrayName === undefined) return newTypeError( "O has to have a well defined [[TypedArrayName]]");
        constructorName = getInternalSlot(O, SLOTS.TYPEDARRAYNAME);
        elementType = TypedArrayElementType[constructorName];
        elementSize = typedArrayElementSize[elementType];
        var offset = ToInteger(byteOffset);
        if (isAbrupt(offset = ifAbrupt(offset))) return offset;
        if (offset < 0) return newRangeError( "offset is smaller 0");
        if ((offset % elementSize) !== 0) return newRangeError( "offset mod elementSize is not 0");
        var byteBufferLength = getInternalSlot(buffer, SLOTS.ARRAYBUFFERBYTELENGTH);
        if (offset + elementSize >= byteBufferLength) return newRangeError( "offset + elementSize is >= byteBufferLength");
        var newByteLength;
        if (length === undefined) {
            if (byteBufferLength % elementSize !== 0) return newRangeError( "byteBufferLength mod elementSize is not 0");
            newByteLength = byteBufferLength + offset;
            if (newByteLength < 0) return newRangeError( "newByteLength < 0 underflow when adding offset to byteBufferLength");
        } else {
            var newLength = ToLength(length);
            if (isAbrupt(newLength = ifAbrupt(newLength))) return newLength;
            newByteLength = newLength * elementSize;
            if (offset + newByteLength > byteBufferLength) return newRangeError( "offset + newByteLength is larger than byteBufferLength");
        }
        if (viewedArrayBuffer !== undefined) return newTypeError( "the [[ViewedArrayBuffer]] of O is not empty");
        setInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER, buffer);
        setInternalSlot(O, SLOTS.BYTELENGTH, newByteLength);
        setInternalSlot(O, SLOTS.BYTEOFFSET, offset);
        setInternalSlot(O, SLOTS.ARRAYLENGTH, Math.floor(newByteLength / elementSize));
    }
    return NormalCompletion(O);
};

var typedArrayPrototypeNames = {
    "Float64Array": INTRINSICS.FLOAT64ARRAYPROTOTYPE,
    "Float32Array": INTRINSICS.FLOAT32ARRAYPROTOTYPE,
    "Int32Array": INTRINSICS.INT32ARRAYPROTOTYPE,
    "Uint32Array": INTRINSICS.UINT32ARRAYPROTOTYPE,
    "Int16Array": INTRINSICS.INT16ARRAYPROTOTYPE,
    "Uint16Array": INTRINSICS.UINT16ARRAYPROTOTYPE,
    "Int8Array": INTRINSICS.INT8ARRAYPROTOTYPE,
    "Uint8Array": INTRINSICS.UINT8ARRAYPROTOTYPE,
    "Uint8Clamped": "%Uint8ClampedArrayProtoype%"
};

var TypedArrayConstructor_$$create = function $$create(thisArg, argList) {
    var F = thisArg;
    if (Type(F) !== OBJECT) return newTypeError( "the this value is not an object");
    if (!hasInternalSlot(F, SLOTS.TYPEDARRAYCONSTRUCTOR)) return newTypeError( "The this value has no [[TypedArrayConstructor]] property");
    var proto = GetPrototypeFromConstructor(F, typedArrayPrototypeNames[getInternalSlot(F, SLOTS.TYPEDARRAYCONSTRUCTOR)]);
    if (isAbrupt(proto = ifAbrupt(proto))) return proto;
    var obj = IntegerIndexedObjectCreate(proto);
    setInternalSlot(obj, SLOTS.VIEWEDARRAYBUFFER, undefined);
    setInternalSlot(obj, SLOTS.TYPEDARRAYNAME, getInternalSlot(F, SLOTS.TYPEDARRAYCONSTRUCTOR));
    setInternalSlot(obj, SLOTS.BYTELENGTH, 0);
    setInternalSlot(obj, SLOTS.BYTEOFFSET, 0);
    setInternalSlot(obj, SLOTS.ARRAYLENGTH, 0);
    return obj;
};

var TypedArrayConstructor_from = function from(thisArg, argList) {
    "use strict";
    var source = argList[0];
    var mapfn = argList[1];
    var tArg = argList[2];
    var T;
    var C = thisArg;
    var newObj;
    var putStatus;
    if (!IsConstructor(C)) return newTypeError(format("S_NO_CONSTRUCTOR", "the this value"));
    var items = ToObject(source);
    if (isAbrupt(items = ifAbrupt(items))) return items;
    var mapping;
    var k;
    var nextValue, kValue, Pk;
    if (mapfn === undefined) {
        mapping = false;
    } else {
        if (!IsCallable(mapfn)) return newTypeError(format("S_NOT_CALLABLE", "mapfn"));
        T = tArg;
        mapping = true;
    }
    var usingIterator = HasProperty(items, $$iterator);
    if (isAbrupt(usingIterator = ifAbrupt(usingIterator))) return usingIterator;
    if (usingIterator) {
        var iterator = Get(items, $$iterator);
        iterator = unwrap(iterator);
        var values = [];
        var next = true;
        while (next != false) {
            next = IteratorStept(iterator);
            if (next !== false) {
                nextValue = IteratorValue(next);
                if (isAbrupt(nextValue = ifAbrupt(nextValue))) return nextValue;
                values.push(nextValue);
            }
        }
        var len = values.length;
        newObj = callInternalSlot(SLOTS.CONSTRUCT, C, C, [len]);
        if (isAbrupt(newObj = ifAbrupt(newObj))) return newObj;
        k = 0;
        while (k < len) {
            Pk = ToString(k);
            kValue = values[k];
            if (mapping) {
                mappedValue = callInternalSlot(SLOTS.CALL, mapfn, T, [kValue]);
                if (isAbrupt(mappedValue = ifAbrupt(mappedValue))) return mappedValue;
            } else mappedValue = kValue;
            putStatus = Put(newObj, Pk, mappedValue, true);
            if (isAbrupt(putStatus)) return putStatus;
            k = k + 1;
        }
        return NormalCompletion(newObj);
    }
    Assert(HasProperty(items, "length"), format("EXPECTING_ARRAYLIKE"));
    var lenValue = Get(items, "length");
    len = ToLength(lenValue);
    if (isAbrupt(len = ifAbrupt(len))) return len;
    newObj = callInternalSlot(SLOTS.CONSTRUCT, C, C, [len]);
    if (isAbrupt(newObj = ifAbrupt(newObj))) return newObj;

    var mappedValue;
    k = 0;
    while (k < len) {
        Pk = ToString(k);
        kValue = Get(items, Pk);
        if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
        if (mapping) {
            mappedValue = callInternalSlot(SLOTS.CALL, mapfn, T, [kValue, k, items]);
            if (isAbrupt(mappedValue = ifAbrupt(mappedValue))) return mappedValue;
        } else {
            mappedValue = kValue;
        }
        putStatus = Put(newObj, Pk, mappedValue, true);
        if (isAbrupt(putStatus)) return putStatus;
        k = k + 1;
    }
    return NormalCompletion(newObj);
};


var TypedArrayConstructor_of = function of(thisArg, argList) {
    var items = CreateArrayFromList(argList);
    var lenValue = Get(items, "length");
    var len = ToLength(lenValue);
    if (isAbrupt(len=ifAbrupt(length))) return length;
    var C = thisArg;
    if (IsConstructor(C)) {
        var newObj = callInternalSlot(SLOTS.CONSTRUCT, C, C, [len]);
        if (isAbrupt(newObj = ifAbrupt(newObj))) return newObj;
    } else {
        return newTypeError( "The thisValue has to be a constructor");
    }
    var k = 0;
    var status;
    var Pk, kValue;
    while (k < len) {
        Pk = ToString(k);
        kValue = Get(items, Pk);
        //if (isAbrupt(kValue = ifAbrupt(kValue))) return kValue;
        status = Put(newObj, Pk, kValue, true);
        if (isAbrupt(status = ifAbrupt(status))) return status;
        k = k + 1;
    }
    return NormalCompletion(newObj);
};

setInternalSlot(TypedArrayConstructor, SLOTS.CALL, TypedArrayConstructor_Call);
LazyDefineProperty(TypedArrayConstructor, $$create, CreateBuiltinFunction(realm, TypedArrayConstructor_$$create, 0, "[Symbol.create]"));
LazyDefineProperty(TypedArrayConstructor, "from", CreateBuiltinFunction(realm, TypedArrayConstructor_from, 1, "from"));
LazyDefineProperty(TypedArrayConstructor, "of", CreateBuiltinFunction(realm, TypedArrayConstructor_of, 2, "of"));

// ------------------------------------------------------------------------------------------
// 22.2.6. Typed Array Prototype
// ------------------------------------------------------------------------------------------

var TypedArrayPrototype_get_byteLength = function (thisArg, argList) {
    var O = thisArg;
    if (Type(O) !== OBJECT) return newTypeError( "this value is not an object");
    if (!hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER)) return newTypeError( "has no ViewedArrayBuffer slot");
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError( "slot value for viewed array buffer is undefined");
    var length = getInternalSlot(O, SLOTS.BYTELENGTH);
    return NormalCompletion(length);
};
var TypedArrayPrototype_get_byteOffset = function (thisArg, argList) {
    var O = thisArg;
    if (Type(O) !== OBJECT) return newTypeError( "this value is not an object");
    if (!hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER)) return newTypeError( "has no ViewedArrayBuffer slot");
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError( "slot value for viewed array buffer is undefined");
    var offset = getInternalSlot(O, SLOTS.BYTEOFFSET);
    return NormalCompletion(offset);
};
var TypedArrayPrototype_get_buffer = function (thisArg, argList) {
    var O = thisArg;
    if (Type(O) !== OBJECT) return newTypeError( "this value is not an object");
    if (!hasInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER)) return newTypeError( "has no ViewedArrayBuffer slot");
    var buffer = getInternalSlot(O, SLOTS.VIEWEDARRAYBUFFER);
    if (buffer === undefined) return newTypeError( "slot value for viewed array buffer is undefined");
    return NormalCompletion(buffer);
};

var TypedArrayPrototype_filter = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_find = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_findIndex = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_forEach = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_indexOf = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_join = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_keys = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_lastIndexOf = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_length = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_map = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_reduce = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_reduceRight = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_reverse = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_set = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_slice = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_some = function subarray(thisArg, argList) {
};
var TypedArrayPrototype_sort = function subarray(thisArg, argList) {
};

var TypedArrayPrototype_subarray = function subarray(thisArg, argList) {
};


var TypedArrayPrototype_$$iterator = function iterator(thisArg, argList) {
    return CreateArrayIterator(thisArg, "value");
};

// $$toStringTag
var TypedArrayPrototype_get_$$toStringTag = function get_toStringTag(thisArg, argList) {
    var O = thisArg;
    if (Type(O) !== OBJECT) return newTypeError( "the this value is not an object");
    if (!hasInternalSlot(O, SLOTS.TYPEDARRAYNAME)) return newTypeError( "the this value has no [[TypedArrayName]] slot");
    var name = getInternalSlot(O, SLOTS.TYPEDARRAYNAME);
    Assert(Type(name) == STRING, "name has to be a string value");
    return NormalCompletion(name);
};

function createTypedArrayPrototype(proto) {
    LazyDefineAccessor(proto, "buffer", CreateBuiltinFunction(realm, TypedArrayPrototype_get_buffer, 0, "get buffer"));
    LazyDefineAccessor(proto, "byteLength", CreateBuiltinFunction(realm, TypedArrayPrototype_get_byteLength, 0, "get byteLength"));
    LazyDefineAccessor(proto, "byteOffset", CreateBuiltinFunction(realm, TypedArrayPrototype_get_byteOffset, 0, "get byteOffset"));
    LazyDefineAccessor(proto, $$toStringTag, CreateBuiltinFunction(realm, TypedArrayPrototype_get_$$toStringTag, 0, "get [Symbol.toStringTag]"));
    LazyDefineBuiltinFunction(proto, "forEach", 1, TypedArrayPrototype_map);
    LazyDefineBuiltinFunction(proto, "map", 1, TypedArrayPrototype_map);
    LazyDefineBuiltinFunction(proto, "reduce", 1, TypedArrayPrototype_reduce);
    return proto;
}

function createTypedArrayVariant(_type, _bpe, _ctor, _proto, ctorName) {
    setInternalSlot(_ctor, SLOTS.REALM, getRealm());
    setInternalSlot(_ctor, SLOTS.TYPEDARRAYCONSTRUCTOR, ctorName);
    setInternalSlot(_ctor, SLOTS.PROTOTYPE, TypedArrayConstructor);
    setInternalSlot(_ctor, SLOTS.CALL, function (thisArg, argList) {
        var O = thisArg;
        if (Type(O) !== OBJECT) return newTypeError( "O is not an object");
        if (!hasInternalSlot(O, SLOTS.TYPEDARRAYNAME)) return newTypeError( "[[TypedArrayName]] is missing");
        //if (getInternalSlot(O, SLOTS.TYPEDARRAYNAME) != undefined) return newTypeError( "[[TypedArrayName]] isnt undefined");
        var suffix = "Array";
        if (_type === "Uint8C") suffix = "lamped" + suffix;
        setInternalSlot(O, SLOTS.TYPEDARRAYNAME, _type + suffix);
        var F = this;
        var realmF = getInternalSlot(F, SLOTS.REALM);
        var sup = Get(realmF.intrinsics, INTRINSICS.TYPEDARRAY);
        var args = argList;
        return callInternalSlot(SLOTS.CALL, sup, O, args);
    });
    setInternalSlot(_ctor, SLOTS.CONSTRUCT, function (argList) {
        return OrdinaryConstruct(this, argList);
    });
    LazyDefineBuiltinConstant(_ctor, "BYTES_PER_ELEMENT", _bpe);
    LazyDefineBuiltinConstant(_ctor, "prototype", _proto);
    LazyDefineBuiltinConstant(_proto, "constructor", _ctor);
    createTypedArrayPrototype(_proto);
    return _ctor;
}

createTypedArrayVariant("Int8", 1, Int8ArrayConstructor, Int8ArrayPrototype, "Int8Array");
createTypedArrayVariant("Uint8", 1, Uint8ArrayConstructor, Int8ArrayPrototype, "Uint8Array");
createTypedArrayVariant("Uint8C", 1, Uint8ClampedArrayConstructor, Uint8ClampedArrayPrototype, "Uint8Clamped");
createTypedArrayVariant("Int16", 2, Int16ArrayConstructor, Int16ArrayPrototype, "Int16Array");
createTypedArrayVariant("Uint16", 2, Uint16ArrayConstructor, Uint16ArrayPrototype, "Uint16Array");
createTypedArrayVariant("Int32", 4, Int32ArrayConstructor, Int32ArrayPrototype, "Int32Array");
createTypedArrayVariant("Uint32", 4, Uint32ArrayConstructor, Uint32ArrayPrototype, "Uint32Array");
createTypedArrayVariant("Float32", 8, Float32ArrayConstructor, Float32ArrayPrototype, "Float32Array");
createTypedArrayVariant("Float64", 8, Float64ArrayConstructor, Float64ArrayPrototype, "Float64Array");


// ===========================================================================================================
// set Timeout
// ===========================================================================================================

setInternalSlot(SetTimeoutFunction, SLOTS.CALL, function (thisArg, argList) {
    var func = argList[0];
    var timeout = argList[1] | 0;
    var task;
    if (!IsCallable(func)) return newTypeError( "setTimeout: function argument expected");
    task = {
        time: Date.now(),
        timeout: timeout,
        func: func
    };
    getEventQueue().push(task);
    return task;
});

// ===========================================================================================================
// Map
// ===========================================================================================================

//
// Map, WeakMap, Set

setInternalSlot(MapConstructor, SLOTS.PROTOTYPE, FunctionPrototype);
setInternalSlot(MapPrototype, SLOTS.PROTOTYPE, ObjectPrototype);

setInternalSlot(MapConstructor, SLOTS.CALL, function Call(thisArg, argList) {

    var iterable = argList[0];
    var comparator = argList[1];
    var map = thisArg;

    if (Type(map) !== OBJECT) return newTypeError( "map is not an object");
    if (!hasInternalSlot(map, SLOTS.MAPDATA)) return newTypeError( "MapData property missing on object");
    if (getInternalSlot(map, SLOTS.MAPDATA) !== undefined) return newTypeError( "MapData property already initialized");

    var iter;
    var hasValues, adder;
    if (iterable === undefined || iterable === null) iter = undefined;
    else {
        hasValues = HasProperty(iterable, "entries");
        if (isAbrupt(hasValues = ifAbrupt(hasValues))) return hasValues;
        if (hasValues) iter = Invoke(iterable, "entries");
        else iter = GetIterator(iterable);
        adder = Get(map, "set");
        if (isAbrupt(adder = ifAbrupt(adder))) return adder;
        if (!IsCallable(adder)) return newTypeError( "map adder (the set function) is not callable");
    }
    if (comparator !== undefined) {
        if (comparator !== "is") return newRangeError( "comparator argument has currently to be 'undefined' or 'is'");
    }

    setInternalSlot(map, SLOTS.MAPDATA, Object.create(null));
    setInternalSlot(map, SLOTS.MAPCOMPARATOR, comparator);

    if (iter === undefined) return NormalCompletion(map);

    var next, nextItem, done, k, v, status;
    for (;;) {
        next = IteratorNext(iter);
        if (isAbrupt(next = ifAbrupt(next))) return next;
        done = IteratorComplete(next);
        if (isAbrupt(done = ifAbrupt(done))) return done;
        if (done) return NormalCompletion(map);
        nextItem = IteratorValue(next);
        if (isAbrupt(nextItem = ifAbrupt(nextItem))) return nextItem;
        k = Get(nextItem, "0");
        if (isAbrupt(k = ifAbrupt(k))) return k;
        v = Get(nextItem, "1");
        if (isAbrupt(v = ifAbrupt(v))) return v;
        status = callInternalSlot(SLOTS.CALL, adder, map, [k, v]);
        if (isAbrupt(status)) return status;
    }
});

setInternalSlot(MapConstructor, SLOTS.CONSTRUCT, function Construct(argList) {
    var F = this;
    var args = argList;
    return OrdinaryConstruct(F, args);
});

DefineOwnProperty(MapConstructor, "prototype", {
    value: MapPrototype,
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(MapPrototype, "constructor", {
    value: MapConstructor,
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(MapPrototype, "has", {
    value: CreateBuiltinFunction(realm, function has(thisArg, argList) {

        var same;
        var key = argList[0];
        var M = thisArg;

        if (Type(M) !== OBJECT) return newTypeError( "this argument is not an object");
        if (!hasInternalSlot(M, SLOTS.MAPDATA)) return newTypeError( "this argument has no map data internal slot");

        var entries = getInternalSlot(M, SLOTS.MAPDATA);
        var comparator = getInternalSlot(M, SLOTS.MAPCOMPARATOR);

        if (comparator === undefined) same = SameValueZero;
        else same = SameValue;

        var internalKey;

        internalKey = __checkInternalUniqueKey(key);

        var record = entries[internalKey];
        if (record) {
            return NormalCompletion(true);
        }
        return NormalCompletion(false);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(MapPrototype, "get", {
    value: CreateBuiltinFunction(realm, function get(thisArg, argList) {
        var key = argList[0];
        var M = thisArg;
        var same;
        if (Type(M) !== OBJECT) return newTypeError( "this argument is not an object");
        if (!hasInternalSlot(M, SLOTS.MAPDATA)) return newTypeError( "this argument has no map data internal slot");
        var entries = getInternalSlot(M, SLOTS.MAPDATA);
        var comparator = getInternalSlot(M, SLOTS.MAPCOMPARATOR);
        if (comparator === undefined) same = SameValueZero;
        else same = SameValue;

        var internalKey;

        internalKey = __checkInternalUniqueKey(key);

        var record = entries[internalKey];
        if (record) {
            var value = record.value;
            return NormalCompletion(value);
        }
        return NormalCompletion(undefined);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(MapPrototype, "set", {
    value: CreateBuiltinFunction(realm, function set(thisArg, argList) {
        var key = argList[0];
        var value = argList[1];
        var M = thisArg;
        var same;
        if (Type(M) !== OBJECT) return newTypeError( "this argument is not an object");
        if (!hasInternalSlot(M, SLOTS.MAPDATA)) return newTypeError( "this argument has no map data internal slot");

        var entries = getInternalSlot(M, SLOTS.MAPDATA);

        var comparator = getInternalSlot(M, SLOTS.MAPCOMPARATOR);
        if (comparator === undefined) same = SameValueZero;
        else same = SameValue;


        var internalKey;

        internalKey = __checkInternalUniqueKey(key, true);

        var record = entries[internalKey];
        if (!record) {
            entries[internalKey] = {
                key: key,
                value: value
            };
        } else {
            record.value = value;
        }
        return NormalCompletion(M);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(MapPrototype, "delete", {
    value: CreateBuiltinFunction(realm, function _delete(thisArg, argList) {
        var key = argList[0];
        var M = thisArg;
        var same;
        if (Type(M) !== OBJECT) return newTypeError( "this argument is not an object");
        if (!hasInternalSlot(M, SLOTS.MAPDATA)) return newTypeError( "this argument has no map data internal slot");
        var entries = getInternalSlot(M, SLOTS.MAPDATA);
        var comparator = getInternalSlot(M, SLOTS.MAPCOMPARATOR);
        if (comparator === undefined) same = SameValueZero;
        else same = SameValue;

        var internalKey;

        internalKey = __checkInternalUniqueKey(key);

        var record = entries[internalKey];
        if (record) {
            entries[internalKey] = undefined;
            delete entries[internalKey];
            return NormalCompletion(true);
        }

        return NormalCompletion(false);
    }, 1, "delete"),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(MapPrototype, "forEach", {
    value: CreateBuiltinFunction(realm, function forEach(thisArg, argList) {

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(MapPrototype, "clear", {
    value: CreateBuiltinFunction(realm, function clear(thisArg, argList) {}),
    writable: false,
    enumerable: false,
    configurable: false
});


var MapPrototype_keys = function (thisArg, argList) {
        var O = thisArg;
        return CreateMapIterator(O, "key");
};

var MapPrototype_values = function (thisArg, argList) {
        var O = thisArg;
        return CreateMapIterator(O, "value");
};

var MapPrototype_entries = function (thisArg, argList) {
        var O = thisArg;
        return CreateMapIterator(O, "key+value");
};

LazyDefineBuiltinFunction(MapPrototype, "entries", 0, MapPrototype_entries);
LazyDefineBuiltinFunction(MapPrototype, "keys", 0, MapPrototype_keys);
LazyDefineBuiltinFunction(MapPrototype, "values", 0, MapPrototype_values);
LazyDefineBuiltinFunction(MapPrototype, $$iterator, 0, MapPrototype_entries);

DefineOwnProperty(MapConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function $$create(thisArg, argList) {
        var F = thisArg;
        return OrdinaryCreateFromConstructor(F, INTRINSICS.MAPPROTOTYPE, [
            SLOTS.MAPDATA,
            SLOTS.MAPCOMPARATOR
        ]);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(MapPrototype, $$toStringTag, {
    value: "Map",
    writable: false,
    enumerable: false,
    configurable: false
});

var UniqueMapAndSetES5Counter = 0;
function __checkInternalUniqueKey(value, writeIfUndefined) {
    var internalKey;
    if (Type(value) === OBJECT) {
        internalKey = getInternalSlot(value, "UniqueMapAndSetES5Key");
        if (internalKey === undefined) {
            internalKey = (++UniqueMapAndSetES5Counter) + Math.random();
            if (writeIfUndefined) setInternalSlot(value, "UniqueMapAndSetES5Key", internalKey);
        }
        return internalKey;
    }
    internalKey = value;
    if (typeof value === "string") internalKey = "str_" + internalKey;
    if (typeof value === "number") internalKey = "num_" + internalKey;
    if (typeof value === "boolean") internalKey = "" + internalKey;
    if (typeof value === "undefined") internalKey = "" + internalKey;
    if (value === null) internalKey = internalKey + "" + internalKey;
    return internalKey;
}




//
// Map Iterator
//

function CreateMapIterator(map, kind) {
    var M = ToObject(map);
    if (isAbrupt(M = ifAbrupt(M))) return M;
    if (!hasInternalSlot(M, SLOTS.MAPDATA)) return newTypeError( "object has no internal MapData slot");
    var entries = getInternalSlot(M, SLOTS.MAPDATA);
    var MapIteratorPrototype = Get(getIntrinsics(), INTRINSICS.MAPITERATORPROTOTYPE);
    var iterator = ObjectCreate(MapIteratorPrototype, {
        "Map": undefined,
        "MapNextIndex": undefined,
        "MapIterationKind": undefined
    });
    setInternalSlot(iterator, "Map", entries);
    setInternalSlot(iterator, "MapNextIndex", 0);
    setInternalSlot(iterator, "MapIterationKind", kind);
    return iterator;
}


DefineOwnProperty(MapIteratorPrototype, $$toStringTag, {
    value: "Map Iterator",
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(MapIteratorPrototype, $$iterator, {
    value: CreateBuiltinFunction(realm, function $$iterator(thisArg, argList) {
        return thisArg;
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(MapIteratorPrototype, "next", {
    value: CreateBuiltinFunction(realm, function next(thisArg, argList) {
        var O = thisArg;
        if (Type(O) !== OBJECT) return newTypeError( "the this value is not an object");
        if (!hasInternalSlot(O, "Map") || !hasInternalSlot(O, "MapNextIndex") || !hasInternalSlot(O, "MapIterationKind")) return newTypeError( "iterator has not all of the required internal properties");
        var entries = getInternalSlot(O, "Map");
        var kind = getInternalSlot(O, "MapIterationKind");
        var index = getInternalSlot(O, "MapNextIndex");
        var result;
        var internalKeys = Object.keys(entries); // deviate from spec
        var len = internalKeys.length;
        while (index < len) {
            var e = entries[internalKeys[index]];
            index = index + 1;
            setInternalSlot(O, "MapNextIndex", index);
            if (e.key !== empty) {
                if (kind === "key") result = e.key;
                else if (kind === "value") result = e.value;
                else {
                    Assert(kind === "key+value", "map iteration kind has to be key+value");
                    var result = ArrayCreate(2);
                    CreateDataProperty(result, "0", e.key);
                    CreateDataProperty(result, "1", e.value);
                }
                return CreateItrResultObject(result, false);
            }
        }
        return CreateItrResultObject(undefined, true);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

// ===========================================================================================================
// Set
// ===========================================================================================================

//
// Set
//

setInternalSlot(SetConstructor, SLOTS.PROTOTYPE, FunctionPrototype);
setInternalSlot(SetPrototype, SLOTS.PROTOTYPE, ObjectPrototype);

setInternalSlot(SetConstructor, SLOTS.CALL, function Call(thisArg, argList) {
    var iterable = argList[0];
    var comparator = argList[1];
    var set = thisArg;

    if (Type(set) !== OBJECT) return newTypeError( "set is not an object");
    if (!hasInternalSlot(set, SLOTS.SETDATA)) return newTypeError( "SetData property missing on object");
    if (getInternalSlot(set, SLOTS.SETDATA) !== undefined) return newTypeError( "SetData property already initialized");

    var iter;
    var hasValues, adder;
    if (iterable === undefined || iterable === null) iter = undefined;
    else {
        hasValues = HasProperty(iterable, "entries");
        if (isAbrupt(hasValues = ifAbrupt(hasValues))) return hasValues;
        if (hasValues) iter = Invoke(iterable, "entries");
        else iter = GetIterator(iterable);
        adder = Get(set, "set");
        if (isAbrupt(adder = ifAbrupt(adder))) return adder;
        if (!IsCallable(adder)) return newTypeError( "set adder (the set function) is not callable");
    }
    if (comparator !== undefined) {
        if (comparator !== "is") return newRangeError( "comparator argument has currently to be 'undefined' or 'is'");
    }

    setInternalSlot(set, SLOTS.SETDATA, Object.create(null));
    setInternalSlot(set, SLOTS.SETCOMPARATOR, comparator);

    if (iter === undefined) return NormalCompletion(set);

    var next, nextItem, done, k, v, status;
    for (;;) {
        next = IteratorNext(iter);
        if (isAbrupt(next = ifAbrupt(next))) return next;
        done = IteratorComplete(next);
        if (isAbrupt(done = ifAbrupt(done))) return done;
        if (done) return NormalCompletion(set);
        nextItem = IteratorValue(next);
        if (isAbrupt(nextItem = ifAbrupt(nextItem))) return nextItem;
        k = Get(nextItem, "0");
        if (isAbrupt(k = ifAbrupt(k))) return k;
        v = Get(nextItem, "1");
        if (isAbrupt(v = ifAbrupt(v))) return v;
        status = callInternalSlot(SLOTS.CALL, adder, set, [v]);
        if (isAbrupt(status)) return status;
    }


});
setInternalSlot(SetConstructor, SLOTS.CONSTRUCT, function (argList) {
    return OrdinaryConstruct(this, argList);
});

DefineOwnProperty(SetConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function $$create(thisArg, argList) {
        var F = thisArg;
        return OrdinaryCreateFromConstructor(F, INTRINSICS.SETPROTOTYPE, [
            SLOTS.SETDATA,
            SLOTS.SETCOMPARATOR
        ]);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(SetPrototype, $$toStringTag, {
    value: SLOTS.SET,
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(SetPrototype, "clear", {
    value: CreateBuiltinFunction(realm, function clear(thisArg, argList) {}),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(SetPrototype, "set", {
    value: CreateBuiltinFunction(realm, function set(thisArg, argList) {
        var value = argList[0];
        var S = thisArg;
        var same;
        if (Type(S) !== OBJECT) return newTypeError( "this argument is not an object");
        if (!hasInternalSlot(S, SLOTS.SETDATA)) return newTypeError( "this argument has no set data internal slot");

        var entries = getInternalSlot(S, SLOTS.SETDATA);

        var comparator = getInternalSlot(S, SLOTS.SETCOMPARATOR);
        if (comparator === undefined) same = SameValueZero;
        else same = SameValue;


        var internalKey;

        internalKey = __checkInternalUniqueKey(value, true);

        entries[internalKey] = value;

        return NormalCompletion(S);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(SetPrototype, "has", {
    value: CreateBuiltinFunction(realm, function has(thisArg, argList) {
        var value = argList[0];
        var S = thisArg;
        var same;
        if (Type(S) !== OBJECT) return newTypeError( "this argument is not an object");
        if (!hasInternalSlot(S, SLOTS.SETDATA)) return newTypeError( "this argument has no map data internal slot");

        var entries = getInternalSlot(S, SLOTS.SETDATA);

        var comparator = getInternalSlot(S, SLOTS.SETCOMPARATOR);
        if (comparator === undefined) same = SameValueZero;
        else same = SameValue;


        var internalKey;

        internalKey = __checkInternalUniqueKey(value);

        if (entries[internalKey] === value) return NormalCompletion(true);

        return NormalCompletion(false);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(SetPrototype, "delete", {
    value: CreateBuiltinFunction(realm, function _delete(thisArg, argList) {
        var value = argList[0];
        var S = thisArg;
        var same;
        if (Type(S) !== OBJECT) return newTypeError( "this argument is not an object");
        if (!hasInternalSlot(S, SLOTS.SETDATA)) return newTypeError( "this argument has no map data internal slot");

        var entries = getInternalSlot(S, SLOTS.SETDATA);

        var comparator = getInternalSlot(S, SLOTS.SETCOMPARATOR);
        if (comparator === undefined) same = SameValueZero;
        else same = SameValue;


        var internalKey;

        internalKey = __checkInternalUniqueKey(value);

        if (entries[internalKey] === value) {
            entries[internalKey] = undefined;
            delete entries[internalKey];
            return NormalCompletion(true);
        }
        return NormalCompletion(false);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});


var SetPrototype_entries = function (thisArg, argList) {
    return CreateSetIterator(thisArg, "key+value");
};
var SetPrototype_keys = function (thisArg, argList) {
    return CreateSetIterator(thisArg, "key");
};
var SetPrototype_values = function (thisArg, argList) {
    return CreateSetIterator(thisArg, "value");
};

var SetPrototype_forEach = function (thisArg, argList) {

};


LazyDefineBuiltinFunction(SetPrototype, "keys", 0, SetPrototype_keys);
LazyDefineBuiltinFunction(SetPrototype, "values", 0, SetPrototype_values);
LazyDefineBuiltinFunction(SetPrototype, "entries", 0, SetPrototype_entries);
LazyDefineBuiltinFunction(SetPrototype, "forEach", 0, SetPrototype_forEach);
LazyDefineBuiltinFunction(SetPrototype, $$iterator, 0, SetPrototype_values);
/**
 *
 * @param set
 * @param kind
 * @returns {*}
 * @constructor
 */
function CreateSetIterator(set, kind) {
    var S = ToObject(set);
    if (isAbrupt(S = ifAbrupt(S))) return S;
    if (!hasInternalSlot(S, SLOTS.SETDATA)) return newTypeError( "object has no internal SetData slot");
    var origEntries = getInternalSlot(S, SLOTS.SETDATA);
    var SetIteratorPrototype = Get(getIntrinsics(), INTRINSICS.SETITERATORPROTOTYPE);
    var iterator = ObjectCreate(SetIteratorPrototype,
        [
            SLOTS.ITERATEDSET,
            SLOTS.SETNEXTINDEX,
            SLOTS.SETITERATIONKIND
        ]
    );
    /* price of creating my es5 iterator is a pre-run of O(n) to
        translate the set into some array (currently)
     */
    var entries = [];
    for (var keys in origEntries) entries.push(origEntries[keys]);
    /*

     */
    setInternalSlot(iterator, SLOTS.ITERATEDSET, entries);
    setInternalSlot(iterator, SLOTS.SETNEXTINDEX, 0);
    setInternalSlot(iterator, SLOTS.SETITERATIONKIND, kind);
    return iterator;
}


LazyDefineBuiltinConstant(SetIteratorPrototype, "constructor", undefined);
LazyDefineBuiltinConstant(SetIteratorPrototype, $$toStringTag, "Set Iterator");

DefineOwnProperty(SetIteratorPrototype, $$iterator, {
    value: CreateBuiltinFunction(realm, function $$iterator(thisArg, argList) {
        return thisArg;
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(SetIteratorPrototype, "next", {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var O = thisArg;
        if (Type(O) !== OBJECT) return newTypeError( "the this value is not an object");
        if (!hasInternalSlot(O, SLOTS.ITERATEDSET) || !hasInternalSlot(O, SLOTS.SETNEXTINDEX) || !hasInternalSlot(O, SLOTS.SETITERATIONKIND)) return newTypeError( "iterator has not all of the required internal properties");
        var entries = getInternalSlot(O, SLOTS.ITERATEDSET);
        var kind = getInternalSlot(O, SLOTS.SETITERATIONKIND);
        var index = getInternalSlot(O, SLOTS.SETNEXTINDEX);
        var result;
        var len = entries.length;
        while (index < len) {
            var e = entries[index];
            index = index + 1;
            setInternalSlot(O, SLOTS.SETNEXTINDEX, index);
            if (e !== empty) {
                if (kind === "key+value") {
                    Assert(kind === "key+value", "set iteration kind has to be key+value");
                    var result = ArrayCreate(2);
                    CreateDataProperty(result, "0", e);
                    CreateDataProperty(result, "1", e);
                    return CreateItrResultObject(result, false);
                }
                return CreateItrResultObject(e, false);
            }
        }
        return CreateItrResultObject(undefined, true);
    }, 1, "next"),
    writable: false,
    enumerable: false,
    configurable: false
});


// ===========================================================================================================
// Event Emitter (nodejs emitter like with equal interfaces)
// ===========================================================================================================

setInternalSlot(EmitterPrototype, SLOTS.PROTOTYPE, ObjectPrototype);
setInternalSlot(EmitterConstructor, SLOTS.CALL, function Call(thisArg, argList) {
    var O = thisArg;
    var type = Type(O);
    var has, listeners;
    if (type === OBJECT) {
        has = hasInternalSlot(O, SLOTS.EVENTLISTENERS);
        if (!has) {
            return newTypeError( "this argument has to have a [[Listeners]] Property");
        } else {
            listeners = getInternalSlot(O, SLOTS.EVENTLISTENERS);
            if (!listeners) {
                listeners = Object.create(null);
                setInternalSlot(O, SLOTS.EVENTLISTENERS, listeners);

            }
        }
    } else {
        return newTypeError( "this argument is not an object");
    }
    return O;
});

setInternalSlot(EmitterConstructor, SLOTS.CONSTRUCT, function Call(argList) {
    var F = this;
    var args = argList;
    return OrdinaryConstruct(F, args);
});

DefineOwnProperty(EmitterConstructor, $$create, {
    value: CreateBuiltinFunction(realm, function (thisArg, argList) {
        var F = EmitterConstructor;
        var proto = GetPrototypeFromConstructor(F, "%EmitterPrototype%");
        return ObjectCreate(proto, [SLOTS.EVENTLISTENERS]);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(EmitterConstructor, "prototype", {
    value: EmitterPrototype,
    writable: false,
    enumerable: false,
    configurable: false
});
DefineOwnProperty(EmitterPrototype, "constructor", {
    value: EmitterConstructor,
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(EmitterPrototype, "on", {
    value: CreateBuiltinFunction(realm, function on(thisArg, argList) {
        var E = thisArg,
            listeners, callback, event;

        if (Type(E) !== OBJECT) return newTypeError( "this argument is not an object");

        if (!hasInternalSlot(E, SLOTS.EVENTLISTENERS)) return newTypeError( "[[Listeners]] missing on this argument");
        else listeners = getInternalSlot(E, SLOTS.EVENTLISTENERS);

        var event = argList[0];
        var callback = argList[1];
        if (Type(event) !== STRING) return newTypeError( "Your argument 1 is not a event name string.");
        if (!IsCallable(callback)) return newTypeError( "Your argument 2 is not a callback function");

        var list = listeners[event];
        if (list == undefined) list = listeners[event] = [];
        list.push(callback);

        return NormalCompletion(undefined);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(EmitterPrototype, "once", {
    value: CreateBuiltinFunction(realm, function once(thisArg, argList) {
        var E = thisArg,
            listeners, callback, event;

        if (Type(E) !== OBJECT) return newTypeError( "this argument is not an object");

        if (!hasInternalSlot(E, SLOTS.EVENTLISTENERS)) return newTypeError( "[[Listeners]] missing on this argument");
        else listeners = getInternalSlot(E, SLOTS.EVENTLISTENERS);

        event = argList[0];
        callback = argList[1];
        if (Type(event) !== STRING) return newTypeError( "Your argument 1 is not a event name string.");
        if (!IsCallable(callback)) return newTypeError( "Your argument 2 is not a callback function");

        var list = listeners[event];
        if (list == undefined) list = listeners[event] = [];

        list.push(
            function (callback) {

                return CreateBuiltinFunction(realm, function once_callback(thisArg, argList) {
                    if (callback) {
                        callInternalSlot(SLOTS.CALL, callback, thisArg, argList);
                        callback = null;
                    }
                });

            }(callback)
        );

        return NormalCompletion(undefined);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(EmitterPrototype, "remove", {
    value: CreateBuiltinFunction(realm, function remove(thisArg, argList) {

        var E = thisArg,
            listeners, callback, event, values;

        if (Type(E) !== OBJECT) return newTypeError( "this argument is not an object");

        if (!hasInternalSlot(E, SLOTS.EVENTLISTENERS)) return newTypeError( "[[Listeners]] missing on this argument");
        else listeners = getInternalSlot(E, SLOTS.EVENTLISTENERS);

        event = argList[0];
        callback = argList[1];

        if (Type(event) !== STRING) return newTypeError( "Your argument 1 is not a event name string.");
        if (!IsCallable(callback)) return newTypeError( "Your argument 2 is not a function.");

        var list = listeners[event];
        if (list == undefined) return NormalCompletion(undefined);

        var newList = [];
        var fn;
        for (var i = 0, j = list.length; i < j; i++) {
            if (fn = list[i]) {
                if (fn !== callback) newList.push(fn);
            }
        }

        listeners[event] = newList;

        return NormalCompletion(undefined);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(EmitterPrototype, "removeAll", {
    value: CreateBuiltinFunction(realm, function removeAll(thisArg, argList) {
        var E = thisArg,
            listeners, event;

        if (Type(E) !== OBJECT) return newTypeError( "this argument is not an object");

        if (!hasInternalSlot(E, SLOTS.EVENTLISTENERS)) return newTypeError( "[[Listeners]] missing on this argument");
        else listeners = getInternalSlot(E, SLOTS.EVENTLISTENERS);

        event = argList[0];

        if (Type(event) !== STRING) return newTypeError( "Your argument 1 is not a event name string.");

        var list = listeners[event];
        if (list == undefined) return NormalCompletion(undefined);
        else listeners[event] = [];

        return NormalCompletion(undefined);

    }),
    writable: false,
    enumerable: false,
    configurable: false
});

DefineOwnProperty(EmitterPrototype, "emit", {
    value: CreateBuiltinFunction(realm, function emit(thisArg, argList) {
        var E = thisArg,
            listeners, callback, event, values;

        if (Type(E) !== OBJECT) return newTypeError( "this argument is not an object");

        if (!hasInternalSlot(E, SLOTS.EVENTLISTENERS)) return newTypeError( "[[Listeners]] missing on this argument");
        else listeners = getInternalSlot(E, SLOTS.EVENTLISTENERS);
        event = argList[0];
        values = arraySlice(argList, 1);
        if (Type(event) !== STRING) return newTypeError( "Your argument 1 is not a event name string.");
        var list = listeners[event];
        if (list == undefined) return NormalCompletion(undefined);

        //setTimeout(function () {
        var F = OrdinaryFunction();
        var status = callInternalSlot(SLOTS.CALL, SetTimeoutFunction, null, [F, 0]);
        setInternalSlot(F, SLOTS.CALL, function (thisArg, argList) {
        var result;
        for (var i = 0, j = list.length; i < j; i++) {
            if (callback = list[i]) {
                result = callInternalSlot(SLOTS.CALL, callback, thisArg, values);
            //    if (isAbrupt(result)) return result;
            }
        }
        });
        //});

        return NormalCompletion(undefined);
    }),
    writable: false,
    enumerable: false,
    configurable: false
});

LazyDefineBuiltinConstant(EmitterPrototype, $$toStringTag, "Emitter");


/*
  Emitter,
  Event
  EventTarget
  MessagePort
 */


MakeConstructor(EventConstructor, true, EventPrototype);
MakeConstructor(EventTargetConstructor, true, EventTargetPrototype);
MakeConstructor(MessagePortConstructor, true, MessagePortPrototype);

var EventConstructor_Call = function (thisArg, argList) {
};


var EventTargetConstructor_Call = function (thisArg, argList) {
};
var EventTargetPrototype_addEventListener = function (thisArg, argList) {
};
var EventTargetPrototype_dispatchEvent = function (thisArg, argList) {
};
var EventTargetPrototype_removeEventListener = function (thisArg, argList) {
};
LazyDefineBuiltinFunction(EventTargetPrototype, "addEventListener", 3, EventTargetPrototype_addEventListener);
LazyDefineBuiltinFunction(EventTargetPrototype, "dispatchEvent", 1, EventTargetPrototype_dispatchEvent);
LazyDefineBuiltinFunction(EventTargetPrototype, "removeEventListener", 2, EventTargetPrototype_removeEventListener);

var MessagePortPrototype_close = function (thisArg, argList) {
};
var MessagePortPrototype_open = function (thisArg, argList) {
};
var MessagePortPrototype_postMessage = function (thisArg, argList) {
};
LazyDefineBuiltinFunction(MessagePortPrototype, "close", 0, MessagePortPrototype_close);
LazyDefineBuiltinFunction(MessagePortPrototype, "open", 0, MessagePortPrototype_open);
LazyDefineBuiltinFunction(MessagePortPrototype, "postMessage", 0, MessagePortPrototype_postMessage);


/**
 * Created by root on 04.04.14.
 */
var TypePrototypePrototype_get = function (thisArg, argList) {
    var O = thisArg;
    if (!hasInternalSlot(O, SLOTS.TYPEDESCRIPTOR)) return newTypeError( "has no type descriptor");
    return NormalCompletion(getInternalSlot(O, SLOTS.TYPEDESCRIPTOR));
};
var TypePrototype_arrayType = function (thisArg, argList) {
    var O = thisArg;
    var length = argList[0];
    if (!TypeObject(O)) return newTypeError( "not a typed object");
    var typeDescriptor = getInternalSlot(O, SLOTS.TYPEDESCRIPTOR);
    var numberLength = ToNumber(length);
    var elementLength = ToLength(numberLength);
    if (isAbrupt(elementLength=ifAbrupt(elementLength))) return elementLength;
    if (SameValueZero(numberLength, elementLength)) return newRangeError( "numberLength is not elementLength");
    var arrayDescriptor = GetOrCreateArrayTypeDescriptor(typeDescriptor);
    if (isAbrupt(arrayDescriptor=ifAbrupt(arrayDescriptor))) return arrayDescriptor;
    var R = TypeExoticObject();
    setInternalSlot(R, SLOTS.TYPEDESCRIPTOR, arrayDescriptor);
    var newDimensions = Cons(N, dimension);
    setInternalSlot(R, SLOTS.DIMENSIONS, newDimensions);
    return NormalCompletion(R);
};
var TypePrototype_opaqueType = function (thisArg, argList) {
    var O = thisArg;
    if (!IsTypeObject(O)) return newTypeError("is not a typed object");
    var typeDescriptor = getInternalSlot(O, SLOTS.TYPEDESCRIPTOR);
    var dimensions = setInternalSlot(O, SLOTS.DIMENSIONS);
    var opaqueDescriptor = GetOrCreateOpaqueTypeDescriptor(typeDescriptor);
    if (isAbrupt(opaqueDescriptor = ifAbrupt(opaqueDescriptor))) return opaqueDescriptor;
    var R = TypeObject();
    setInternalSlot(R, SLOTS.TYPEDESCRIPTOR, opaqueDescriptor);
    setInternalSlot(R, SLOTS.DIMENSIONS, dimensions);
    return NormalCompletion(R);
};
var StructTypeConstructor_Call = function (thisArg, argList) {
    var object = argList[0];
    if (Type(object) !== OBJECT) return newTypeError( "first argument is not an object");

    var O = thisArg;
    if (!IsTypeObject(O)) return newTypeError( "O is no TypeObject");
    var currentOffset = 0;
    var maxAlignment = 1;
    var structure = [];
    for (var P in object.Bindings) {
        var fieldType = Get(object, P);
        if (isAbrupt(fieldType=ifAbrupt(fieldType))) return fieldType;
        if (!IsTypeObject(fieldType)) return newTypeError( "fieldType is no TypeObject");
        var alignment = Alignment(fieldType);
        maxAlignment = Math.max(alignment, maxAlignment);
        currentOffset = AlignTo(currentOffset, alignment);

        var r = FieldRecord(fieldName, byteOffset, currentOffset, fieldType);
        structure.push(r);
        var s = Size(fieldType);
        if (isAbrupt(s=ifAbrupt(s))) return s;
        currentOffset = currentOffset + s;
    }
    var size = AlignTo(currentOffset, maxAlignment);
    var typeDescriptor = CreateStructTypeDescriptor(structure);
    setInternalSlot(O, SLOTS.TYPEDESCRIPTOR, typeDescriptor);
    OrdinaryDefineOwnProperty(O, "prototype", {
        configurable: false,
        enumerable: false,
        value: typeDescriptor,
        writable: false
    });
    return NormalCompletion(O);
};
var StructTypeConstructor_Construct = function (argList) {
    return OrdinaryConstruct(this, argList);
};
var StructTypeConstructor_$$create = function (thisArg, argList) {
    var F = thisArg;
    var proto = OrdinaryCreateFromConstructor(F, INTRINSICS.STRUCTTYPEPROTOTYPE, [ SLOTS.TYPEDESCRIPTOR, SLOTS.DIMENSIONS ]);
    if (isAbrupt(proto = ifAbrupt(proto))) return proto;
    return ObjectCreate(proto);
};

// The above must be moved out of intrinsics/ into api for more speed creating realms.
// that all "objects" gonna be refactored for typed memory is some other topic.

// StructType
setInternalSlot(StructTypeConstructor, SLOTS.CALL, StructTypeConstructor_Call);
setInternalSlot(StructTypeConstructor, SLOTS.CONSTRUCT, StructTypeConstructor_Construct);
LazyDefineBuiltinFunction(StructTypePrototype, $$create, 1, StructTypeConstructor_$$create)

// StructType.prototype



// Type.prototype
LazyDefineAccessor(TypePrototype, "prototype", TypePrototypePrototype_get);
LazyDefineBuiltinFunction(TypePrototype, "arrayType", 1, TypePrototype_arrayType);
LazyDefineBuiltinFunction(TypePrototype, "opaqueType", 1, TypePrototype_opaqueType);


/*

    This is a small interface for the upcoming virtual machine implementation,
    that i can execute VM.eval(code[, realm]) from the es6> prompt and don´t
    have to switch to node for calling the functions.
    
*/
var VMObject_eval = function (thisArg, argList) {
    var code = argList[0];
    var realm = argList[1];
    var realmObject;
    if (realm === undefined) realmObject = getRealm();
    else if (!(realmObject = getInternalSlot(realm, "RealmObject"))) return newTypeError( "Sorry, only realm objects are accepted as realm object");
    return require("vm").CompileAndRun(realmObject, code);
};

var VMObject_heap = function (thisArg, argList) {
    var size = argList[0];
    var realm = argList[1];
    var realmObject;
    if (realm === undefined) realmObject = getRealm();
    else if (!(realmObject = getInternalSlot(realm, "RealmObject"))) return newTypeError( "Sorry, only realm objects are accepted as realm object");
    var Heap = require("heap").Heap;
    var heap = new Heap(size);
    var O = NativeJSObjectWrapper(heap);
    setInternalSlot(O, "Heap", heap);    
    LazyDefineProperty(O, $$toStringTag, "HeapWrapper");    
    return NormalCompletion(O);
};
LazyDefineBuiltinFunction(VMObject, "eval", 1, VMObject_eval);
LazyDefineBuiltinFunction(VMObject, "heap", 1, VMObject_heap);




        createGlobalThis = function createGlobalThis(realm, globalThis, intrinsics) {
            SetPrototypeOf(globalThis, ObjectPrototype);
            setInternalSlot(globalThis, SLOTS.EXTENSIBLE, true);
            DefineOwnProperty(globalThis, "Array", GetOwnProperty(intrinsics, INTRINSICS.ARRAY));
            DefineOwnProperty(globalThis, "ArrayBuffer", GetOwnProperty(intrinsics, INTRINSICS.ARRAYBUFFER));
            DefineOwnProperty(globalThis, "Boolean", GetOwnProperty(intrinsics, INTRINSICS.BOOLEAN));
            DefineOwnProperty(globalThis, "DataView", GetOwnProperty(intrinsics, INTRINSICS.DATAVIEW));
            DefineOwnProperty(globalThis, "Date", GetOwnProperty(intrinsics, INTRINSICS.DATE));
            DefineOwnProperty(globalThis, "Emitter", GetOwnProperty(intrinsics, INTRINSICS.EMITTER));
            DefineOwnProperty(globalThis, "Event", GetOwnProperty(intrinsics, INTRINSICS.EVENT));
            DefineOwnProperty(globalThis, "EventTarget", GetOwnProperty(intrinsics, INTRINSICS.EVENTTARGET));
            DefineOwnProperty(globalThis, "Error", GetOwnProperty(intrinsics, INTRINSICS.ERROR));
            DefineOwnProperty(globalThis, "EvalError", GetOwnProperty(intrinsics, INTRINSICS.EVALERROR));
            DefineOwnProperty(globalThis, "Function", GetOwnProperty(intrinsics, INTRINSICS.FUNCTION));
            DefineOwnProperty(globalThis, "Float32Array", GetOwnProperty(intrinsics, INTRINSICS.FLOAT32ARRAY));
            DefineOwnProperty(globalThis, "Float64Array", GetOwnProperty(intrinsics, INTRINSICS.FLOAT64ARRAY));
            DefineOwnProperty(globalThis, "GeneratorFunction", GetOwnProperty(intrinsics, INTRINSICS.GENERATORFUNCTION));
            LazyDefineBuiltinConstant(globalThis, "Infinity", Infinity);
            DefineOwnProperty(globalThis, "Int8Array", GetOwnProperty(intrinsics, INTRINSICS.INT8ARRAY));
            DefineOwnProperty(globalThis, "Int16Array", GetOwnProperty(intrinsics, INTRINSICS.INT16ARRAY));
            DefineOwnProperty(globalThis, "Int32Array", GetOwnProperty(intrinsics, INTRINSICS.INT32ARRAY));
            DefineOwnProperty(globalThis, "JSON", GetOwnProperty(intrinsics, INTRINSICS.JSON));
            DefineOwnProperty(globalThis, "Loader", GetOwnProperty(intrinsics, INTRINSICS.LOADER));
            DefineOwnProperty(globalThis, "Math", GetOwnProperty(intrinsics, INTRINSICS.MATH));
            DefineOwnProperty(globalThis, "Map", GetOwnProperty(intrinsics, INTRINSICS.MAP));
            DefineOwnProperty(globalThis, "MessagePort", GetOwnProperty(intrinsics, INTRINSICS.MESSAGEPORT));
            DefineOwnProperty(globalThis, "Module", GetOwnProperty(intrinsics, INTRINSICS.MODULE));
            LazyDefineBuiltinConstant(globalThis, "NaN", NaN);
            DefineOwnProperty(globalThis, "Number", GetOwnProperty(intrinsics, INTRINSICS.NUMBER));
            DefineOwnProperty(globalThis, "Proxy", GetOwnProperty(intrinsics, INTRINSICS.PROXY));
            DefineOwnProperty(globalThis, "RangeError", GetOwnProperty(intrinsics, INTRINSICS.RANGEERROR));
            DefineOwnProperty(globalThis, "Realm", GetOwnProperty(intrinsics, INTRINSICS.REALM));
            DefineOwnProperty(globalThis, "ReferenceError", GetOwnProperty(intrinsics, INTRINSICS.REFERENCEERROR));
            DefineOwnProperty(globalThis, "RegExp", GetOwnProperty(intrinsics, INTRINSICS.REGEXP));
            DefineOwnProperty(globalThis, "StructType", GetOwnProperty(intrinsics, INTRINSICS.STRUCTTYPE));
            DefineOwnProperty(globalThis, "SyntaxError", GetOwnProperty(intrinsics, INTRINSICS.SYNTAXERROR));
            LazyDefineProperty(globalThis, "System", realm.loader);
            DefineOwnProperty(globalThis, "TypeError", GetOwnProperty(intrinsics, INTRINSICS.TYPEERROR));
            DefineOwnProperty(globalThis, "URIError", GetOwnProperty(intrinsics, INTRINSICS.URIERROR));
            DefineOwnProperty(globalThis, "Object", GetOwnProperty(intrinsics, INTRINSICS.OBJECT));
            DefineOwnProperty(globalThis, "Promise", GetOwnProperty(intrinsics, INTRINSICS.PROMISE));
            DefineOwnProperty(globalThis, "Reflect", GetOwnProperty(intrinsics, INTRINSICS.REFLECT));
            DefineOwnProperty(globalThis, "Set", GetOwnProperty(intrinsics, INTRINSICS.SET));
            DefineOwnProperty(globalThis, "String", GetOwnProperty(intrinsics, INTRINSICS.STRING));
            DefineOwnProperty(globalThis, "Symbol", GetOwnProperty(intrinsics, INTRINSICS.SYMBOL));
            DefineOwnProperty(globalThis, "Uint8Array", GetOwnProperty(intrinsics, INTRINSICS.UINT8ARRAY));
            DefineOwnProperty(globalThis, "Uint8ClampedArray", GetOwnProperty(intrinsics, INTRINSICS.UINT8CLAMPEDARRAY));
            DefineOwnProperty(globalThis, "Uint16Array", GetOwnProperty(intrinsics, INTRINSICS.UINT16ARRAY));
            DefineOwnProperty(globalThis, "Uint32Array", GetOwnProperty(intrinsics, INTRINSICS.UINT32ARRAY));
            DefineOwnProperty(globalThis, "WeakMap", GetOwnProperty(intrinsics, INTRINSICS.MAP));
            DefineOwnProperty(globalThis, "WeakSet", GetOwnProperty(intrinsics, INTRINSICS.SET));
            DefineOwnProperty(globalThis, "console", GetOwnProperty(intrinsics, INTRINSICS.CONSOLE));
            DefineOwnProperty(globalThis, "debug", GetOwnProperty(intrinsics, INTRINSICS.DEBUGFUNCTION));
            DefineOwnProperty(globalThis, "decodeURI", GetOwnProperty(intrinsics, INTRINSICS.DECODEURI));
            DefineOwnProperty(globalThis, "decodeURIComponent", GetOwnProperty(intrinsics, INTRINSICS.DECODEURICOMPONENT));
            DefineOwnProperty(globalThis, "encodeURI", GetOwnProperty(intrinsics, INTRINSICS.ENCODEURI));
            DefineOwnProperty(globalThis, "encodeURIComponent", GetOwnProperty(intrinsics, INTRINSICS.ENCODEURICOMPONENT));
            DefineOwnProperty(globalThis, "escape", GetOwnProperty(intrinsics, INTRINSICS.ESCAPE));
            DefineOwnProperty(globalThis, "eval", GetOwnProperty(intrinsics, INTRINSICS.EVAL));
            LazyDefineBuiltinConstant(globalThis, "global", globalThis);
            DefineOwnProperty(globalThis, "isFinite", GetOwnProperty(intrinsics, INTRINSICS.ISFINITE));
        DefineOwnProperty(globalThis, "isNaN", GetOwnProperty(intrinsics, INTRINSICS.ISNAN));
            DefineOwnProperty(globalThis, "load", GetOwnProperty(intrinsics, INTRINSICS.LOAD));
//            LazyDefineBuiltinConstant(globalThis, "null", null);
            DefineOwnProperty(globalThis, "parseInt", GetOwnProperty(intrinsics, INTRINSICS.PARSEINT));
            DefineOwnProperty(globalThis, "parseFloat", GetOwnProperty(intrinsics, INTRINSICS.PARSEFLOAT));
            DefineOwnProperty(globalThis, "print", GetOwnProperty(intrinsics, INTRINSICS.PRINTFUNCTION));
            DefineOwnProperty(globalThis, "request", GetOwnProperty(intrinsics, INTRINSICS.REQUEST));
            DefineOwnProperty(globalThis, "setTimeout", GetOwnProperty(intrinsics, INTRINSICS.SETTIMEOUT));
            DefineOwnProperty(globalThis, "setLanguage", GetOwnProperty(intrinsics, INTRINSICS.SETLANGUAGE));
            LazyDefineBuiltinConstant(globalThis, "undefined", undefined);
            DefineOwnProperty(globalThis, "unescape", GetOwnProperty(intrinsics, INTRINSICS.UNESCAPE));
            LazyDefineBuiltinConstant(globalThis, $$toStringTag, "syntaxjs");
            DefineOwnProperty(globalThis, "VM", GetOwnProperty(intrinsics, INTRINSICS.VM));

        if (typeof Java !== "function" && typeof load !== "function" && typeof print !== "function") {
	
	        LazyDefineProperty(intrinsics, INTRINSICS.DOMWRAPPER, 
	        NativeJSObjectWrapper(
	        typeof importScripts === "function" ? self : 
	        typeof window === "object" ? window : 
	        typeof process === "object" ? process : {}
	        )
	        );
        
            if (typeof importScripts === "function") {
                DefineOwnProperty(globalThis, "self", GetOwnProperty(intrinsics, INTRINSICS.DOMWRAPPER));
            } else if (typeof window === "object") {
                DefineOwnProperty(globalThis, "window", GetOwnProperty(intrinsics, INTRINSICS.DOMWRAPPER));
                DefineOwnProperty(globalThis, "document", {
                    configurable: true,
                    enumerable: true,
                    value: Get(Get(globalThis, "window"), "document"),
                    writable: true

                });
            } else if (typeof process === "object") {
                DefineOwnProperty(globalThis, "process", GetOwnProperty(intrinsics, INTRINSICS.DOMWRAPPER));
            }

	}
            return globalThis;
        };

        return intrinsics;
    };



    exports.NextTask = NextTask;
    exports.getTasks = getTasks;
    exports.OBJECT = OBJECT;
    exports.NUMBER = NUMBER;
    exports.STRING = STRING;
    exports.SYMBOL = SYMBOL;
    exports.BOOLEAN = BOOLEAN;
    exports.REFERENCE = REFERENCE;
    exports.ENVIRONMENT = ENVIRONMENT;
    exports.COMPLETION = COMPLETION;
    exports.UNDEFINED = UNDEFINED;
    exports.NULL = NULL;
    exports.SLOTS = SLOTS; // replace all string slots with the SLOTS.[[GET]](N)
    exports.INTRINSICS = INTRINSICS;
    exports.$$unscopables        = $$unscopables;
    exports.$$create             = $$create;
    exports.$$toPrimitive        = $$toPrimitive;
    exports.$$hasInstance        = $$hasInstance;
    exports.$$toStringTag        = $$toStringTag;
    exports.$$iterator           = $$iterator;
    exports.$$isRegExp           = $$isRegExp;
    exports.$$isConcatSpreadable = $$isConcatSpreadable;
    exports.IndirectEval = IndirectEval;
    exports.CreateBuiltinFunction = CreateBuiltinFunction;
    exports.AddRestrictedFunctionProperties = AddRestrictedFunctionProperties;
    exports.uriReserved = uriReserved;
    exports.uriUnescaped = uriUnescaped;
    exports.Encode = Encode;
    exports.Decode = Decode;
    exports.UTF8Encode = UTF8Encode;
    exports.SetFunctionName = SetFunctionName;
    exports.HasOwnProperty = HasOwnProperty;
    exports.Put = Put;
    exports.Invoke = Invoke;
    exports.CreateArrayIterator = CreateArrayIterator;
    exports.CopyDataBlockBytes = CopyDataBlockBytes;
    exports.GetThisEnvironment = GetThisEnvironment;
    exports.GeneratorStart = GeneratorStart;
    exports.GeneratorYield = GeneratorYield;
    exports.GeneratorResume = GeneratorResume;
    exports.CreateItrResultObject = CreateItrResultObject;
    exports.IteratorNext = IteratorNext;
    exports.IteratorComplete = IteratorComplete;
    exports.IteratorValue = IteratorValue;
    exports.GetIterator = GetIterator;
    exports.CreateDataProperty = CreateDataProperty;
    exports.CreateOwnAccessorProperty = CreateOwnAccessorProperty;
    exports.NormalCompletion = NormalCompletion;
    exports.Completion = Completion;
    exports.NewDeclarativeEnvironment = NewDeclarativeEnvironment;
    exports.NewObjectEnvironment = NewObjectEnvironment;
    exports.NewFunctionEnvironment = NewFunctionEnvironment;
    exports.createIdentifierBinding = createIdentifierBinding;
    exports.GetIdentifierReference = GetIdentifierReference;
    exports.FunctionCreate = FunctionCreate;
    exports.FunctionAllocate = FunctionAllocate;
    exports.FunctionInitialize = FunctionInitialize;
    exports.GeneratorFunctionCreate = GeneratorFunctionCreate;
    exports.OrdinaryHasInstance = OrdinaryHasInstance;
    exports.GetPrototypeFromConstructor = GetPrototypeFromConstructor;
    exports.OrdinaryCreateFromConstructor = OrdinaryCreateFromConstructor;
    exports.OrdinaryConstruct = OrdinaryConstruct;
    exports.Construct = Construct;
    exports.CreateFromConstructor = CreateFromConstructor;
    exports.MakeConstructor = MakeConstructor;
    exports.CreateEmptyIterator = CreateEmptyIterator;
    exports.ArgumentsExoticObject = ArgumentsExoticObject;
    exports.ArrayCreate = ArrayCreate;
    exports.ArraySetLength = ArraySetLength;
    exports.NativeJSObjectWrapper = NativeJSObjectWrapper;
    exports.NativeJSFunctionWrapper = NativeJSFunctionWrapper;
    exports.BoundFunctionCreate = BoundFunctionCreate;
    exports.GeneratorFunctionCreate = GeneratorFunctionCreate;
    exports.ObjectDefineProperties = ObjectDefineProperties;
    exports.DeclarativeEnvironment = DeclarativeEnvironment;
    exports.ObjectEnvironment = ObjectEnvironment;
    exports.GlobalEnvironment = GlobalEnvironment;
    exports.ToPropertyKey = ToPropertyKey;
    exports.IsPropertyKey = IsPropertyKey;
    exports.IsSymbol = IsSymbol;
    exports.CreateDataProperty = CreateDataProperty;
    exports.PropertyDescriptor = PropertyDescriptor;
    exports.IsAccessorDescriptor = IsAccessorDescriptor;
    exports.IsDataDescriptor = IsDataDescriptor;
    exports.IsGenericDescriptor = IsGenericDescriptor;
    exports.FromPropertyDescriptor = FromPropertyDescriptor;
    exports.ToPropertyDescriptor = ToPropertyDescriptor;
    exports.CompletePropertyDescriptor = CompletePropertyDescriptor;
    exports.ValidateAndApplyPropertyDescriptor = ValidateAndApplyPropertyDescriptor;
    exports.OrdinaryObject = OrdinaryObject;
    exports.ObjectCreate = ObjectCreate;
    exports.IsCallable = IsCallable;
    exports.IsConstructor = IsConstructor;
    exports.OrdinaryFunction = OrdinaryFunction;
    exports.FunctionEnvironment = FunctionEnvironment;
    exports.DeclarativeEnvironment = DeclarativeEnvironment;
    exports.GlobalEnvironment = GlobalEnvironment;
    exports.ObjectEnvironment = ObjectEnvironment;
    exports.SymbolPrimitiveType = SymbolPrimitiveType;
    exports.CodeRealm = CodeRealm;
    exports.ExecutionContext = ExecutionContext;
    exports.CompletionRecord = CompletionRecord;
    exports.NormalCompletion = NormalCompletion;
    exports.IdentifierBinding = IdentifierBinding;
    exports.floor = floor;
    exports.ceil = ceil;
    exports.sign = sign;
    exports.abs = abs;
    exports.min = min;
    exports.max = max;
    exports.Type = Type;
    exports.ToPrimitive = ToPrimitive;
    exports.ToString = ToString;
    exports.ToBoolean = ToBoolean;
    exports.ToUint32 = ToUint32;
    exports.ToNumber = ToNumber;
    exports.ToObject = ToObject;
    exports.GetValue = GetValue;
    exports.PutValue = PutValue;
    exports.GetBase = GetBase;
    exports.MakeSuperReference = MakeSuperReference;
    exports.IsSuperReference = IsSuperReference;
    exports.IsUnresolvableReference = IsUnresolvableReference;
    exports.IsPropertyReference = IsPropertyReference;
    exports.IsStrictReference = IsStrictReference;
    exports.GetReferencedName = GetReferencedName;
    exports.GetThisValue = GetThisValue;
    exports.HasPrimitiveBase = HasPrimitiveBase;
    exports.ifAbrupt = ifAbrupt;
    exports.isAbrupt = isAbrupt;
    exports.Assert = Assert;
    exports.unwrap = unwrap;
    exports.SameValue = SameValue;
    exports.SameValueZero = SameValueZero;
    exports.Type = Type;
    exports.Reference = Reference;
    exports.ToPrimitive = ToPrimitive;
    exports.ToInteger = ToInteger;
    exports.ToNumber = ToNumber;
    exports.ToUint16 = ToUint16;
    exports.ToInt32 = ToInt32;
    exports.ToUint32 = ToUint32;
    exports.OrdinaryHasInstance = OrdinaryHasInstance;
    exports.GetGlobalObject = GetGlobalObject;
    exports.ThisResolution = ThisResolution;
    exports.CreateArrayFromList = CreateArrayFromList;
    exports.CreateListFromArrayLike = CreateListFromArrayLike;
    exports.TestIntegrityLevel = TestIntegrityLevel;
    exports.SetIntegrityLevel = SetIntegrityLevel;
    exports.CheckObjectCoercible = CheckObjectCoercible;
    exports.HasProperty = HasProperty;
    exports.GetMethod = GetMethod;
    exports.Get = Get;
    exports.Set = Set;
    exports.DefineOwnProperty = DefineOwnProperty;
    exports.GetOwnProperty = GetOwnProperty;
    exports.OwnPropertyKeys = OwnPropertyKeys;
    exports.OwnPropertyKeysAsList = OwnPropertyKeysAsList;
    exports.GetOwnPropertyKeys = GetOwnPropertyKeys;
    exports.MakeListIterator = MakeListIterator;
    exports.DefineOwnPropertyOrThrow = DefineOwnPropertyOrThrow;
    exports.Delete = Delete;
    exports.Enumerate = Enumerate;
    exports.OwnPropertyKeys = OwnPropertyKeys;
    exports.SetPrototypeOf = SetPrototypeOf;
    exports.GetPrototypeOf = GetPrototypeOf;
    exports.PreventExtensions = PreventExtensions;
    exports.IsExtensible = IsExtensible;
    exports.CreateByteArrayBlock = CreateByteArrayBlock;
    exports.SetArrayBufferData = SetArrayBufferData;
    exports.AllocateArrayBuffer = AllocateArrayBuffer;
    exports.IntegerIndexedObjectCreate = IntegerIndexedObjectCreate;
    exports.StringExoticObject = StringExoticObject;
    exports.thisTimeValue = thisTimeValue;
    exports.thisNumberValue = thisNumberValue;
    exports.thisBooleanValue = thisBooleanValue;
    exports.thisStringValue = thisStringValue;
    exports.thisSymbolValue = thisSymbolValue;
    exports.MakeMethod = MakeMethod;
    exports.CloneMethod = CloneMethod;
    exports.newTypeError = newTypeError;
    exports.newSyntaxError = newSyntaxError;
    exports.newRangeError = newRangeError;
    exports.newEvalError = newEvalError;
    exports.newURIError = newURIError;
    exports.newReferenceError = newReferenceError;
    exports.TypedArrayFrom = TypedArrayFrom;
    // my own definitions between the ecma stuff
    exports.SetFunctionLength = SetFunctionLength;
    exports.LazyDefineProperty = LazyDefineProperty;
    exports.LazyDefineSelfHostingFunction = LazyDefineSelfHostingFunction;
    exports.createIntrinsics = createIntrinsics;
    exports.setCodeRealm = setCodeRealm;
    exports.saveCodeRealm = saveCodeRealm;
    exports.restoreCodeRealm = restoreCodeRealm;
    exports.Push = Push;
    exports.Length = Length;
    exports.getField = getField;
    exports.setField = setField;
    exports.setRec = setRec;
    exports.getRec = getRec;
    exports.genericArray = genericArray;
    exports.genericRecord = genericRecord;
    exports.getEventQueue = getEventQueue;
    exports.getContext = getContext;
    exports.getRealm = getRealm;
    exports.getLexEnv = getLexEnv;
    exports.getVarEnv = getVarEnv;
    exports.getIntrinsic = getIntrinsic;
    exports.getIntrinsics = getIntrinsics;
    exports.getGlobalEnv = getGlobalEnv;
    exports.getGlobalThis = getGlobalThis;
    exports.getStack = getStack;
    exports.getInternalSlot = getInternalSlot;
    exports.setInternalSlot = setInternalSlot;
    exports.hasInternalSlot = hasInternalSlot;
    exports.callInternalSlot = callInternalSlot;
    exports.printException = printException;
    exports.createExceptionTextOutput = createExceptionTextOutput;
    exports.stringifyErrorStack = stringifyErrorStack;
    exports.addMissingProperties = addMissingProperties;
//    exports.List = List; // never used (should be removed from code base)
    return exports;
});

define("runtime", function () {
//    function makeRuntime() {
    "use strict";
    var parse = require("parser");// .makeParser(); // soon: CREATE A _NEW_ PARSER (which creates a new tokenizer) HERE (when realm creates a NEW RUNTIME) (creating one now just slows down startup but brings no completly own closure)
    var ecma = require("api");
    var statics = require("slower-static-semantics");
    var parseGoal = parse.parseGoal;

    var debugmode = false;
    var isWorker = typeof importScripts === "function" && typeof window === "undefined";
    var hasConsole = typeof console === "object" && console && typeof console.log == "function";
    var hasPrint = typeof print === "function";

    function debug() {
        if (debugmode && hasConsole) console.log.apply(console, arguments);
    }
    function debugdir() {
        if (debugmode && hasConsole) console.dir.apply(console, arguments);
    }
    function consoleLog() {
        if (hasConsole) console.log.apply(console, arguments);
        else if (hasPrint) print.apply(undefined, arguments);
    }
    function consoleDir() {
        if (hasConsole) console.dir.apply(console, arguments);
        else if (hasPrint) print.apply(undefined, arguments);
    }

    // Assignment, backrefs, temp solution
    ecma.OrdinaryFunction.prototype.Call = Call;
    ecma.EvaluateBody = EvaluateBody;
    ecma.Evaluate = Evaluate;
    ecma.CreateGeneratorInstance = CreateGeneratorInstance;
    var DeclaredNames = statics.DeclaredNames;
    var BoundNames = statics.BoundNames;
    var VarScopedDeclarations = statics.VarScopedDeclarations;
    var LexicallyScopedDeclarations = statics.LexicallyScopedDeclarations;
    var VarDeclaredNames = statics.VarDeclaredNames;
    var LexicallyDeclaredNames = statics.LexicallyDeclaredNames;
    var LexicalDeclarations = statics.LexicalDeclarations;
    var IsLexicalDeclaration = statics.IsLexicalDeclaration;
    var IsConstantDeclaration = statics.IsConstantDeclaration;
    var ReferencesSuper = statics.ReferencesSuper;

    var ConstructorMethod = statics.ConstructorMethod;
    var PrototypeMethodDefinitions = statics.PrototypeMethodDefinitions;
    var StaticMethodDefinitions = statics.StaticMethodDefinitions;
    var HasInitializer = statics.HasInitializer;
    var IsSimpleParameterList = statics.IsSimpleParameterList;
    var ExpectedArgumentCount = statics.ExpectedArgumentCount;
    var IsValidSimpleAssignmentTarget = statics.IsValidSimpleAssignmentTarget;
    var PropName = statics.PropName;
    var PropNameList = statics.PropNameList;
    var SpecialMethod = statics.SpecialMethod;
    var ElisionWidth = statics.ElisionWidth;
    var IsStrict = statics.IsStrict;
    var IsAnonymousFunctionDefinition = statics.IsAnonymousFunctionDefinition;
    var StringValue = statics.StringValue;
    var IsIdentifierRef = statics.IsIdentifierRef;
    var SLOTS = ecma.SLOTS;
    var INTRINSICS = ecma.INTRINSICS;
    var OBJECT = ecma.OBJECT;
    var NUMBER = ecma.NUMBER;
    var STRING = ecma.STRING;
    var SYMBOL = ecma.SYMBOL;
    var BOOLEAN = ecma.BOOLEAN;
    var REFERENCE = ecma.REFERENCE;
    var ENVIRONMENT = ecma.ENVIRONMENT;
    var COMPLETION = ecma.COMPLETION;
    var UNDEFINED = ecma.UNDEFINED;
    var NULL = ecma.NULL;
    var NextTask = ecma.NextTask;
    var getTasks = ecma.getTasks;
    var RegExpCreate = ecma.RegExpCreate;
    var Assert = ecma.Assert;
    var assert = ecma.assert;
    var CreateRealm = ecma.CreateRealm;
    var CreateDataProperty = ecma.CreateDataProperty;
    var CreateAccessorProperty = ecma.CreateAccessorProperty;
    var ToPropertyKey = ecma.ToPropertyKey;
    var IsPropertyKey = ecma.IsPropertyKey;
    var IsSymbol = ecma.IsSymbol;
    var IsAccessorDescriptor = ecma.IsAccessorDescriptor;
    var IsDataDescriptor = ecma.IsDataDescriptor;
    var IsGenericDescriptor = ecma.IsGenericDescriptor;
    var FromPropertyDescriptor = ecma.FromPropertyDescriptor;
    var ToPropertyDescriptor = ecma.ToPropertyDescriptor;
    var CompletePropertyDescriptor = ecma.CompletePropertyDescriptor;
    var ValidateAndApplyPropertyDescriptor = ecma.ValidateAndApplyPropertyDescriptor;
    var ThrowTypeError = ecma.ThrowTypeError;
    var $$unscopables = ecma.$$unscopables;
    var $$create = ecma.$$create;
    var $$toPrimitive = ecma.$$toPrimitive;
    var $$toStringTag = ecma.$$toStringTag;
    var $$hasInstance = ecma.$$hasInstance;
    var $$iterator = ecma.$$iterator;
    var $$isRegExp = ecma.$$isRegExp;
    var $$isConcatSpreadable = ecma.$$isConcatSpreadable;
    var MakeMethod = ecma.MakeMethod;
    var NewFunctionEnvironment = ecma.NewFunctionEnvironment;
    var NewObjectEnvironment = ecma.NewObjectEnvironment;
    var NewDeclarativeEnvironment = ecma.NewDeclarativeEnvironment;
    var OrdinaryObject = ecma.OrdinaryObject;
    var ObjectCreate = ecma.ObjectCreate;
    var IsCallable = ecma.IsCallable;
    var IsConstructor = ecma.IsConstructor;
    var OrdinaryConstruct = ecma.OrdinaryConstruct;
    var Construct = ecma.Construct;
    var CreateFromConstructor = ecma.CreateFromConstructor;
    var OrdinaryCreateFromConstructor = ecma.OrdinaryCreateFromConstructor;
    var FunctionCreate = ecma.FunctionCreate;
    var FunctionAllocate = ecma.FunctionAllocate;
    var FunctionInitialize = ecma.FunctionInitialize;
    var GeneratorFunctionCreate = ecma.GeneratorFunctionCreate;
    var OrdinaryFunction = ecma.OrdinaryFunction;
    var FunctionEnvironment = ecma.FunctionEnvironment;
    var SymbolPrimitiveType = ecma.SymbolPrimitiveType;
    var ExecutionContext = ecma.ExecutionContext;
    var CodeRealm = ecma.CodeRealm;
    var CompletionRecord = ecma.CompletionRecord;
    var NormalCompletion = ecma.NormalCompletion;
    var Completion = ecma.Completion;
    var OrdinaryHasInstance = ecma.OrdinaryHasInstance;
    var floor = ecma.floor;
    var ceil = ecma.ceil;
    var sign = ecma.sign;
    var abs = ecma.abs;
    var min = ecma.min;
    var max = ecma.max;
    var IdentifierBinding = ecma.IdentifierBinding;
    var GlobalEnvironment = ecma.GlobalEnvironment;
    var ObjectEnvironment = ecma.ObjectEnvironment;
    var ToNumber = ecma.ToNumber;
    var ToUint16 = ecma.ToUint16;
    var ToInt32 = ecma.ToInt32;
    var ToUint32 = ecma.ToUint32;
    var ToString = ecma.ToString;
    var ToObject = ecma.ToObject;
    var Type = ecma.Type;
    var Reference = ecma.Reference;
    var GetIdentifierReference = ecma.GetIdentifierReference;
    var IsSuperReference = ecma.IsSuperReference;
    var GetThisEnvironment = ecma.GetThisEnvironment;
    var GetOwnProperty = ecma.GetOwnProperty;
    var GetValue = ecma.GetValue;
    var PutValue = ecma.PutValue;
    var SameValue = ecma.SameValue;
    var SameValueZero = ecma.SameValueZero;
    var ToPrimitive = ecma.ToPrimitive;
    var GetGlobalObject = ecma.GetGlobalObject;
    var ThisResolution = ecma.ThisResolution;
    var CreateArrayFromList = ecma.CreateArrayFromList;
    var CreateListFromArrayLike = ecma.CreateListFromArrayLike;
    var TestIntegrityLevel = ecma.TestIntegrityLevel;
    var SetIntegrityLevel = ecma.SetIntegrityLevel;
    var Intrinsics;
    var MakeConstructor = ecma.MakeConstructor;
    var ArrayCreate = ecma.ArrayCreate;
    var ArraySetLength = ecma.ArraySetLength;
    var GeneratorStart = ecma.GeneratorStart;
    var GeneratorYield = ecma.GeneratorYield;
    var GeneratorResume = ecma.GeneratorResume;
    var CreateEmptyIterator = CreateEmptyIterator;
    var ToBoolean = ecma.ToBoolean;
    var CreateItrResultObject = ecma.CreateItrResultObject;
    var IteratorNext = ecma.IteratorNext;
    var IteratorComplete = ecma.IteratorComplete;
    var IteratorValue = ecma.IteratorValue;
    var GetIterator = ecma.GetIterator;
    var SetFunctionName = ecma.SetFunctionName;
    var Invoke = ecma.Invoke;
    var Get = ecma.Get;
    var Set = ecma.Set;
    var DefineOwnProperty = ecma.DefineOwnProperty;
    var DefineOwnPropertyOrThrow = ecma.DefineOwnPropertyOrThrow;
    var Delete = ecma.Delete;
    var Enumerate = ecma.Enumerate;
    var OwnPropertyKeys = ecma.OwnPropertyKeys;
    var OwnPropertyKeysAsList = ecma.OwnPropertyKeysAsList;
    var SetPrototypeOf = ecma.SetPrototypeOf;
    var GetPrototypeOf = ecma.GetPrototypeOf;
    var PreventExtensions = ecma.PreventExtensions;
    var IsExtensible = ecma.IsExtensible;
    var Put = ecma.Put;
    var GetMethod = ecma.GetMethod;
    var HasProperty = ecma.HasProperty;
    var HasOwnProperty = ecma.HasOwnProperty;
    var IsPropertyReference = ecma.IsPropertyReference;
    var MakeSuperReference = ecma.MakeSuperReference;
    var IsUnresolvableReference = ecma.IsUnresolvableReference;
    var IsStrictReference = ecma.IsStrictReference;
    var HasPrimitiveBase = ecma.HasPrimitiveBase;
    var GetBase = ecma.GetBase;
    var GetReferencedName = ecma.GetReferencedName;
    var GetThisValue = ecma.GetThisValue;
    var empty = ecma.empty;
    var all = ecma.all;
    var StrictEqualityComparison = ecma.StrictEqualityComparison;
    var AbstractEqualityComparison = ecma.AbstractEqualityComparison;
    var AbstractRelationalComparion = ecma.AbstractRelationalComparison;
    var ArgumentsExoticObject = ecma.ArgumentsExoticObject;

    var AddRestrictedFunctionProperties = ecma.AddRestrictedFunctionProperties;
    var ifAbrupt = ecma.ifAbrupt;
    var isAbrupt = ecma.isAbrupt;
    var unwrap = ecma.unwrap;
    var setInternalSlot = ecma.setInternalSlot;
    var getInternalSlot = ecma.getInternalSlot;
    var hasInternalSlot = ecma.hasInternalSlot;
    var callInternalSlot = ecma.callInternalSlot;
    var getRealm = ecma.getRealm;
    var getLexEnv = ecma.getLexEnv;
    var getVarEnv = ecma.getVarEnv;
    var getIntrinsics = ecma.getIntrinsics;
    var getIntrinsic = ecma.getIntrinsic;
    var getGlobalThis = ecma.getGlobalThis;
    var getGlobalEnv = ecma.getGlobalEnv;
    var getStack = ecma.getStack;
    var getContext = ecma.getContext;
    var getEventQueue = ecma.getEventQueue;
    var SetFunctionLength = ecma.SetFunctionLength;
    var writePropertyDescriptor = ecma.writePropertyDescriptor;
    var withError = ecma.withError;
    var newSyntaxError = ecma.newSyntaxError;
    var newTypeError = ecma.newTypeError;
    var newReferenceError = ecma.newReferenceError;

    var printException = ecma.printException;
    var createExceptionTextOutput = ecma.createExceptionTextOutput;
    var CheckObjectCoercible = ecma.CheckObjectCoercible;
    var line, column;
    var realm, intrinsics, globalEnv, globalThis;
    var stack, eventQueue;
    var scriptLocation;
    var initializedTheRuntime = false;
    var shellMode;  // keep strict mode turned on
    var keepStrict; // idea for legacy shell mode (until i remove whole syntaxjs.eval for syntaxjs.createRealm().eval() and kick shared state with factories)
    var evaluation = Object.create(null);
    var strictModeStack = [];
    var inStrictMode = false;
    var loc = {};
    var generatorState;
    var IsFunctionDeclaration = statics.IsFunctionDeclaration;
    var IsFunctionExpression = statics.IsFunctionExpression;
    var IsGeneratorDeclaration = statics.IsGeneratorDeclaration;
    var IsGeneratorExpression = statics.IsGeneratorExpression;
    var IsVarDeclaration = statics.IsVarDeclaration;
    var isDuplicateProperty = statics.isDuplicateProperty;
    var IsIdentifier = statics.IsIdentifier;
    var CV = statics.CV;
    var MV = statics.MV;
    var SV = statics.SV;
    var TV = statics.TV;
    var TRV = statics.TRV;
    var isFuncDecl = {
        "GeneratorDeclaration":true,
        "FunctionDeclaration":true,
        __proto__:null
    };
    var IsBindingPattern = {
        __proto__: null,
        "ObjectPattern": true,
        "ArrayPattern": true
    };
    var ControlStatement = {
        "IfStatement": true,
        "SwitchStatement": true
    };
    var isUndefined = {__proto__:null, "undefined":true, "null":true};
    var isValidSimpleAssignmentTarget = {
        "ObjectPattern": true,
        "ArrayPattern": true,
        "ObjectExpression": true,
        "ArrayExpression": true
    };
    var IterationStatements = {
        "ForStatement": true
    };
    var BreakableStatements = {
        "WhileStatement": true,
        "DoWhileStatement": true,
        "SwitchStatement": true
    };
    var SkipMeDeclarations = {
        __proto__: null,
        "FunctionDeclaration": true,
        "GeneratorDeclaration": true
    };
    var makeNativeException = ecma.makeNativeException;

    function setCodeRealm(r) {
        if (r) {
            realm = r;
            stack = realm.stack;
            intrinsics = realm.intrinsics;
            globalEnv = realm.globalEnv;
            globalThis = realm.globalThis;
            eventQueue = realm.eventQueue;
        }
    }
    function inStrict (node) {
        if (node && node.strict) return true;
        return getContext().strict;

    }
    function SkipDecl(node) {
        return SkipMeDeclarations[node.type] && !node.expression;

    }
    function assign(obj, obj2) {
        for (var k in obj2) {
            if (Object.prototype.hasOwnProperty.call(obj2, k)) obj[k] = obj2[k];
        }
        return obj;
    }

    function unquote(str) {
        return str.replace(/^("|')|("|')$/g, "");  //'
    }

    function repeatch(ch, times) {
        var str = "";
        for (var i = 0; i < times; i++) str += ch;
        return str;
    }

    function atLineCol() {
        var line = loc && loc.start.line;
        var column = loc && loc.start.column;
        return " at line "+line+", column "+column;
    }

    function banner(str) {
        if (hasConsole) {
            consoleLog(repeatch("-", 79));
            consoleLog(str);
            consoleLog(repeatch("-", 79));
        } else if(hasPrint) {
            print(repeatch("-", 79));
            print(str);
            print(repeatch("-", 79));
        }
    }
    function ResolveBinding(name) {
        var lex = getLexEnv();
        var strict = getContext().strict;
        return GetIdentifierReference(lex, name, strict);
    }
    function InstantiateModuleDeclaration(code, env) {
        var declarations = LexicalDeclaration(code);
        var functionsToInitialize = [];
        for (var i = 0, j = declarations.length; i < j; i++) {
            if (d = declarations[i]) {
                var boundNames = BoundNames(d);
                for (var k = 0, l = boundNames.length; k < l; k++) {
                    var dn = boundNames[k];
                    if (IsConstantDeclaration(d)) {
                        env.CreateImmutableBinding(dn);
                    } else  {
                        var status = env.CreateMutableBinding(dn, false);
                        if (isAbrupt(status)) return status;
                    }
                }
                if (IsGeneratorDeclaration(d)) {
                    functionsToInitialize.push(d);
                }
            }
        }
        for (i = 0, j = functionsToInitialize.length; i < j; i++) {
            var fn = BoundNames(f)[0];
            var fo = InstantiateFunctionObject(f, env);
            env.InitializeBinding(fn, fo);
        }
    }
    function InstantiateGlobalDeclaration(script, env, deletableBindings) {
        "use strict";

        var name;
        var boundNamesInPattern;
        var code = script.body
        var strict = !!script.strict;
        var cx = getContext();
        if (strict) cx.strict = true;
        var lexNames = LexicallyDeclaredNames(code);
        var varNames = VarDeclaredNames(code);
        var i, j, y, z;
        var status, ex;
        for (i = 0, j = lexNames.length; i < j; i++) {
            if (name = lexNames[i]) {
                if (env.HasVarDeclaration(name)) return newSyntaxError( "Instantiate global: existing var declaration: " + name);
                if (env.HasLexicalDeclaration(name)) return newSyntaxError( "Instantiate global: existing lexical declaration: " + name);
            }
        }

        for (i = 0, j = varNames.length; i < j; i++) {
            if (name = varNames[i]) {
                if (env.HasLexicalDeclaration(name)) return newSyntaxError( "Instantiate global: var " + name + " has already a lexical declaration: " + name);
            }
        }

        var varDeclarations = VarScopedDeclarations(script.body);
        var functionsToInitialize = [];
        var declaredFunctionNames = Object.create(null);
        var d;
        var fn;
        var fnDefinable;
        for (i = varDeclarations.length - 1, j = 0; i >= j; i--) {
            d = varDeclarations[i];
            if (isFuncDecl[d.type]) {
                fn = d && (d.id || d.id.name);
                fnDefinable = env.CanDeclareGlobalFunction(fn);
                if (!fnDefinable) return newTypeError( "Instantiate global: can not declare global function: " + fn);
                declaredFunctionNames[fn] = d;
                functionsToInitialize.push(d);
            }
        }
        var vnDefinable;
        var declaredVarNames = Object.create(null);
        var vn;
        for (i = 0, j = varDeclarations.length; i < j; i++) {
            d = varDeclarations[i];

            if (d.type === "VariableDeclarator") {

                vn = d.id.name;
                if (!declaredVarNames[vn]) {
                    vnDefinable = env.CanDeclareGlobalVar(vn);
                    //debug("Can declare global var: " + vn + ", is " + vnDefinable);
                    if (!vnDefinable) return newTypeError( "Instantiate global: can not declare global variable" + vn);
                    declaredVarNames[vn] = d;
                } //else //debug(vn + "is already declared");

            } else if (IsBindingPattern[d.type]) { // extra hack or spec update ?

                boundNamesInPattern = BoundNames(d.elements);
                for (y = 0, z = boundNamesInPattern.length; y < z; y++) {
                    vn = boundNamesInPattern[y];
                    if (!declaredVarNames[vn]) {
                        vnDefinable = env.CanDeclareGlobalVar(vn);
                        //debug("Can declare global var: " + vn + ", is " + vnDefinable);
                        if (!vnDefinable) return newTypeError( "Instantiate global: can not declare global variable" + vn);
                        declaredVarNames[vn] = d;
                    } //else //debug(vn + "is already declared");
                }
            }
        }
        var fo;
        // if (functionsToInitialize.length) //debug("Functions to initialize: " + functionsToInitialize.length);
        for (i = 0, j = functionsToInitialize.length; i < j; i++) {
            d = functionsToInitialize[i];
            fn = d.id;
            fo = InstantiateFunctionObject(d, env);
            status = env.CreateGlobalFunctionBinding(fn, fo, deletableBindings);
            if (isAbrupt(status)) return status;
            //status = SetFunctionName(fo, fn);
            //if (isAbrupt(status)) return status;
        }
        for (d in declaredVarNames) {
            status = env.CreateGlobalVarBinding(d, deletableBindings);
            if (isAbrupt(status)) return status;
        }

        var lexDeclarations = LexicalDeclarations(script.body);
        var dn, kind;
        for (i = 0, j = lexDeclarations.length; i < j; i++) {
            //debug("lexdecls: " + j);
            d = lexDeclarations[i];
            kind = d.kind;
            if (IsBindingPattern[d.type]) { // extra hack
                boundNamesInPattern = BoundNames(d.elements);
                for (y = 0, z = boundNamesInPattern.length; y < z; y++) {
                    dn = boundNamesInPattern[y];
                    if (kind === "const") status = env.CreateImmutableBinding(dn);
                    else status = env.CreateMutableBinding(dn);
                    if (isAbrupt(status)) return status;
                }
            } else if (kind === "const") {
                dn = d.id.name;
                status = env.CreateImmutableBinding(dn);
                if (isAbrupt(status)) return status;
            } else if (kind === "let") {
                dn = d.id.name;
                status = env.CreateMutableBinding(dn, deletableBindings);
                if (isAbrupt(status)) return status;
            } else if (d.generator) {
                fn = d.id;
                fo = InstantiateFunctionObject(d, env);
                status = env.CreateMutableBinding(fn);
                if (isAbrupt(status)) return status;
                status = env.InitializeBinding(fn, fo, false);
                if (isAbrupt(status)) return status;
                //status = SetFunctionName(fo, fn);
                //if (isAbrupt(status)) return status;
            }
        }
    }
    function InstantiateBlockDeclaration(code, env) {
        "use strict";
        var ex;
        var declarations = LexicalDeclarations(code);
        var decl, functionsToInitialize = [];
        var fn;
        var fo;
        var type, kind;
        var status;
        for (var i = 0, j = declarations.length; i < j; i++) {
            if (decl = declarations[i]) {
                type = decl.type;
                kind = decl.kind;
                if (isFuncDecl[type] && (!decl.expression)) {
                    functionsToInitialize.push(decl);
                } else {
                    var names = BoundNames(decl);
                    for (var y = 0, z = names.length; y < z; y++) {
                        var dn = names[y];
                        if (type === "VariableDeclarator") { // here i had a bug first
                            if (kind === "const") { // this will fail with es (decl has no .kind yet, just the array´s container node)
                                status = env.CreateImmutableBinding(dn);
                                if (isAbrupt(status)) return status;
                            } else {
                                status = env.CreateMutableBinding(dn);
                                if (isAbrupt(status)) return status;
                            }
                        }
                    }
                }
            }
        }
        for (i = 0, j = functionsToInitialize.length; i < j; i++) {
            fn = functionsToInitialize[i].id;
            fo = InstantiateFunctionObject(functionsToInitialize[i], env);
            env.SetMutableBinding(fn, fo, false);
            SetFunctionName(fo, fn);
        }
    }
    function InstantiateFunctionObject(node, env) {

        var F;
        var cx = getContext();
        var params = node.params;
        var body = node.body;
        var generator = !!node.generator;
        var needsSuper = !!node.needsSuper;
        var strict = cx.strict || !!node.strict;
        var scope = env;

        if (!generator) {
            var name = node.id;
            F = FunctionCreate("normal", params, body, scope, strict);
            // 14.1.16 4.
            if (needsSuper) MakeMethod(F, name, undefined);
            MakeConstructor(F);
            if (name) SetFunctionName(F, name);
        } else if (generator) {
            strict = true;
            var name = node.id;
            F = GeneratorFunctionCreate("generator", params, body, scope, strict);
            var prototype = ObjectCreate(getIntrinsic(INTRINSICS.GENERATORPROTOTYPE));
            if (name) SetFunctionName(F, name);
            MakeConstructor(F, true, prototype);
        }

        var realm = getRealm();
        setInternalSlot(F, SLOTS.REALM, realm);
        return F;
    }
    function InstantiateFunctionDeclaration(F, argList, env) {
        "use strict";
        var x;
        //console.log("ins=");
        //console.dir(argList);
        var cx = getContext();
        var code = getInternalSlot(F, SLOTS.CODE);
        var formals = getInternalSlot(F, SLOTS.FORMALPARAMETERS);
        var strict = getInternalSlot(F, SLOTS.STRICT);
        var thisMode = getInternalSlot(F, SLOTS.THISMODE);
        var boundNamesInPattern;
        var parameterNames = BoundNames(formals);
        var varDeclarations = VarScopedDeclarations(code);
        var argumentsObjectNeeded;
        argumentsObjectNeeded = thisMode !== "lexical";
        var d;
        var fn;
        var fo;
        var functionsToInitialize = [];
        var alreadyDeclared;
        var status;
        for (var j = 0, i = varDeclarations.length; i >= j; i--) {
            if (d = varDeclarations[i]) {
                if (IsFunctionDeclaration(d)) {
                    fn = BoundNames(d)[0];
                    alreadyDeclared = env.HasBinding(fn);
                    if (isAbrupt(alreadyDeclared)) return alreadyDeclared;
                    if (!alreadyDeclared) {
                        env.CreateMutableBinding(fn);
                        functionsToInitialize.push(d);
                    }
                }
            }
        }
        var paramName;
        for (i = 0, j = parameterNames.length; i < j; i++) {
            if (paramName = parameterNames[i]) {
                alreadyDeclared = env.HasBinding(paramName);
                if (!alreadyDeclared) {
                    if (paramName === "arguments") argumentsObjectNeeded = false;
                    status = env.CreateMutableBinding(paramName, false);
                    //if (isAbrupt(status)) return status;
                }
            }
        }
        if (argumentsObjectNeeded) {
            if (strict) {
                env.CreateImmutableBinding("arguments");
            } else {
                env.CreateMutableBinding("arguments");
            }
        }
        var varNames = VarDeclaredNames(code);
        var varName;
        for (i = 0, j = varNames.length; i < j; i++) {
            if (varName = varNames[i]) {
                alreadyDeclared = env.HasBinding(varName);
                if (!alreadyDeclared) {
                    var status = env.CreateMutableBinding(varName);
                    //if (isAbrupt(status)) return status;
                }
            }
        }
        var lexDeclarations = LexicalDeclarations(code);
        var dn, bn;
        for (i = 0, j = lexDeclarations.length; i < j; i++) {
            if (d = lexDeclarations[i]) {
                bn = BoundNames(d);
                for (var y = 0, z = bn.length; y < z; y++) {
                    dn = bn[y];
                    if (IsGeneratorDeclaration(d)) {
                        functionsToInitialize.push(d);
                    } else if (IsConstantDeclaration(d)) {
                        env.CreateImmutableBinding(dn);
                    } else {
                        env.CreateMutableBinding(dn);
                    }
                }
            }
        }
        for (i = 0, j = functionsToInitialize.length; i < j; i++) {
            if (d = functionsToInitialize[i]) {
                fn = BoundNames(d)[0];
                fo = InstantiateFunctionObject(d, env);
                env.InitializeBinding(fn, fo, false);
            }
        }
        var ao = InstantiateArgumentsObject(argList);
        if (isAbrupt(ao = ifAbrupt(ao))) return ao;
        var formalStatus = BindingInitialization(formals, ao, undefined);
        if (isAbrupt(formalStatus)) return formalStatus;

        if (argumentsObjectNeeded) {
            if (strict) {
                CompleteStrictArgumentsObject(ao);
            } else {
                CompleteMappedArgumentsObject(ao, F, formals, env);
            }
            env.InitializeBinding("arguments", ao);
        }
        return F;
    }
    function InstantiateArgumentsObject(args) {
        var len = args.length;
        var obj = ArgumentsExoticObject();
        /* callInternalSlot(SLOTS.DEFINEOWNPROPERTY, */

        writePropertyDescriptor(obj, "length", {
            value: len,
            writable: true,
            configurable: true,
            enumerable: false
        });
        var indx = len - 1;
        var val;
        while (indx >= 0) {
            val = args[indx];
            //callInternalSlot(SLOTS.DEFINEOWNPROPERTY,
            writePropertyDescriptor(obj, ToString(indx), {
                value: val,
                writable: true,
                enumerable: true,
                configurable: true
            });
            indx = indx - 1;
        }

        return obj;
    }
    function CompleteStrictArgumentsObject(obj) {
        AddRestrictedFunctionProperties(obj);
        return obj;
    }

    function CompleteMappedArgumentsObject(obj, F, formals, env) {

        var len = Get(obj, "length");
        formals = formals || [];
        env = env || getLexEnv().outer;
        var mappedNames = Object.create(null);
        var numberOfNonRestFormals;
        var i = 0;
        while (i < formals.length) {
            if (formals[i].type === "RestParameter") break;
            ++i;
        }
        numberOfNonRestFormals = i;
        var map = ObjectCreate();
        var name;
        var indx = len - 1;
        var param;
        var g,s;
        while (indx >= 0) {
            if (indx < numberOfNonRestFormals) {
                param = formals[indx];
                if (IsBindingPattern[param.type]) { // extra hack ?
                    var elem;
                    for (var x = 0, y = param.elements.length; x < y; x++) {
                        elem = param.elements[i];
                        name = elem.target ? elem.target.name : (elem.name || elem.value);
                        if (!mappedNames[name]) {
                            mappedNames[name] = true;
                            g = MakeArgGetter(name, env);
                            s = MakeArgSetter(name, env);
                            callInternalSlot(SLOTS.DEFINEOWNPROPERTY, map, name, {
                                get: g,
                                set: s,
                                enumerable: true,
                                configurable: true
                            });
                        }
                    }
                } else {
                    if (param.type === "Identifier") {
                        name = param.name || param.value;
                    } else if (param.type === "DefaultParameter") {
                        name = param.id;
                    } else name = "";
                    if (name && !mappedNames[name]) {
                        mappedNames[name] = true;
                        g = MakeArgGetter(name, env);
                        s = MakeArgSetter(name, env);
                        callInternalSlot(SLOTS.DEFINEOWNPROPERTY, map, name, {
                            get: g,
                            set: s,
                            enumerable: true,
                            configurable: true
                        });
                    }
                }
            }
            indx = indx - 1;
        }

        if (Object.keys(mappedNames).length) {
            setInternalSlot(obj, SLOTS.PARAMETERMAP, map);
        }

        var status = DefineOwnPropertyOrThrow(map, $$iterator, {
            value: getIntrinsic("%ArrayProto_values%"),
            enumerable: false,
            writeable: true,
            configurable: true
        });

        if (isAbrupt(status)) return status;
        status = DefineOwnPropertyOrThrow(obj, "callee", {
            value: F,
            writable: false,
            configurable: false,
            enumerable: false
        });
        if (isAbrupt(status)) return status;

        return obj;
    }
    function makeArgumentsGetter(name) {
        return [{
            type: "ReturnStatement",
            argument: {
                type: "Identifier",
                name: name
            }
        }];
    }
    function makeArgumentsSetterFormals(name) {
        return [{
            type: "Identifier",
            name: name + "_arg"
        }];
    }
    function makeArgumentsSetter(name) {
        return {
            type: "AssigmentExpression",
            operator: "=",
            left: {
                type: "Identifier",
                name: name
            },
            right: {
                type: "Identifier",
                name: name + "_arg"
            }
        };
    }
    function MakeArgGetter(name, env) {
        var bodyText = makeArgumentsGetter(name);
        var formals = [];
        //var bodyText = parseGoal("FunctionBody", "return " + name + ";");
        //var formals = [];
        var F = FunctionCreate("normal", formals, bodyText, env, true);
        return F;
    }
    function MakeArgSetter(name, env) {
        var bodyText = makeArgumentsSetter(name);
        var formals = makeArgumentsSetterFormals(name);
        //var bodyText = parseGoal("FunctionBody", name + "= " + name + "_arg;");
        //var formals = parseGoal("FormalParameterList", name + "_arg");
        return FunctionCreate("normal", formals, bodyText, env, true);

    }
    function ArgumentListEvaluation(list) {
        var args = [], arg, type, value;
        for (var i = 0, j = list.length; i < j; i++) {
            arg = list[i];
            type = arg.type;
            if (type === "TemplateLiteral") {
                var siteObj = GetTemplateCallSite(arg);
                var substitutions = SubstitutionEvaluation(siteObj);
                if (isAbrupt(substitutions = ifAbrupt(substitutions))) return substitutions;
                args.push(siteObj);
                for (var k = 0, l = substitutions.length; k < l; k++) args.push(substitutions[k]);
                return args;
            } else if (type === "SpreadExpression") {
                var array = GetValue(Evaluate(arg));
                if (isAbrupt(array = ifAbrupt(array))) return array;
                var l = Get(array, "length");
                if (isAbrupt(l=ifAbrupt(l))) return l;
                for (var k = 0; k < l; k++) {
                    value = Get(array, ToString(k));
                    if (isAbrupt(value = ifAbrupt(value))) return value;
                    args.push(value);
                }
            } else {
                // Identifer und Literals.
                var argRef = Evaluate(arg);
                if (isAbrupt(argRef = ifAbrupt(argRef))) return argRef;
                var argValue = GetValue(argRef);
                if (isAbrupt(argValue = ifAbrupt(argValue))) return argValue;
                args.push(argValue);
            }
        }
        return args;
    }

    // tmp for require("vm") just to test
    ecma.EvaluateCall = EvaluateCall;
    ecma.ArgumentListEvaluation = ArgumentListEvaluation


    function EvaluateCall(ref, args, tailPosition) {
        var thisValue;
        
        var func = GetValue(ref);
        
        if (isAbrupt(func = ifAbrupt(func))) return func;
        var argList = ArgumentListEvaluation(args);
        
        if (isAbrupt(argList = ifAbrupt(argList))) return argList;

        if (Type(func) !== OBJECT) return newTypeError( "EvaluateCall: func is not an object");
        if (!IsCallable(func)) return newTypeError( "EvaluateCall: func is not callable");

        if (Type(ref) === REFERENCE) {
            if (IsPropertyReference(ref)) {
                thisValue = GetThisValue(ref);
            } else {
                var env = GetBase(ref);
                thisValue = env.WithBaseObject();
            }
            
        } else {
            thisValue = undefined;
        }
        
//        if (tailPosition) { PrepareForTailCall(); }

        var result = callInternalSlot(SLOTS.CALL, func, thisValue, argList);

//        if (tailPosition) {}
        return result;

    }
    function Call(thisArg, argList) {
        var status, result, fname, localEnv;
        var F = this;
        var code = getInternalSlot(this, SLOTS.CODE);
        if (!code) return newTypeError( "Call: this value has no [[Code]] slot (if you called a native function it´s a bug and it´s [[Call]] isn´t set. but that shouldn´t happen.)");
        var params = getInternalSlot(this, SLOTS.FORMALPARAMETERS);
        var thisMode = getInternalSlot(this, SLOTS.THISMODE);
        var strictSlot = getInternalSlot(this, SLOTS.STRICT);
        var scope = getInternalSlot(this, SLOTS.ENVIRONMENT);
        var realm = getRealm();
        var callerContext = getContext();
        var calleeContext = ExecutionContext(getContext());
        var calleeName = Get(this, "name"); // costs time and money, is just for the context.name for stackframe
        var callerName = callerContext.callee;
        stack.push(calleeContext);
        calleeContext.realm = realm;
        calleeContext.caller = callerName;
        calleeContext.callee = calleeName;
        if (thisMode === "lexical") {
            localEnv = NewDeclarativeEnvironment(scope);
        } else {
            if (thisMode === "strict" || strictSlot) {
                this.thisValue = thisArg;
                calleeContext.strict = true;
            } else {
                if (thisArg === null || thisArg === undefined) {
                    this.thisValue = getGlobalThis();
                } else if (Type(thisArg) !== OBJECT) {
                    this.thisValue = ToObject(thisArg);
                } else if (Type(thisArg) === OBJECT) {
                    this.thisValue = thisArg;
                } else {
                    this.thisValue = getGlobalThis();
                }
            }
            localEnv = NewFunctionEnvironment(this, this.thisValue);
            if (isAbrupt(localEnv=ifAbrupt(localEnv))) return localEnv;
        }
        calleeContext.VarEnv = localEnv;
        calleeContext.LexEnv = localEnv;
        status = InstantiateFunctionDeclaration(this, argList, localEnv);
        if (isAbrupt(status = ifAbrupt(status))) return status;
        result = EvaluateBody(this);
        Assert(stack.pop() === calleeContext, "The right context could not be popped from the stack");
        return result;
    }
    function PrepareForTailCall() {
        getStack().pop();
    }
    evaluation.SpreadExpression = SpreadExpression;
    function SpreadExpression(node) {
        return Evaluate(node.argument);
    }
    evaluation.BreakStatement = BreakStatement;
    function BreakStatement(node) {
        return Completion("break", undefined, node.label || empty);
    }
    evaluation.ContinueStatement = ContinueStatement;
    function ContinueStatement(node) {
        return Completion("continue", undefined, node.label || empty);
    }
    evaluation.ThrowStatement = ThrowStatement;
    function ThrowStatement(node) {
        var expr = node.argument;

        var exprRef = Evaluate(expr);
        if (isAbrupt(exprRef)) return exprRef;
        var exprValue = GetValue(exprRef);

        return Completion("throw", exprValue, empty);
    }
    evaluation.ReturnStatement = ReturnStatement;
    function ReturnStatement(node) {
        var expr = node.argument;
        var exprRef = Evaluate(expr);
        if (isAbrupt(exprRef)) return exprRef;
        var exprValue = GetValue(exprRef);
        return Completion("return", exprValue, empty);
    }
    evaluation.YieldExpression = YieldExpression;
    function YieldExpression(node, completion) {

        var parent = node.parent;
        var expression = node.argument;
        var delegator = node.delegator;

        if (!expression) {

            return GeneratorYield(CreateItrResultObject(undefined, false));

        }

        var exprRef = Evaluate(expression);
        var value = GetValue(exprRef);
        if (isAbrupt(value = ifAbrupt(value))) return value;
        if (delegator) {
            var iterator = GetIterator(value);
            if (isAbrupt(iterator = ifAbrupt(iterator))) return iterator;
            var received = completion || NormalCompletion(undefined);
            var innerResult, done, innerValue;
            for (;;) {
                if (received.type === "normal") {
                    innerResult = IteratorNext(iterator, received.value);
                    if (isAbrupt(innerResult = ifAbrupt(innerResult))) return innerResult;
                } else {
                    Assert(received.type === "throw", "YieldExpression: at this point the completion has to contain the throw type");
                    if (HasProperty(iterator, "throw")) {
                        innerResult = Invoke(iterator, "throw", [received.value]);
                        if (isAbrupt(innerResult = ifAbrupt(innerResult))) return innerResult;
                    } else {
                        return received;
                    }
                }
                var done = IteratorComplete(iterator);
                if (isAbrupt(done = ifAbrupt(done))) return done;
                if (done) {
                    innerValue = IteratorValue(innerResult);
                    return innerValue;
                }
                received = GeneratorYield(innerResult);
            }
        } else {
            return GeneratorYield(CreateItrResultObject(value, false));
        }
    }
    function CreateGeneratorInstance(F) {
        var env = GetThisEnvironment();
        var G = env.GetThisBinding();
        if (Type(G) !== OBJECT || (Type(G) === OBJECT && getInternalSlot(G, SLOTS.GENERATORSTATE) === undefined)) {
            var newG = OrdinaryCreateFromConstructor(F, INTRINSICS.GENERATORPROTOTYPE, [
                SLOTS.GENERATORSTATE,
                SLOTS.GENERATORCONTEXT
            ]);
            if (isAbrupt(newG = ifAbrupt(newG))) return newG;
            G = newG;
        }
        return GeneratorStart(G, getInternalSlot(F, SLOTS.CODE));
    }
    function EvaluateConciseBody(F) {
        "use strict";
        var code = F.Code;
        var exprRef, exprValue;
        var node;
        if (!Array.isArray(code) && code) {
            exprValue = GetValue(Evaluate(code));
            if (isAbrupt(exprValue)) return exprValue;
            return NormalCompletion(exprValue);
        }
        for (var i = 0, j = code.length; i < j; i++) {
            if (node = code[i]) {
                // tellExecutionContext(node, i, code);
                exprRef = Evaluate(node);
                if (isAbrupt(exprRef)) {
                    // untellExecutionContext()
                    if (exprRef.type === "return") {
                        return NormalCompletion(exprRef.value);
                    } else return exprRef;
                }
            }
        }
        // untellExecutionContext();
        return exprRef;
    }
    function EvaluateBody(F) {
        "use strict";
        var exprRef, exprValue;
        var node;
        var code = getInternalSlot(F,SLOTS.CODE);
        var kind = getInternalSlot(F, SLOTS.FUNCTIONKIND);
        var thisMode = getInternalSlot(F, SLOTS.THISMODE);
        if (kind === "generator") {
            return CreateGeneratorInstance(F);
        } else if (thisMode === "lexical") {
            return EvaluateConciseBody(F);
        }
        for (var i = 0, j = code.length; i < j; i++) {
            if ((node = code[i])) {
                // tellExecutionContext(node, i, code);
                exprRef = Evaluate(node);
                if (isAbrupt(exprRef=ifAbrupt(exprRef))) {
                    // untellExecutionContext();
                    if (exprRef.type === "return") {
                        return NormalCompletion(exprRef.value);
                    } else return exprRef;
                }
            }
        }
        // untellExecutionContext();
        return NormalCompletion(undefined);
    }
    function EvaluateModuleBody(M) {
        "use strict";
        var exprRef, exprValue;
        var node;
        var code = M.body;
        for (var i = 0, j = code.length; i < j; i++) {
            if ((node = code[i])) {
                // tellExecutionContext(node, i, code);
                exprRef = Evaluate(node);
                if (isAbrupt(exprRef=ifAbrupt(exprRef))) {
                    // untellExecutionContext();
                    if (exprRef.type === "return") {
                        return NormalCompletion(exprRef.value);
                    } else return exprRef;
                }
            }
        }
        // untellExecutionContext();
        return NormalCompletion(exprRef);
    }
    evaluation.GeneratorExpression = GeneratorDeclaration;
    evaluation.GeneratorDeclaration = GeneratorDeclaration;
    function GeneratorDeclaration(node) {
        "use strict";
        var params = node.params;
        var body = node.body;
        var id = node.id;
        var gproto = Get(getIntrinsics(), INTRINSICS.GENERATORPROTOTYPE);
        var scope = getLexEnv();
        var strict = true;
        var closure;
        var isExpression = node.expression;
        var prototype;

        if (isExpression) {
            scope = NewDeclarativeEnvironment(scope);
            closure = GeneratorFunctionCreate("generator", params, body, scope, strict);
            prototype = ObjectCreate(gproto);
            MakeConstructor(closure, true, prototype);
            if (id) {
                scope.CreateMutableBinding(id);
                scope.InitializeBinding(id, closure);
                SetFunctionName(closure, id);
            }
            return closure;
        } else {
            return NormalCompletion(empty);
        }
    }
    evaluation.ArrowExpression = ArrowExpression;
    function ArrowExpression(node) {
        "use strict";
        var F;
        var scope = getLexEnv();
        var body = node.body;
        var params = node.params;
        var strict = true;
        F = FunctionCreate("arrow", params, body, scope, strict);
        setInternalSlot(F, SLOTS.THISMODE,  "lexical");
        //MakeConstructor(F);
        return NormalCompletion(F);
    }
    evaluation.FunctionExpression = FunctionDeclaration;
    evaluation.FunctionDeclaration = FunctionDeclaration;
    function FunctionDeclaration(node) {
        "use strict";
        var F;
        var id = node.id;
        var expr = node.expression;
        var params = node.params;
        var body = node.body;
        var scope;
        var strict = getContext().strict || node.strict;
        if (expr) {
            if (id) {
                scope = NewDeclarativeEnvironment(getLexEnv());
                status = scope.CreateMutableBinding(id);
                if (isAbrupt(status)) return status;
            } else scope = getLexEnv();
            F = FunctionCreate("normal", params, body, scope, strict);
            if (node.needsSuper) MakeMethod(F, id, undefined);
            MakeConstructor(F);
            if (id) {
                var status;
                status = SetFunctionName(F, id);
                if (isAbrupt(status)) return status;
                status = scope.InitializeBinding(id, F);
                if (isAbrupt(status)) return status;
            }
            return NormalCompletion(F);
        }
        return NormalCompletion(empty);
    }
    function isSuperMemberExpression (node) {
        return node.object.type === "SuperExpression";
    }
    evaluation.MemberExpression = MemberExpression;
    function MemberExpression(node) {
        "use strict";
        var notSuperExpr = !isSuperMemberExpression(node);
        var propertyNameReference;
        var propertyNameValue;
        var propertyNameString;
        var baseReference;
        var baseValue;
        var o = node.object;
        var p = node.property;
        var cx = getContext();
        var strict = cx.strict;
        if (notSuperExpr) {
            baseReference = Evaluate(o);
            baseValue = GetValue(baseReference);
            if (isAbrupt(baseValue = ifAbrupt(baseValue))) return baseValue;
        }
        if (node.computed) {
            propertyNameReference = Evaluate(p);
            if (isAbrupt(propertyNameReference = ifAbrupt(propertyNameReference))) return propertyNameReference;
            propertyNameValue = GetValue(propertyNameReference);
            if (isAbrupt(propertyNameValue = ifAbrupt(propertyNameValue))) return propertyNameValue;
        } else {
            propertyNameValue = p.name || p.value;
        }
        propertyNameString = ToPropertyKey(propertyNameValue);
        if (notSuperExpr) {
            // object.name
            // object[nameExpr]
            var bv = CheckObjectCoercible(baseValue);
            if (isAbrupt(bv = ifAbrupt(bv))) return bv;
            var ref = Reference(propertyNameString, bv, strict);
            return ref;
        } else {
            // super.name
            // super[nameExpr]
            return MakeSuperReference(propertyNameString, strict);
        }
    }
    evaluation.NewExpression = NewExpression;
    function isSuperCallExpression(node) {
        return node.callee.type === "SuperExpression";
    }
    function NewExpression(node) {
        "use strict";
        var exprRef;
        var O, callee;
        var cx = getContext();
        var strict = cx.strict;
        var notSuperExpr = !isSuperCallExpression(node);
        if (notSuperExpr) {
            exprRef = Evaluate(node.callee);
            if (isAbrupt(exprRef = ifAbrupt(exprRef))) return exprRef;
            callee = GetValue(exprRef);
        } else {
            exprRef = MakeSuperReference(undefined, strict);
            if (isAbrupt(exprRef = ifAbrupt(exprRef))) return exprRef;
            callee = GetValue(exprRef);
        }
        if (isAbrupt(callee = ifAbrupt(callee))) return callee;
        if (!IsConstructor(callee)) return newTypeError( "expected function is not a constructor");
        if (callee) cx.callee = "new " + (Get(callee, "name") || "(anonymous)");
        var args = node.arguments;
        var argList;
        if (args) argList = ArgumentListEvaluation(args);
        else argList = [];
        return callInternalSlot(SLOTS.CONSTRUCT, callee, argList);
    }
    evaluation.CallExpression = CallExpression;
    function CallExpression(node) {
        "use strict";
        var callee = node.callee;
        var notSuperExpr = !isSuperCallExpression(node);
        var strict = getContext().strict;
        var tailCall = !! node.tailCall;
        var exprRef;
        if (notSuperExpr) {
            exprRef = Evaluate(callee);
            if (isAbrupt(exprRef = ifAbrupt(exprRef))) return exprRef;
            return EvaluateCall(exprRef, node.arguments, tailCall);
        } else {
            exprRef = MakeSuperReference(undefined, strict);
            if (isAbrupt(exprRef = ifAbrupt(exprRef))) return exprRef;
            return EvaluateCall(exprRef, node.arguments, tailCall);
        }
    }
    evaluation.LexicalDeclaration = VariableDeclaration;
    evaluation.VariableDeclaration = VariableDeclaration;
    function VariableDeclaration(node) {
        "use strict";
        var decl, decl2, init, arr, initializer, status;
        var env = (node.type === "VariableDeclaration") ? (node.kind === "var" ? getVarEnv() : getLexEnv()) : getLexEnv();
        var i, j, p, q, type;
        var name;
        var cx = getContext();
        var strict = cx.strict;
        for (i = 0, j = node.declarations.length; i < j; i++) {
            decl = node.declarations[i];
            type = decl.type;
            if (IsBindingPattern[type]) {
                if (decl.init) initializer = GetValue(Evaluate(decl.init));
                else return newTypeError( "Destructuring Patterns must have some = Initializer.");
                if (isAbrupt(initializer=ifAbrupt(initializer))) return initializer;
                status = BindingInitialization(decl, initializer, env);
                if (isAbrupt(status = ifAbrupt(status))) return status;
            } else {
                if (decl.init) {
                    name = decl.id.name;
                    initializer = GetValue(Evaluate(decl.init));
                    if (isAbrupt(initializer=ifAbrupt(initializer))) return initializer;
                    if (IsCallable(initializer)) {
                        if (!HasOwnProperty(initializer, "name")) {
                            SetFunctionName(initializer, name);
                        }
                    }
                    status = BindingInitialization(name, initializer, env);
                    if (isAbrupt(status = ifAbrupt(status))) return status;
                }
            }
        }
        return NormalCompletion();
    }
    function KeyedBindingInitialization(decl, obj, env) {
        "use strict";
        var elem;
        var val;
        var status;
        var cx = getContext();
        var identName, newName, init, target;
        if (decl.type === "ObjectPattern" || decl.type === "ObjectExpression") {
            var elems = decl.elements||decl.properties;
            for (var p = 0, q = elems.length; p < q; p++) {
                if (elem = elems[p]) {
                    var type = elem.type;
                    if (elem.type == "Identifier") {
                        identName = elem.name || elem.value;
                    } else if (elem.target && IsBindingPattern[as.type]) {
                        identName = elem.id.name;
                        target = elem.target;
                    }
                    if (elem.init) {
                        var initializer = GetValue(Evaluate(elem.init));
                        if (isAbrupt(initializer = ifAbrupt(initializer))) return initializer;
                    }
                    obj = ToObject(obj);
                    if (isAbrupt(obj=ifAbrupt(obj))) return obj;
                    var val = Get(obj, ToString(identName));
                    val = ifAbrupt(val);
                    if (isAbrupt(val)) return val;
                    if (val === undefined && initializer != undefined) {
                        val = initializer;
                    }
                    if (target) {
                        status = KeyedBindingInitialization(target, val, env);
                        if (isAbrupt(status)) return status;
                    } else {
                        status = InitializeBoundName(identName, val, env);
                        if (isAbrupt(status)) return status;
                    }
                    target = undefined;
                }
            }
        }
        return NormalCompletion();
    }
    evaluation.BindingElement = BindingElement;
    function BindingElement (node) {
        if (node.target) {
            return ResolveBinding(node.target);
        } else {
            return Identifier(node);
        }
    }
    function IteratorBindingInitialization() {

    }
    function IndexedBindingInitialization(decl, nextIndex, value, env) {
        "use strict";
        var len = Get(value, "length");
        var elem;
        var index = 0;
        var ref;
        var val;
        var identName, newName;
        var cx = getContext();
        if ((decl && decl.type === "ArrayPattern") /*||
         /* (decl && decl.type === "ArrayExpression")*/) {
            for (var i = 0, j = decl.elements.length; i < j; i++) {
                if (elem = decl.elements[i]) {
                    if (elem.id) {
                        identName = elem.id.name;
                        newName = elem.target.name;
                    } else {
                        identName = elem.name || elem.value;
                        newName = undefined;
                    }
                    /* default initializer */
                    if (elem.init) {
                        var initializer = GetValue(Evaluate(elem.init));
                        if (isAbrupt(initializer = ifAbrupt(initializer))) return initializer;
                    }
                    val = Get(value, ToString(i));
                    val = ifAbrupt(val);
                    if (isAbrupt(val)) return val;
                    if (val === undefined && initializer != undefined) {
                        val = initializer;
                    }
                    // nextIndex = nextIndex + 1
                    if (env !== undefined) {
                        if (newName) env.InitializeBinding(newName, val);
                        else env.InitializeBinding(identName, val);
                    } else {
                        var lref = Evaluate(elem);
                        if (isAbrupt(lref = ifAbrupt(lref))) return lref;
                        PutValue(lref, val);
                    }
                }
            }
        } else if (decl && decl.type === "RestParameter") {
            var array = ArrayCreate(len - nextIndex);
            var name = decl.id;
            for (var i = nextIndex; i < len; i++) {
                elem = value.Get(ToString(i), value);
                if (isAbrupt(elem = ifAbrupt(elem))) return elem;
                array.DefineOwnProperty(ToString(index), {
                    value: elem,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
                index = index + 1;
            }
            if (env !== undefined) {
                env.InitializeBinding(name, array);
            } else {
                var lref = Reference(name, getLexEnv(), getContext().strict);
                if (isAbrupt(lref = ifAbrupt(lref))) return lref;
                PutValue(lref, array);
            }
        }
        return len;
    }
    function getStrict() {
        return getContext().strict;
    }
    function InitializeBoundName(name, value, environment) {
        Assert(Type(name) === STRING, "InitializeBoundName: name has to be a string");
        if (environment != undefined) {
            environment.InitializeBinding(name, value, getStrict());
            return NormalCompletion(undefined);
        } else {
            var lhs = ResolveBinding(name);
            return PutValue(lhs, value);
        }
    }
    function BindingInitialization(node, value, env) {
        "use strict";
        var names, name, val, got, len, ex, decl, lhs, strict, type, identName;
        var cx = getContext();
        if (!node) return;
        if (Array.isArray(node)) { // F.FormalParameters: formals ist ein Array
            for (var i = 0, j = node.length; i < j; i++) {
                decl = node[i];
                type = decl.type;
                if (type === "ObjectPattern") {
                    ex = KeyedBindingInitialization(decl, Get(value, ToString(i)), env);
                    if (isAbrupt(ex)) return ex;
                } else if (type === "ArrayPattern") {
                    ex = IndexedBindingInitialization(decl, undefined, Get(value, ToString(i)), env);
                    if (isAbrupt(ex)) return ex;
                } else if (type === "RestParameter") {
                    ex = IndexedBindingInitialization(decl, i, value, env);
                    if (isAbrupt(ex)) return ex;
                } else {
                    ex = BindingInitialization(decl, Get(value, ToString(i)), env);
                    if (isAbrupt(ex)) return ex;
                }
            }
            return NormalCompletion(undefined);
        }
        type = node.type;
        strict = !! cx.strict;
        if (type === "ForDeclaration") {
            return BindingInitialization(node.id, value, env);
        }
        if (type === "DefaultParameter") {
            name = node.id;
            if (value === undefined) value = GetValue(Evaluate(node.init));
            if (env !== undefined) env.InitializeBinding(name, value, strict);
            else {
                lhs = ResolveBinding(name);
                PutValue(lhs, value);
            }
            return NormalCompletion(undefined);
        }
        if (type === "Identifier") {
            name = node.name;
            if (env !== undefined) {
                ex = env.InitializeBinding(name, value, strict);
                if (isAbrupt(ex)) return ex;
                return NormalCompletion(undefined);
            } else {
                lhs = ResolveBinding(name);
                ex = PutValue(lhs, value);
                if (isAbrupt(ex)) return ex;
                return NormalCompletion(undefined);
            }
        } else if (type === "ArrayPattern") {
            var decl;
            /* coerce to object addition */
            value = ToObject(value);
            if (isAbrupt(value = ifAbrupt(value))) return value;
            /* ...is invalid */
            for (var p = 0, q = node.elements.length; p < q; p++) {
                if (decl = node.elements[p]) {
                    if (decl.type === "RestParameter") {
                        return IndexedBindingInitialization(decl, p, value, env);
                    } else {
                        if (decl.init) {
                            var initializer = GetValue(Evaluate(decl.init));
                            if (isAbrupt(initializer = ifAbrupt(initializer))) return initializer;
                        }
                        if (env) {
                            if (decl.id) { // is not an identifier, is a "BindingElement"
                                val = Get(value, decl.id.name, value);
                                if (isAbrupt(val = ifAbrupt(val))) return val;
                                if (val == undefined && initializer != undefined) val = initializer;
                                env.InitializeBinding(decl.target.name, val);
                            } else {    // is not a bindingelement, is an "Identifier"
                                val =  Get(value, ToString(p), value);
                                if (isAbrupt(val = ifAbrupt(val))) return val;
                                if (val == undefined && initializer != undefined) val = initializer;
                                env.InitializeBinding(decl.name, val);
                            }
                        } else {
                            if (decl.id) { // BindingElement has el.id and el.target
                                lhs = Evaluate(decl.id);
                                val = Get(value, decl.id.name);
                                if (isAbrupt(val = ifAbrupt(val))) return val;
                                if (val == undefined && initializer != undefined) val = initializer;
                                PutValue(lhs, val);
                            } else { // Identifier has el.name
                                lhs = Evaluate(decl.name);
                                val = Get(value, ToString(p));
                                if (isAbrupt(val = ifAbrupt(val))) return val;
                                if (val == undefined && initializer != undefined) val = initializer;
                                PutValue(lhs, val);
                            }
                        }
                    }
                }
            }
            return NormalCompletion(undefined);
        } else if (type === "ObjectPattern") {
            var decl;

            /* coerce to object addition */
            value = ToObject(value);
            if (isAbrupt(value = ifAbrupt(value))) return value;


            for (var p = 0, q = node.elements.length; p < q; p++) {
                if (decl = node.elements[p]) {
                    if (decl.init) {
                        var initializer = GetValue(Evaluate(decl.init));
                        if (isAbrupt(initializer = ifAbrupt(initializer))) return initializer;
                    }



                    if (env) {


                        if (decl.id) {
                            val =  Get(value, decl.id.name, value);
                            if (isAbrupt(val=ifAbrupt(val))) return val;
                            if (val === undefined && initializer != undefined) val = initializer;

                            env.InitializeBinding(decl.target.name, val);

                        } else if (decl.type === "Identifier") {
                            val = Get(value, decl.name, value);
                            if (isAbrupt(val=ifAbrupt(val))) return val;
                            if (val === undefined && initializer != undefined) val = initializer;
                            env.InitializeBinding(decl.name, val);
                        } else  {

                        }

                    } else {
                        if (decl.id) {
                            lhs = Evaluate(decl.id);
                            val = Get(value, decl.id.name);
                            if (isAbrupt(val=ifAbrupt(val))) return val;
                            if (val === undefined && initializer != undefined) val = initializer;
                            PutValue(lhs, val);
                        } else if (decl.type === "Identifier") {
                            lhs = Evaluate(decl.name);
                            val =  Get(value, decl.name);
                            if (isAbrupt(val=ifAbrupt(val))) return val;
                            if (val === undefined && initializer != undefined) val = initializer;
                            PutValue(lhs, val);
                        }


                    }
                }
            }
            return NormalCompletion(undefined);

        } else if (typeof node === "string") {
            return InitializeBoundName(node, value, env);
        }
        return NormalCompletion(undefined);
    }
    function EmptyStatement(node) {
        return NormalCompletion(empty);
    }
    
    
    ecma.debuggerOutput = debuggerOutput;
    function debuggerOutput() {
        banner("stack");
        if (hasConsole) console.dir(getStack());
        else if (hasPrint) print(getStack());
        banner("varenv");
        if (hasConsole) console.dir(getVarEnv());
        else if (hasPrint) print(getVarEnv());
        banner("lexenv");
        if (hasConsole) console.dir(getLexEnv());
        else if (hasPrint) print(getLexEnv());
        banner("realm");
        if (hasConsole) console.dir(getRealm());
        else if (hasPrint) print(getRealm());
    }
    
    evaluation.EmptyStatement = EmptyStatement;
    function DebuggerStatement(node) {
        var loc = node.loc;
        var line = loc && loc.start ? loc.start.line : "bug";
        var column = loc && loc.start ? loc.start.column : "bug";
        banner("DebuggerStatement at line " + (line) + ", " + (column) + "\n");
	debuggerOutput();
        banner("DebuggerStatement end");
        return NormalCompletion(undefined);
    }
    evaluation.DebuggerStatement = DebuggerStatement;
    function RegularExpressionLiteral(node) {
        var source = node.value;
        var flags = node.flags;
        return RegExpCreate(source, flags);
    }
    evaluation.RegularExpressionLiteral = RegularExpressionLiteral;
    evaluation.StringLiteral = StringLiteral;
    function StringLiteral(node) {
        return node.computed || unquote(node.value);
    }
    evaluation.NumericLiteral = NumericLiteral;
    function NumericLiteral(node) {
        if (node.computed) return MV(node.computed);
        return MV(node.value);
        // return +node.value;
    }
    evaluation.NullLiteral = NullLiteral;
    function NullLiteral(node) {
        return null;
    }
    evaluation.BooleanLiteral = BooleanLiteral;
    function BooleanLiteral(node) {
        return node.value === "true";
    }
    evaluation.Literal = Literal;
    function Literal(node) {
        return node.value;
    }
    evaluation.ThisExpression = ThisExpression;
    function ThisExpression(node) {
        return ThisResolution();
    }
    evaluation.Identifier = Identifier;
    function Identifier(node) {
        var name = node.name || node.value;
        var lex = getLexEnv();
        var cx = getContext();
        var strict = cx.strict;
        return GetIdentifierReference(lex, name, strict);
    }
    evaluation.Elision = Elision;
    function Elision(node) {
        return node.width;
    }
    function ArrayAccumulation(elementList, array, nextIndex) {
        "use strict";
        var exprRef;
        var exprValue;
        var i, j = elementList.length;
        var element;
        for (i = 0; i < j; i++) {
            element = elementList[i];
            if (element.type === "Elision") {
                nextIndex += element.width;
            } else if (element.type === "SpreadExpression") {
                var spreadRef = Evaluate(element);
                var spreadObj = GetValue(spreadRef);
                if (isAbrupt(spreadObj=ifAbrupt(spreadObj))) return spreadObj;
                var spreadLen = Get(spreadObj, "length");
                if (isAbrupt(spreadLen=ifAbrupt(spreadLen))) return spreadLen;
                for (var k = 0; k < spreadLen; k++) {
                    exprValue = Get(spreadObj, ToString(k));
                    if (isAbrupt(exprValue = ifAbrupt(exprValue))) return exprValue;
                    callInternalSlot(SLOTS.DEFINEOWNPROPERTY, array, ToString(nextIndex), {
                        writable: true,
                        value: exprValue,
                        enumerable: true,
                        configurable: true
                    });
                    nextIndex = nextIndex + 1;
                }
            } else {
                exprRef = Evaluate(element);
                if (isAbrupt(exprRef = ifAbrupt(exprRef))) return exprRef;
                exprValue = GetValue(exprRef);
                if (isAbrupt(exprValue = ifAbrupt(exprValue))) return exprValue;
                callInternalSlot(SLOTS.DEFINEOWNPROPERTY, array, ToString(nextIndex), {
                    writable: true,
                    value: exprValue,
                    enumerable: true,
                    configurable: true
                });
                nextIndex = nextIndex + 1;
            }
        }
        return nextIndex;
    }
    evaluation.ArrayExpression = ArrayExpression;
    function ArrayExpression(node) {
        var j = node.elements.length;
        var array, pad, nextIndex;
        var element;
        if (j === 1) {
            element = node.elements[0];
            if (element.type === "Elision") {
                array = ArrayCreate(0);
                pad = element.width;
                ArraySetLength(array,{
                    value: pad,
                    writable: true,
                    enumerable: false,
                    configurable: false
                });
                return array;
            }
        }
        array = ArrayCreate(0);
        nextIndex = 0;
        nextIndex = ArrayAccumulation(node.elements, array, nextIndex);
        if (isAbrupt(nextIndex = ifAbrupt(nextIndex))) return nextIndex;
        ArraySetLength(array, {
            value: nextIndex,
            writable: true,
            enumerable: false,
            configurable: false
        });
        return NormalCompletion(array);
    }
    evaluation.PropertyDefinition = PropertyDefinition;
    function PropertyDefinition(newObj, propertyDefinition) {
        "use strict";
        var kind = propertyDefinition.kind;
        var key =  propertyDefinition.key;
        var node = propertyDefinition.value;
        var computed = propertyDefinition.computed;
        var status;
        var strict = node.strict;
        var propRef, propName, propValue;
        /* I refactored it today, but resetted it tonight, i rewrite it tomorrow */
        // TOMORROW ? (FOUR DAYS AGO)
        if (kind == "init") {
            // prop key
            if (computed) {
                var symRef = Evaluate(key);
                var symValue = GetValue(symRef);
                if (isAbrupt(symValue = ifAbrupt(symValue))) return symValue;
                if (!IsSymbol(symValue)) symValue = ToString(symValue);
                if (isAbrupt(symValue = ifAbrupt(symValue))) return symValue;
                if (!IsPropertyKey(symValue)) return newTypeError( "A [computed] property inside an object literal has to evaluate to a Symbol primitive");
                propName = symValue;
            } else {
                // init
                propName = ToString(PropName(key));
                if (isAbrupt(propName=ifAbrupt(propName))) return propName;
            }
            // value
            if (node.type === "FunctionDeclaration") {
                status = defineFunctionOnObject(node, newObj, propName);
                if (isAbrupt(status)) return status;
            } else {
                propRef = Evaluate(node, newObj);
                if (isAbrupt(propRef = ifAbrupt(propRef))) return propRef;
                propValue = GetValue(propRef);
                if (isAbrupt(propValue = ifAbrupt(propValue))) return propValue;
                // B 3.
                // DOESNT WORK
                if (!computed && (propName === "__proto__")) {
                    if (Type(propValue) === OBJECT || propValue === null) {
                        return callInternalSlot(SLOTS.SETPROTOTYPEOF, newObj, propValue);
                    }
                    return NormalCompletion(empty);
                }
                // FOR NOW
                status = CreateDataProperty(newObj, propName, propValue);
                if (isAbrupt(status)) return status;
            }
        } else if (kind === "method") {
            propValue = Evaluate(node, newObj);
            if (isAbrupt(propValue = ifAbrupt(propValue))) return propValue;
        } else if (kind === "get" || kind === "set") {
            // get [s] () { return 10 }
            if (node.computed) {
                propName = GetValue(Evaluate(key));
                if (isAbrupt(propName = ifAbrupt(propName))) return propName;
                if (!IsSymbol(propName)) propName = ToString(propName);
                if (isAbrupt(propName = ifAbrupt(propName))) return propName;
                if (!IsPropertyKey(propName)) return newTypeError( "A [computed] property has to evaluate to valid property key");
            } else {
                propName = typeof key === "string" ? key : key.name || key.value;
            }
            defineGetterOrSetterOnObject(node, newObj, propName, kind);
        }
    }
    function defineFunctionOnObject (node, newObj, propName) {
        "use strict";
        var cx = getContext();
        var scope = getLexEnv();
        var body = node.body;
        var formals = node.params;
        var strict = cx.strict || node.strict;
        var fproto = Get(getIntrinsics(), INTRINSICS.FUNCTIONPROTOTYPE);
        var id = node.id;
        var generator = node.generator;
        var propValue;
        var methodName = propName;
        if (id) {
            scope = NewDeclarativeEnvironment(scope);
            scope.CreateMutableBinding(id);
        }
        if (ReferencesSuper(node)) {
            var home = getLexEnv().GetSuperBase();
            //getInternalSlot(object, SLOTS.HOMEOBJECT);
        } else {
            methodName = undefined;
            home = undefined;
        }
        if (generator) propValue = GeneratorFunctionCreate("method", formals, body, scope, strict, fproto, home, methodName);
        else propValue = FunctionCreate("method", formals, body, scope, strict, fproto, home, methodName);
        if (id) scope.InitializeBinding(id, propValue);
        MakeConstructor(propValue);
        SetFunctionName(propValue, propName);
        CreateDataProperty(newObj, propName, propValue);
    }
    function defineGetterOrSetterOnObject (node, newObj, propName, kind) {
        var scope = getLexEnv();
        var body = node.body;
        var formals = node.params;
        var functionPrototype = getIntrinsic(INTRINSICS.FUNCTIONPROTOTYPE);
        var strict = node.strict;
        var methodName;
        var propValue;
        var status;
        if (ReferencesSuper(node)) {
            var home = getLexEnv().GetSuperBase();
            methodName = propName;
        } else {
            home = undefined;
            methodName = undefined
        }
        //getInternalSlot(object, SLOTS.HOMEOBJECT);
        propValue = FunctionCreate("method", formals, body, scope, strict, functionPrototype, home, methodName);
        var desc = kind == "get" ? {
            get: propValue,
            enumerable: true,
            configurable: true
        } : {
            set: propValue,
            enumerable: true,
            configurable: true
        };
        SetFunctionName(propValue, propName, kind);
        status = DefineOwnPropertyOrThrow(newObj, propName, desc);
        if (isAbrupt(status)) return status;
    }
    evaluation.ObjectExpression = ObjectExpression;
    function ObjectExpression(node) {
        "use strict";
        var props = node.properties;
        var newObj = ObjectCreate();
        var status;
        for (var i = 0, j = props.length; i < j; i++) {
            status = PropertyDefinition(newObj, props[i]);
            if (isAbrupt(status)) return status;
        }
        return NormalCompletion(newObj);
    }
    evaluation.AssignmentExpression = AssignmentExpression;
    evaluation.ObjectPattern = ObjectPattern;
    function ObjectPattern(node) {
        var rref = Evaluate(node.init);
        var rval = GetValue(rref);
        if (isAbrupt(rval=ifAbrupt(rval))) return rval;
        return DestructuringAssignmentEvaluation(node, rval, "=");
    }
    function IteratorDestructuringEvaluation() {}
    function DestructuringAssignmentEvaluation(left, rval, op) {
	var type = left.type;
        if (type === "ObjectPattern") {
            return ObjectPatternDestructuring(left, rval, op);
        } else if (type === "ArrayPattern") {
            return ArrayPatternDestructuring(left, rval, op);
        }
    }
    function ObjectPatternDestructuring(left, rval, op) {
        "use strict";
        var leftElems = left.elements;
        var type = left.type;
        var lval;
        var lref;
        var result;
        var l, i, j;
        var obj;
        var status;
        obj = rval;
        var identName, newName;
        if (Type(rval) !== OBJECT) return newTypeError( "can not desctructure a non-object into some object");
        for (i = 0, j = leftElems.length; i < j; i++) {
            var lel = leftElems[i];
            if (lel.id) identName = lel.id.name;
            else identName = lel.name;
            lval = GetValue(Evaluate(lel));
            rval = Get(obj, identName);
            result = applyAssignmentBinOp(op, lval, rval);
            var target;
            if (lel.target) {
                if (IsBindingPattern[lel.target.type]) {
                    //consoleLog("BINDINGPATTERN")
                    status = DestructuringAssignmentEvaluation(lel.target, result, op);
                    if (isAbrupt(status)) return status;
                } else {
                    //consoleLog("TARGET")
                    target = Evaluate(lel.target);
                    if (isAbrupt(target)) return target;
                    PutValue(target, result);
                }
            } else {
                getLexEnv().SetMutableBinding(identName, result);
            }
            target = undefined;
        }
        return NormalCompletion(result);
    }
    function ArrayPatternDestructuring (left, rval, op) {
        "use strict";
        var leftElems = left.elements;
        var type = left.type;
        var lval;
        var result;
        var l, i, j;
        var status;
        var array;
        array = rval;
        if (Type(rval) !== OBJECT) return newTypeError( "can not desctructure a non-object into some object");
        var index = 0;
        var len = Get(rval, "length");
        var status;
        for (i = 0, j = leftElems.length; i < j; i++) {
            var lel = leftElems[i];
            var ltype = lel.type;
            if (ltype === "SpreadExpression") {
                var rest = ArrayCreate(0);
                var restName = BoundNames(lel.argument)[0];
                var index2 = 0;
                while (index < len) {
                    lval = Get(array, ToString(index));
                    result = applyAssignmentBinOp(op, lval, rval);
                    status = callInternalSlot(SLOTS.DEFINEOWNPROPERTY, rest, ToString(index2), {
                        value: result,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                    if (isAbrupt(status)) return status;
                    index += 1;
                    index2 += 1;
                }
                getLexEnv().SetMutableBinding(restName, rest);
                break;
            } else if (ltype === "Elision") {
                index += node.width - 1;
                result = undefined;
            } else {
                l = lel.value || lel.name;
                rval = Get(array, ToString(index));
                if (isAbrupt(rval = ifAbrupt(rval))) return rval;
                lval = GetValue(Evaluate(lel));
                if (isAbrupt(lval = ifAbrupt(lval))) return lval;
                result = applyAssignmentBinOp(op, lval, rval);
                status = getLexEnv().SetMutableBinding(l, result);
                if (isAbrupt(status)) return status;
                index = index + 1;
            }
        }
        return NormalCompletion(result);
    }

    function AssignmentExpression(node) {
        var lref, rref;
        var lval, rval;
        var op = node.operator;
        var result, status;
        var ltype = node.left.type;
        if (ltype === "Identifier") {
            lref = Evaluate(node.left);
            rref = Evaluate(node.right);
            if (isAbrupt(lref = ifAbrupt(lref))) return lref;
            if (isAbrupt(rref = ifAbrupt(rref))) return rref;
            lval = GetValue(lref);
            rval = GetValue(rref);
            if (isAbrupt(lval = ifAbrupt(lval))) return lval;
            if (isAbrupt(rval = ifAbrupt(rval))) return rval;
            result = applyAssignmentBinOp(op, lval, rval);
            status = PutValue(lref, result);
            if (isAbrupt(status)) return status;
        } else if (ltype === "MemberExpression") {
            lref = Evaluate(node.left);
            if (isAbrupt(lref = ifAbrupt(lref))) return lref;
            rref = Evaluate(node.right);
            if (isAbrupt(rref = ifAbrupt(rref))) return rref;
            lval = GetValue(lref);
            rval = GetValue(rref);
            if (isAbrupt(lval = ifAbrupt(lval))) return lval;
            if (isAbrupt(rval = ifAbrupt(rval))) return rval;
            result = applyAssignmentBinOp(op, lval, rval);
            status = Put(lref.base, lref.name, result, false);
            if (isAbrupt(status)) return status;
        } else if (isValidSimpleAssignmentTarget[ltype]) {
            rref = Evaluate(node.right);
            if (isAbrupt(rref = ifAbrupt(rref))) return rref;
            rval = GetValue(rref);
            if (isAbrupt(rval = ifAbrupt(rval))) return rval;
            return DestructuringAssignmentEvaluation(node.left, rval, node.operator);
        } else {
            return newReferenceError("Currently not a valid lefthandside expression for assignment")
        }
        return NormalCompletion(result);
    }
    evaluation.ConditionalExpression = ConditionalExpression;

    ecma.applyAssignmentBinOp = applyAssignmentBinOp;
    function applyAssignmentBinOp(op, lval, rval) {
        switch (op) {
            case "=": return rval;
            case "+=": return lval + rval;
            case "%=": return lval % rval;
            case "/=": return lval / rval;
            case "*=": return lval * rval;
            case "-=": return lval - rval;
            case "^=": return lval ^ rval;
            case "|=": return lval | rval;
            case "&=": return lval & rval;
            case ">>>=": return lval >>> rval;
        }
    }


    /*
        auf den stack
        1. test, consequent, alternate, dann ce expr
        (4 * auf den stack)

        wenn die expr dran ist,
        poppt sie die anderen 3 nodes runter

     */

    function ConditionalExpression(node) {  // (node) entfaellt

        var testExpr = node.test;
        var trueExpr = node.consequent;
        var falseExpr = node.alternate;
        /*
            var cx = getContext();

            testExpr = cx.stack.pop();
            trueExpr = cx.stack.pop();
            falseExpr = cx.stack.pop();


         */

        var exprRef = Evaluate(testExpr);
        var exprValue = GetValue(exprRef);
        if (isAbrupt(exprValue)) return exprValue;
        if (exprValue) {
            var trueRef = Evaluate(trueExpr);
            if (isAbrupt(trueRef = ifAbrupt(trueRef))) return trueRef;
            var trueValue = GetValue(trueRef);
            if (isAbrupt(trueValue = ifAbrupt(trueValue))) return trueValue;
            return NormalCompletion(trueValue);
        } else {
            var falseRef = Evaluate(falseExpr);
            if (isAbrupt(falseRef = ifAbrupt(falseRef))) return falseRef;
            var falseValue = GetValue(falseRef);
            if (isAbrupt(falseValue = ifAbrupt(falseValue))) return falseValue;
            return NormalCompletion(falseValue);
        }
    }
    var lazyTypes = Object.create(null);
    lazyTypes[OBJECT] = "object";
    lazyTypes[NUMBER] = "number";
    lazyTypes[SYMBOL] = "symbol";
    lazyTypes[STRING] = "string";
    lazyTypes[NULL] = "null";
    lazyTypes[UNDEFINED] = "undefined";


    function UnaryExpression(node) {
        var isPrefixOperation = node.prefix;
        var op = node.operator;
        var argument = node.argument;
        var exprRef = Evaluate(argument);
        if (isAbrupt(exprRef = ifAbrupt(exprRef))) return exprRef;
        return applyUnaryOp(op, isPrefixOperation, exprRef);
    }

    ecma.applyUnaryOp = applyUnaryOp;
    function applyUnaryOp(op, isPrefixOperation, exprRef) {
        var oldValue, newValue, val, status;
        if (op === "typeof") {
            if (Type(exprRef) === REFERENCE) {
                if (IsUnresolvableReference(exprRef)) return NormalCompletion("undefined");
                val = GetValue(exprRef);
            } else val = exprRef;
            if (isAbrupt(val = ifAbrupt(val))) return val;
            var lazyTypeString = lazyTypes[Type(val)];
            if (IsCallable(val)) return NormalCompletion("function");
            if (val === null) return NormalCompletion("object");
            return NormalCompletion(lazyTypeString);
        } else if (op === "void") {
            oldValue = GetValue(exprRef);
            return NormalCompletion(undefined);
        } else if (op === "delete") {
            if (Type(exprRef) !== REFERENCE) return NormalCompletion(true);
            if (IsUnresolvableReference(exprRef)) {
                if (IsStrictReference(exprRef)) return newSyntaxError("Can not delete unresolvable and strict reference.");
                return NormalCompletion(true);
            }
            if (IsPropertyReference(exprRef)) {
                if (IsSuperReference(exprRef)) return newReferenceError("Can not delete a super reference.");
                var deleteStatus = Delete(ToObject(GetBase(exprRef), GetReferencedName(exprRef)));
                deleteStatus = ifAbrupt(deleteStatus);
                if (isAbrupt(deleteStatus)) return deleteStatus;
                if (deleteStatus === false && IsStrictReference(exprRef)) return newTypeError("deleteStatus is false and IsStrictReference is true.");
                return deleteStatus;
            } else {
                var bindings = GetBase(exprRef);
                return bindings.DeleteBinding(GetReferencedName(exprRef));
            }
        } else if (isPrefixOperation) {
            switch (op) {
                case "!!":
                    oldValue = GetValue(exprRef);
                    if (isAbrupt(oldValue)) return oldValue;
                    return NormalCompletion(ToBoolean(oldValue));
                case "~":
                    oldValue = ToNumber(GetValue(exprRef));
                    if (isAbrupt(oldValue)) return oldValue;
                    newValue = ~oldValue;
                    return NormalCompletion(newValue);
                case "!":
                    oldValue = ToBoolean(GetValue(exprRef));
                    if (isAbrupt(oldValue)) return oldValue;
                    newValue = !oldValue;
                    return NormalCompletion(newValue);
                case "+":
                    oldValue = GetValue(exprRef);
                    if (isAbrupt(oldValue)) return oldValue;
                    newValue = ToNumber(oldValue);
                    if (isAbrupt(newValue)) return newValue;
                    return NormalCompletion(newValue);
                    break;
                case "-":
                    oldValue = GetValue(exprRef);
                    newValue = ToNumber(oldValue);
                    if (isAbrupt(newValue)) return newValue;
                    return NormalCompletion(-newValue);
                    break;
                case "++":
                    oldValue = ToNumber(GetValue(exprRef));
                    if (isAbrupt(oldValue = ifAbrupt(oldValue))) return oldValue;
                    newValue = oldValue + 1;
                    status = PutValue(exprRef, newValue);
                    if (isAbrupt(status)) return status;
                    return NormalCompletion(newValue);
                    break;
                case "--":
                    oldValue = ToNumber(GetValue(exprRef));
                    if (isAbrupt(oldValue = ifAbrupt(oldValue))) return oldValue;
                    newValue = oldValue - 1;
                    status = PutValue(exprRef, newValue);
                    if (isAbrupt(status)) return status;
                    return NormalCompletion(newValue);
                    break;
            }
        } else {
            switch (op) {
                case "++":
                    oldValue = ToNumber(GetValue(exprRef));
                    if (isAbrupt(oldValue)) return oldValue;
                    oldValue = unwrap(oldValue);
                    newValue = oldValue + 1;
                    status = PutValue(exprRef, newValue);
                    if (isAbrupt(status)) return status;
                    return NormalCompletion(oldValue);
                case "--":
                    oldValue = ToNumber(GetValue(exprRef));
                    if (isAbrupt(oldValue)) return oldValue;
                    oldValue = unwrap(oldValue);
                    newValue = oldValue - 1;
                    status = PutValue(exprRef, newValue);
                    if (isAbrupt(status)) return status;
                    return NormalCompletion(oldValue);
                    break;
            }

        }
    }

    evaluation.UnaryExpression = UnaryExpression;
    evaluation.BinaryExpression = BinaryExpression;
    function instanceOfOperator(O, C) {
        if (Type(C) !== OBJECT) return newTypeError( "instanceOfOperator: C is not an object.");
        var instHandler = GetMethod(C, $$hasInstance);
        if (isAbrupt(instHandler)) return instHandler;
        if (instHandler) {
            if (!IsCallable(instHandler)) return newTypeError( "instanceOfOperator: [@@hasInstance] is expected to be a callable.");
            var result = instHandler.Call(C, [O]);
            return ToBoolean(result);
        }
        if (IsCallable(C) === false) return newTypeError( "instanceOfOperator: C ist not callable.");
        return OrdinaryHasInstance(C, O);
    }

    ecma.applyBinOp = applyBinOp;
    function applyBinOp(op, rval, lval) {
        switch (op) {
            case "in":
                return HasProperty(rval, ToPropertyKey(lval));
            case "<":
                return NormalCompletion(lval < rval);
            case ">":
                return NormalCompletion(lval > rval);
            case "<=":
                return NormalCompletion(lval <= rval);
            case ">=":
                return NormalCompletion(lval >= rval);
            case "+":
                return NormalCompletion(lval + rval);
            case "-":
                return NormalCompletion(lval - rval);
            case "*":
                return NormalCompletion(lval * rval);
            case "/":
                return NormalCompletion(lval / rval);
            case "^":
                return NormalCompletion(lval ^ rval);
            case "%":
                return NormalCompletion(lval % rval);
            case "===":
                return NormalCompletion(lval === rval);
            case "!==":
                return NormalCompletion(lval !== rval);
            case "==":
                return NormalCompletion(lval == rval);
            case "!=":
                return NormalCompletion(lval != rval);
            case "&&":
                return NormalCompletion(lval && rval);
            case "||":
                return NormalCompletion(lval || rval);
            case "|":
                return NormalCompletion(lval | rval);
            case "&":
                return NormalCompletion(lval & rval);
            case "<<":
                return NormalCompletion(lval << rval);
            case ">>":
                return NormalCompletion(lval >> rval);
            case ">>>":
                return NormalCompletion(lval >>> rval);
            case "instanceof":
                return NormalCompletion(instanceOfOperator(lval, rval));
        }
    }


    function BinaryExpression(node) {

        var op = node.operator;

        var lref = Evaluate(node.left);
        if (isAbrupt(lref = ifAbrupt(lref))) return lref;
        var rref = Evaluate(node.right);
        if (isAbrupt(rref = ifAbrupt(rref))) return rref;

        var lval = GetValue(lref);
        if (isAbrupt(lval = ifAbrupt(lval))) return lval;
        var rval = GetValue(rref);
        if (isAbrupt(rval = ifAbrupt(rval))) return rval;



        var result = applyBinOp(op, rval, lval)

        return NormalCompletion(result); // NormalCompletion(result);
    }
    evaluation.ExpressionStatement = ExpressionStatement;

    function ExpressionStatement(node) {
        return Evaluate(node.expression);
    }
    evaluation.ParenthesizedExpression = ParenthesizedExpression;
    function ParenthesizedExpression (node) {
        return Evaluate(node.expression);
    }

    evaluation.SequenceExpression = SequenceExpression;
    function SequenceExpression(node) {
        var exprRef, exprValue;
        var list = node.sequence;
        var V = undefined;
        var item;
        for (var i = 0, j = list.length; i < j; i += 1) {
            if (item = list[i]) {
                // tellExecutionContext(item, i, list);
                exprRef = Evaluate(item);
                if (isAbrupt(exprRef)) {
                    // untellExecutionContext();
                    return exprRef;
                }
                exprValue = GetValue(exprRef);
                if (isAbrupt(exprValue)) {
                    // untellExecutionContext();
                    return exprValue;
                }
                if (exprValue !== empty) V = exprValue;
            }
        }
        // untellExecutionContext();
        return NormalCompletion(V);
    }
    evaluation.FunctionStatementList = StatementList;
    evaluation.StatementList = StatementList;
    function StatementList(stmtList) {
        var stmtRef, stmtValue, stmt;

        var index = 0;

        var gen = getContext().generator;

        var V = undefined;
        for (var i = index, j = stmtList.length; i < j; i++) {
            if (stmt = stmtList[i]) {

                // tellExecutionContext(stmt, i, stmtList);
                stmtRef = Evaluate(stmt);
                stmtValue = GetValue(stmtRef);

                if (isAbrupt(stmtValue)) return stmtValue;
                if (stmtValue !== empty) V = stmtValue;
            }
        }
        return NormalCompletion(V);
    }
    evaluation.BlockStatement = BlockStatement;
    function BlockStatement(node) {
        var stmtList = node.body;

        var oldEnv = getLexEnv();
        var blockEnv = NewDeclarativeEnvironment(oldEnv);

        var status = InstantiateBlockDeclaration(stmtList, blockEnv);
        if (isAbrupt(status)) {
            return status;
        }

        getContext().LexEnv = blockEnv;
        status = evaluation.StatementList(stmtList);
        getContext().LexEnv = oldEnv;
        if (isAbrupt(status)) return status;
        return NormalCompletion(empty);

    }
    evaluation.IfStatement = IfStatement;
    function IfStatement(node) {
        var test = node.test;
        var ok = node.consequent;
        var not = node.alternate;
        var rval;
        if (not) {
            rval = GetValue(Evaluate(test)) ? GetValue(Evaluate(ok)) : GetValue(Evaluate(not));
        } else {
            if (GetValue(Evaluate(test))) rval = GetValue(Evaluate(ok));
        }
        return NormalCompletion();
    }
    function LoopContinues(completion, labelSet) {
        // -- inconsistency fix
        if (completion instanceof CompletionRecord === false) return true;
        // --- reg. code
        if (completion.type === "normal") return true;
        if (completion.type !== "continue") return false;
        if (completion.target === "" || completion.target === undefined) return true;
        return !!(labelSet && labelSet[completion.target]);

    }
    evaluation.WhileStatement = WhileStatement;
    function WhileStatement(node, labelSet) {

        var test = node.test;
        var body = node.body;
        var exprRef, exprValue;
        var V, stmt;
        labelSet = labelSet || Object.create(null);

        for (;;) {

            var testRef = Evaluate(test);


            if (isAbrupt(testRef = ifAbrupt(testRef))) return testRef;
            var testValue = GetValue(testRef);
            if (isAbrupt(testValue = ifAbrupt(testValue))) return testValue;
            if (ToBoolean(testValue) === false) {
                return NormalCompletion(V);
            }

            exprRef = Evaluate(body);


            exprValue = GetValue(exprRef);
            if (LoopContinues(exprValue, labelSet) === false) return exprValue;
            V = unwrap(exprValue);

        }

    }
    function DoWhileStatement(node, labelSet) {
        var test = node.test;
        var body = node.body;
        var exprRef, exprValue;
        var V, stmt;
        labelSet = labelSet || Object.create(null);

        for (;;) {

            exprRef = Evaluate(body);

            exprValue = GetValue(exprRef);
            if (LoopContinues(exprValue, labelSet) === false) return exprValue;
            V = unwrap(exprValue);

            var testRef = Evaluate(test);

            if (isAbrupt(testRef = ifAbrupt(testRef))) return testRef;
            var testValue = GetValue(testRef);
            if (isAbrupt(testValue = ifAbrupt(testValue))) return testValue;

            if (ToBoolean(testValue) === false) {
                return NormalCompletion(V);
            }
        }
    }
    evaluation.DoWhileStatement = DoWhileStatement;
    evaluation.ForDeclaration = ForDeclaration;
    function ForDeclaration(node) {
        var kind = node.kind;
        var id = node.id;
        return Evaluate(node.id);
    }

    function ForInOfExpressionEvaluation(expr, iterationKind, labelSet) {
        var exprRef = Evaluate(expr);
        var exprValue = GetValue(exprRef);
        var iterator, obj, keys;
        if (isAbrupt(exprValue = ifAbrupt(exprValue))) {
            if (LoopContinues(exprValue, labelSet) === false) return exprValue;
            else return Completion("break");
        }

        if (exprValue === null || exprValue === undefined) return Completion("break");
        obj = ToObject(exprValue);
        if (iterationKind === "enumerate") {

            keys = Enumerate(obj);

        } else if (iterationKind === "iterate") {

            iterator = Invoke(obj, $$iterator, []);
            keys = ToObject(iterator);

        } else if (iterationKind) {
            return newTypeError( "ForInOfExpression: iterationKind is neither enumerate nor iterate.");
        }

        if (isAbrupt(keys)) {
            if (keys.type === "throw") return keys;
            if (LoopContinues(exprValue, labelSet) === false) return exprValue;
            Assert(keys.type === "continue", "invalid completion value: "+keys.type);
            return Completion("break");
        }
        return keys;

    }
    function ForInOfBodyEvaluation(lhs, stmt, keys, lhsKind, labelSet) {
        "use strict";
        var oldEnv = getLexEnv();
        var noArgs = [];
        var V;
        var nextResult, nextValue, done, status;
        var rval, lhsRef;
        var names = BoundNames(lhs);

        for (;;) {
            nextResult = Invoke(keys, "next", noArgs);
            if (isAbrupt(nextResult = ifAbrupt(nextResult))) return nextResult;
            if (Type(nextResult) !== OBJECT) return newTypeError( "ForInOfBodyEvaluation: nextResult is not an object");
            done = IteratorComplete(nextResult);
            if (isAbrupt(done = ifAbrupt(done))) return done;
            if (done === true) return NormalCompletion(V);
            nextValue = IteratorValue(nextResult);
            if (isAbrupt(nextValue = ifAbrupt(nextValue))) return nextValue;
            if (lhsKind === "assignment") {

                if (!IsBindingPattern[lhs.type]) {
                    lhsRef = Evaluate(lhs);
                    status = PutValue(lhsRef, nextValue);
                } else {
                    rval = ToObject(nextValue);
                    if (isAbrupt(rval)) status = rval;
                    else status = DestructuringAssignmentEvaluation(lhs, rval);
                }

            } else if (lhsKind === "varBinding") {
                status = BindingInitialization(lhs, nextValue, undefined);
            } else {
                Assert(lhsKind === "lexicalBinding", "lhsKind has to be a lexical Binding");
                // Assert(lhs == ForDeclaration);
                var iterationEnv = NewDeclarativeEnvironment(oldEnv);
                for (var i = 0, j = names.length; i < j; i++) {
                    iterationEnv.CreateMutableBinding(names[i], true);
                }
                getContext().LexEnv = iterationEnv;
                status = BindingInitialization(lhs, nextValue, iterationEnv);
                if (isAbrupt(status)) {
                    getContext().LexEnv = oldEnv;
                    return status;
                }
                status = NormalCompletion(undefined);

            }

            if (!isAbrupt(status)) {
                status = Evaluate(stmt);
                if (status instanceof CompletionRecord) {
                    if (status.type === "normal" && status.value !== empty) V = status.value;
                }
            }

            getContext().LexEnv = oldEnv;
            if (isAbrupt(status) && LoopContinues(status, labelSet) === false) return status;
        }
    }
    function ForInStatement(node, labelSet) {
        var left = node.left;
        var right = node.right;
        var body = node.body;
        var tleft = left.type;
        var tright = right.type;


        labelSet = labelSet || Object.create(null);
        var lhsKind = "assignment";
        var iterationKind = "enumerate";

        var keyResult = ForInOfExpressionEvaluation(right, iterationKind, labelSet);
        return ForInOfBodyEvaluation(left, body, keyResult, lhsKind, labelSet);
    }
    evaluation.ForInStatement = ForInStatement;
    function ForOfStatement(node, labelSet) {
        "use strict";
        var left = node.left;
        var right = node.right;
        var body = node.body;
        var tleft = left.type;
        var tright = right.type;
        var labelSet = labelSet || Object.create(null);
        var lhsKind;
        var iterationKind = "iterate";

        lhsKind = "assignment";

        if (IsLexicalDeclaration(left)) {
            lhsKind = "lexicalBinding";
        } else {
            lhsKind = "varBinding";
        }

        var keyResult = ForInOfExpressionEvaluation(right, iterationKind, labelSet);
        return ForInOfBodyEvaluation(left, body, keyResult, lhsKind, labelSet);
    }
    evaluation.ForOfStatement = ForOfStatement;
    function LabelledEvaluation(node, labelSet) {
        var result;
        var type = node.type;
        var fn = evaluation[type];
        if (fn) result = fn(node, labelSet);
        else throw new SyntaxError("can not evaluate " + type + atLineCol());
        return NormalCompletion(result);
    }
    evaluation.LabelledStatement = LabelledStatement;
    function LabelledStatement(node) {
        var exists;
        var label = node.label.name || node.label.value;
        var statement = node.statement;
        var labelSet = Object.create(null);

        labelSet[label] = node;

        var result = LabelledEvaluation(statement, labelSet);
        //if (!exists) cx.labelSet = undefined;
        return result;
    }
    evaluation.ForStatement = ForStatement;
    function ForStatement(node, labelSet) {
        "use strict";
        var initExpr = node.init;
        var testExpr = node.test;
        var incrExpr = node.update;
        var body = node.body;
        var exprRef, exprValue;
        var varDcl, isConst, dn, forDcl;
        var oldEnv, loopEnv, bodyResult;
        var cx = getContext();
        // FRESH BINDINGS

        var perIterationBindings = [];

        if (!labelSet) {
            labelSet = Object.create(null);
            //cx.labelSet = labelSet;
        }
        if (initExpr) {
            if (IsVarDeclaration(initExpr)) {
                varDcl = Evaluate(initExpr);
                if (!LoopContinues(varDcl, labelSet)) return varDcl;
                return ForBodyEvaluation(testExpr, incrExpr, body, labelSet, perIterationBindings);
            } else if (IsLexicalDeclaration(initExpr)) {
                oldEnv = getLexEnv();
                loopEnv = NewDeclarativeEnvironment(oldEnv);
                isConst = IsConstantDeclaration(initExpr);
                for (var i = 0, j = initExpr.declarations.length; i < j; i++) {
                    var names = BoundNames(initExpr.declarations[i]);
                    for (var y = 0, z = names.length; y < z; y++) {
                        var dn = names[y];
                        if (isConst) {
                            loopEnv.CreateImmutableBinding(dn);
                        } else {
                            loopEnv.CreateMutableBinding(dn, false);

                            // FRESH BINDINGS: collect the names here
                            perIterationBindings.push(dn);
                        }
                    }
                }
                getContext().LexEnv = loopEnv;
                forDcl = Evaluate(initExpr);
                if (!LoopContinues(forDcl, labelSet)) {
                    getContext().LexEnv = oldEnv;
                    return forDcl;
                }
                // FRESH BINDINGS: set the perI
                if (isConst) perIterationBindings = [];
                bodyResult = ForBodyEvaluation(testExpr, incrExpr, body, labelSet, perIterationBindings);
                getContext().LexEnv = oldEnv;
                return bodyResult;

            } else {
                var exprRef = Evaluate(initExpr);
                var exprValue = GetValue(exprRef);
                if (!LoopContinues(exprValue, labelSet)) return exprValue;
                return ForBodyEvaluation(testExpr, incrExpr, body, labelSet, perIterationBindings);
            }
        }

    }
    function CreatePerIterationEnvironment(perIterationBindings) {
        var len = perIterationBindings.length;
        if (len) {
            var lastIterationEnv = getLexEnv();
            var outer = lastIterationEnv.outer;
            Assert(outer != null, "CreatePerIterationEnvironment: outer MUST NOT be null");
            var thisIterationEnv = NewDeclarativeEnvironment(outer);
            for (var i = 0; i < len; i++) {
                var bn = perIterationBindings[i];
                var status = thisIterationEnv.CreateMutableBinding(bn, false);
                Assert(!isAbrupt(status), "status may not be an abrupt completion");
                var lastValue = lastIterationEnv.GetBindingValue(bn);
                if (isAbrupt(lastValue = ifAbrupt(lastValue))) return lastValue;
                thisIterationEnv.InitializeBinding(bn, lastValue);
            }
            getContext().LexEnv = thisIterationEnv;
        }
        return NormalCompletion(undefined);
    }
    function ForBodyEvaluation(testExpr, incrementExpr, stmt, labelSet, perIterationBindings) {
        "use strict";
        var V = undefined;
        var result;
        var testExprRef, testExprValue;
        var incrementExprRef, incrementExprValue;
        var status = CreatePerIterationEnvironment(perIterationBindings);
        if (isAbrupt(status)) return status;
        for (;;) {

            if (testExpr) {
                testExprRef = Evaluate(testExpr);
                testExprValue = ToBoolean(GetValue(testExprRef));
                if (testExprValue === false) return NormalCompletion(V);
                if (!LoopContinues(testExprValue, labelSet)) return testExprValue;
            }

            result = Evaluate(stmt);
            // here is a fix if no completion comes out (which is something which may not happen later anymore)
            if (result instanceof CompletionRecord) {
                if (result.value !== empty) V = result.value;
            } else V = result;

            if (!LoopContinues(result, labelSet)) return result;
            status = CreatePerIterationEnvironment(perIterationBindings);
            if (isAbrupt(status)) return status;
            if (incrementExpr) {
                incrementExprRef = Evaluate(incrementExpr);
                incrementExprValue = GetValue(incrementExprRef);
                if (!LoopContinues(incrementExprValue, labelSet)) return incrementExprValue;
            }
        }
    }

    function CaseSelectorEvaluation(node) {
        var test = node.test;
        var exprRef = Evaluate(test);
        return GetValue(exprRef);
    }

    function CaseBlockEvaluation(input, caseBlock) {
        var clause;
        var clauseSelector;
        var runDefault = true;
        var matched;
        var sList;
        var V;
        var R;
        var defaultClause;
        var searching = true;
        for (var i = 0, j = caseBlock.length; i < j; i++) {
            clause = caseBlock[i];
            if (clause.type === "DefaultCase") {
                defaultClause = clause;
            } else {
                clauseSelector = CaseSelectorEvaluation(clause);
                if (isAbrupt(clauseSelector=ifAbrupt(clauseSelector))) return clauseSelector;
                if (searching) matched = SameValue(input, clauseSelector);
                if (matched) {
                    searching = false;
                    sList = clause.consequent; // parseNode
                    if (sList) {
                        R = GetValue(Evaluate(sList));
                        if (isAbrupt(R=ifAbrupt(R))) {
                            if (R.type === "break") break;
                            if (R.type === "continue") return newTypeError( "continue is not allowed in a switch statement");
                            if (R.type === "throw") return R;
                            if (R.type === "return") return R;
                        } else {
                            V = R;
                        }
                    }
                    if (isAbrupt(R)) break;
                }
            }
        }
        if (!isAbrupt(R)) searching = true; // kein Break.
        if (searching && defaultClause) {
            R = Evaluate(defaultClause.consequent);
            if (isAbrupt(R)) {
                if (R.type === "break") return V;
                if (R.type === "continue") return newTypeError( "continue is not allowed in a switch statement");
                if (R.type === "throw") return R;
                if (R.type === "return") return R;
            } else {
                V = GetValue(R);
            }
        }
        return V;
    }
    evaluation.SwitchStatement = SwitchStatement;
    function SwitchStatement(node) {
        var oldEnv, blockEnv;
        var R;
        var switchExpr = node.discriminant;
        var caseBlock = node.cases;
        var exprRef = Evaluate(switchExpr);
        var switchValue = GetValue(exprRef);
        if (isAbrupt(switchValue)) return switchValue;
        oldEnv = getLexEnv();
        blockEnv = NewDeclarativeEnvironment(oldEnv);
        R = InstantiateBlockDeclaration(caseBlock, blockEnv);
        if (isAbrupt(R)) return R;
        getContext().LexEnv = blockEnv;
        R = CaseBlockEvaluation(switchValue, caseBlock);
        getContext().LexEnv = oldEnv;
        return R;
    }
    function TemplateStrings(node, raw) {
        var list = [];
        var spans = node.spans;
        var span;
        var i, j;
        if (raw) {
            if (spans.length === 1) return spans;
            for (i = 0, j = spans.length; i < j; i+=2) {
                if ((span = spans[i]) !== undefined) list.push(span);
            }
        } else {
            if (spans.length === 1) return [];
            for (i = 1, j = spans.length; i < j; i+=2) {
                if ((span = spans[i]) !== undefined) list.push(span);
            }
        }
        return list;
    }
    function SubstitutionEvaluation(siteObj) {
        var len = +Get(siteObj, "length");
        var results = [];
        for (var i = 0; i < len; i++) {
            var expr = Get(siteObj, ToString(i));
            if (isAbrupt(expr = ifAbrupt(expr))) return expr;
            if (typeof expr === "string") {
                expr = parseGoal("Expression", expr);
                var exprRef = Evaluate(expr);
                var exprValue = GetValue(exprRef);
                if (isAbrupt(exprValue = ifAbrupt(exprValue))) return exprValue;
                results.push(exprValue);
            }
        }
        return results;
    }
    function GetTemplateCallSite(templateLiteral) {
        if (templateLiteral.siteObj) return templateLiteral.siteObj;
        var cookedStrings = TemplateStrings(templateLiteral, false); // die expressions ??? bei mir jedenfalls gerade
        var rawStrings = TemplateStrings(templateLiteral, true); // strings
        var count = Math.max(cookedStrings.length, rawStrings.length);
        var siteObj = ArrayCreate(count);
        var rawObj = ArrayCreate(count);
        var index = 0;
        var prop, cookedValue, rawValue;
        while (index < count) {
            prop = ToString(index);
            cookedValue = cookedStrings[index];
            rawValue = rawStrings[index];
            if (cookedValue !== undefined) callInternalSlot(SLOTS.DEFINEOWNPROPERTY, siteObj, prop, {
                value: cookedValue,
                enumerable: false,
                writable: false,
                configurable: false
            });
            if (rawValue !== undefined) callInternalSlot(SLOTS.DEFINEOWNPROPERTY, rawObj, prop, {
                value: rawValue,
                enumerable: false,
                writable: false,
                configurable: false
            });
            index = index + 1;
        }
        SetIntegrityLevel(rawObj, "frozen");
        DefineOwnProperty(siteObj, "raw", {
            value: rawObj,
            enumerable: false,
            writable: false,
            configurable: false
        });
        SetIntegrityLevel(siteObj, "frozen");
        templateLiteral.siteObj = siteObj;
        return siteObj;
    }
    function TemplateLiteral(node) {
        return GetTemplateCallSite(node);
    }
    evaluation.TemplateLiteral = TemplateLiteral;
    var defaultClassConstructorFormalParameters = parseGoal("FormalParameterList", "...args");
    var defaultClassConstructorFunctionBody = parseGoal("FunctionBody", "return super(...args);");
    function DefineMethod(node, object, functionPrototype) {
        "use strict";
        var body = node.body;
        var formals = node.params;
        var key = node.id;
        var computed = node.computed;
        var strict = IsStrict(body);
        var scope = getLexEnv();
        var closure;
        var generator = node.generator;
        var propKey;
        if (computed) {
            propKey = GetValue(Evaluate(key));
            if (isAbrupt(propKey = ifAbrupt(propKey))) return propKey;
            if (!IsSymbol(propKey)) propKey = ToString(propKey);
            if (isAbrupt(propKey = ifAbrupt(propKey))) return propKey;
            if (!IsPropertyKey(propKey)) return newTypeError( "A [computed] property has to evaluate to valid property key");
        } else {
            propKey = PropName(node);
        }

        if (isAbrupt(propKey = ifAbrupt(propKey))) return propKey;
        if (generator) closure = GeneratorFunctionCreate("method", formals, body, scope, strict, functionPrototype);
        else closure = FunctionCreate("method", formals, body, scope, strict, functionPrototype);
        if (isAbrupt(closure = ifAbrupt(closure))) return closure;

        if (ReferencesSuper(node)) {
            MakeMethod(closure, propKey, GetPrototypeOf(object));
        }

        var rec = {
            key: propKey,
            closure: closure
        };
        return NormalCompletion(rec);
    }
    evaluation.MethodDefinition = MethodDefinition;
    function MethodDefinition(node, object) {
        "use strict";
        var fproto;
        if (node.generator) {
            var intrinsics = getIntrinsics();
            fproto = Get(intrinsics, INTRINSICS.GENERATORFUNCTION);
        }
        var methodDef = DefineMethod(node, object, fproto);
        if (isAbrupt(methodDef = ifAbrupt(methodDef))) return methodDef;
        SetFunctionName(methodDef.closure, methodDef.key);
        var desc = {
            value: methodDef.closure,
            writable: true,
            enumerable: true,
            configurable: true
        };
        return DefineOwnPropertyOrThrow(object, methodDef.key, desc);
    }
    evaluation.ClassDeclaration = ClassDeclaration;
    function ClassDeclaration(node) {
        "use strict";
        var cx = getContext();
        var superclass = null;
        var elements = node.elements;
        var constructor = ConstructorMethod(elements);
        var staticMethods = StaticMethodDefinitions(elements);
        var protoMethods = PrototypeMethodDefinitions(elements);
        var protoParent;
        var ObjectPrototype = getIntrinsic(INTRINSICS.OBJECTPROTOTYPE);
        var FunctionPrototype = getIntrinsic(INTRINSICS.FUNCTIONPROTOTYPE);
        var className = node.id;
        var isExtending = node.extends;
        var isConst = !!node.const;
        var isExpr = !!node.expr;
        var constructorParent;
        var Proto;
        var decl;
        var status;
        if (isExtending) {
            superclass = GetValue(Evaluate(node.extends));
            if (isAbrupt(superclass=ifAbrupt(superclass))) return superclass;
        }
        if (!superclass) {
            protoParent = null;
            // protoParent = ObjectPrototype;
            constructorParent = FunctionPrototype;
        } else {
            if (Type(superclass) !== OBJECT) return newTypeError( "superclass is no object");
            if (!IsConstructor(superclass)) return newTypeError( "superclass is no constructor");
            protoParent = Get(superclass, "prototype");
            if (isAbrupt(protoParent=ifAbrupt(protoParent))) return protoParent;
            if (Type(protoParent) !== OBJECT && Type(protoParent) !== NULL) return newTypeError( "prototype of superclass is not object, not null");
            constructorParent = superclass;
        }
        Proto = ObjectCreate(protoParent);
        if (isAbrupt(Proto=ifAbrupt(Proto))) return Proto;
        var lex = getLexEnv();
        var scope = NewDeclarativeEnvironment(lex);
        if (className && !isExpr) {
            lex.CreateMutableBinding(className);
        }
        var caller = cx.callee;
        getContext().LexEnv = scope;
        cx.callee = className;
        cx.caller = caller;

        var F = FunctionCreate("normal", [], null, scope, true, FunctionPrototype, constructorParent);
        if (isAbrupt(F=ifAbrupt(F))) return F;
        
        if (!constructor) {
            if (isExtending) {
                setInternalSlot(F, SLOTS.FORMALPARAMETERS, defaultClassConstructorFormalParameters);
                setInternalSlot(F, SLOTS.CODE, defaultClassConstructorFunctionBody);
            } else {
                setInternalSlot(F, SLOTS.FORMALPARAMETERS, []);
                setInternalSlot(F, SLOTS.CODE, []);
            }
        } else {
            setInternalSlot(F, SLOTS.FORMALPARAMETERS, constructor.params);
            SetFunctionLength(F, ExpectedArgumentCount(constructor.params));
            setInternalSlot(F, SLOTS.CODE, constructor.body);
        }

        var i, j;
        for (i = 0, j = protoMethods.length; i < j; i++) {
            if (decl = protoMethods[i]) {
                status = evaluation.MethodDefinition(decl, Proto);
                if (isAbrupt(status)) return status;
            }
        }
        for (i = 0, j = staticMethods.length; i < j; i++) {
            if (decl = staticMethods[i]) {
                status = evaluation.MethodDefinition(decl, F);
                if (isAbrupt(status)) return status;
            }
        }
        if (protoParent) {
            setInternalSlot(F, SLOTS.HOMEOBJECT, protoParent);
            setInternalSlot(F, SLOTS.METHODNAME, "constructor");
        }
        MakeConstructor(F, false, Proto);

        setInternalSlot(F, SLOTS.CONSTRUCT, function (argList) {
            var O = OrdinaryConstruct(this, argList);
            if (isConst) {
    		status = SetIntegrityLevel(O, "frozen");
    		if (isAbrupt(status)) return status;
    	    }
    	    return O;
        });

        if (className) {
            status = SetFunctionName(F, className);
            if (isAbrupt(status)) return status;
            if (!isExpr) lex.InitializeBinding(className, F);
        }
        getContext().LexEnv = lex;
        if (isConst) {
    	    status = SetIntegrityLevel(F, "frozen");
    	    if (isAbrupt(status)) return status;
        }
        return NormalCompletion(F);
    }

    function SuperExpression(node) {
        return NormalCompletion(empty);
    }
    evaluation.SuperExpression = SuperExpression;
    evaluation.ModuleDeclaration = ModuleDeclaration;
    function ModuleDeclaration(node) {
        var body = node.body;
        var oldContext = getContext();
        var initContext = ExecutionContext(getContext(), getRealm());
        var env = NewDeclarativeEnvironment(getLexEnv());

        var status = InstantiateModuleDeclaration(node, env);
        if (isAbrupt(status)) return status;

        var result = EvaluateModuleBody(node);
        if (isAbrupt(result)) return result;

        return NormalCompletion(undefined);
    }
    evaluation.ImportStatement = ImportStatement;
    evaluation.ExportStatement = ExportStatement;
    function ImportStatement(node) {
        // Get Module x
        // Get Property y of Module and Return
        var importRef;
        var importValue;
        var moduleRef;
        var moduleValue;
        var status;
        // shh. wait for the next draft. ;)
        return NormalCompletion("this is an import");
    }
    function ExportStatement(node) {
        return NormalCompletion("this is an export");
    }
    evaluation.WithStatement = WithStatement;
    function WithStatement(node) {
        var body = node.body;
        var object = GetValue(Evaluate(node.object));
        if (isAbrupt(object = ifAbrupt(object))) return object;
        var objEnv = ObjectEnvironment(object, getContext().LexEnv);
        objEnv.withEnvironment = true;
        var oldEnv = getLexEnv();
        getContext().LexEnv = objEnv;
        var result = Evaluate(body);
        getContext().LexEnv = oldEnv;
        if (isAbrupt(result)) return result;
        return NormalCompletion(undefined);
    }
    evaluation.ArrayComprehension = ArrayComprehension;
    evaluation.GeneratorComprehension = GeneratorComprehension;
    function ComprehensionEvaluation(node, accumulator) {
        var filters = node.filter;
        var expr = node.expression;
        var filter;
        if (accumulator !== undefined) {
            if (filters.length) {
                for (var i = 0, j = filters.length; i < j; i++) {
                    if (filter = filters[i]) {
                        var filterRef = Evaluate(filter);
                        var filterValue = GetValue(filterRef);
                        if (isAbrupt(filterValue = ifAbrupt(filterValue))) return filterValue;
                        if (ToBoolean(filterValue) === false) break;
                    }
                }
            }
            if (!filter || (ToBoolean(filterValue) === true)) {
                var exprRef = Evaluate(expr);
                var exprValue = GetValue(exprRef);
                if (isAbrupt(exprValue=ifAbrupt(exprValue))) return exprValue;
                var len = Get(accumulator, "length");
                if (len >= (Math.pow(2, 53) - 1)) return newRangeError( "Range limit exceeded");
                var putStatus = Put(accumulator, ToString(len), exprValue, true);
                if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
                len = len + 1;
                putStatus = Put(accumulator, "length", len, true);
                if (isAbrupt(putStatus = ifAbrupt(putStatus))) return putStatus;
            }
            return NormalCompletion(undefined);
        } else {
            var yieldStatus = GeneratorYield(CreateItrResultObject(value, false));
            if (isAbrupt(yieldStatus = ifAbrupt(yieldStatus))) return yieldStatus;
            return NormalCompletion(undefined);
        }
    }
    function QualifierEvaluation(block, node, accumulator) {

        var forBinding = block.left;
        var assignmentExpr = block.right;
        var exprRef = Evaluate(assignmentExpr);
        var exprValue = GetValue(exprRef);
        var obj = ToObject(exprValue);
        if (isAbrupt(obj = ifAbrupt(obj))) return obj;
        var iterator = Invoke(obj, $$iterator, []);
        var keys = ToObject(iterator);
        var oldEnv = getLexEnv();
        var noArgs = [];
        var status;
        for (;;) {
            var nextResult = Invoke(keys, "next", noArgs);
            if (isAbrupt(nextResult = ifAbrupt(nextResult))) return nextResult;
            if (Type(nextResult) !== OBJECT) return newTypeError( "QualifierEvaluation: nextResult is not an object");
            var done = IteratorComplete(nextResult);
            if (isAbrupt(done = ifAbrupt(done))) return done;
            if (done === true) return true;
            var nextValue = IteratorValue(nextResult);
            if (isAbrupt(nextValue = ifAbrupt(nextValue))) return nextValue;
            var forEnv = NewDeclarativeEnvironment(oldEnv);
            var bn = BoundNames(forBinding);
            for (var i = 0, j = bn.length; i < j; i++) {
                forEnv.CreateMutableBinding(bn[i]);
                status = BindingInitialization(forBinding, nextValue, forEnv);
                if (isAbrupt(status)) return status;
            }
            getContext().LexEnv = forEnv;
            var continuer = ComprehensionEvaluation(node, accumulator);
            getContext().LexEnv = oldEnv;
            if (isAbrupt(continuer = ifAbrupt(continuer))) return continuer;
        }
    }
    function ArrayComprehension(node) {
        var blocks = node.blocks;
        var filter = node.filter;
        var expr = node.expression;

        var array = ArrayCreate(0);
        var status;

        for (var i = 0, j = blocks.length; i < j; i++) {
            status = QualifierEvaluation(blocks[i], node, array);
            if (isAbrupt(status = ifAbrupt(status))) return status;
        }
        return array;
    }
    function GeneratorComprehension(node) {
        var filter = node.filter;
        var blocks = node.blocks;
        var binding;
        var closure = FunctionCreate("generator", [], [], getLexEnv(), true);
        return callInternalSlot(SLOTS.CALL, closure, undefined, []);
    }
    function CatchClauseEvaluation(thrownValue, catchNode) {
        var status, oldEnv, catchEnv;
        var catchBlock = catchNode.block;
        var catchParameter = catchNode.params && catchNode.params[0];
        var boundNames = BoundNames(catchNode.params);
        var R;
        oldEnv = getLexEnv();
        catchEnv = NewDeclarativeEnvironment(oldEnv);
        getContext().LexEnv = catchEnv;
        for (var i = 0, j = boundNames.length; i < j; i++) {
            catchEnv.CreateMutableBinding(boundNames[i]);
        }
        status = BindingInitialization(catchParameter, thrownValue, undefined);
        if (isAbrupt(status)) return status;
        R = Evaluate(catchBlock);
        getContext().LexEnv = oldEnv;
        return R;
    }
    evaluation.Finally = Finally;
    function Finally(node) {
        /*
            return operandStack.pop();
         */
        return Evaluate(node.block);
    }
    evaluation.TryStatement = TryStatement;
    function TryStatement(node) {
        var tryBlock = node.handler;
        var catchNode = node.guard;
        var finalizer = node.finalizer;
        var B, C, F;

        B = Evaluate(tryBlock);
        if (isAbrupt(B) && (B.type === "throw")) {
            var thrownValue = B.value;
            C = CatchClauseEvaluation(thrownValue, catchNode);
        } else {
            C = B;
        }

        if (finalizer) {
            F = Evaluate(finalizer);
            if (!isAbrupt(F)) {
                return C;
            }
        } else {
            return C;
        }
        return F;
    }
    var isStrictDirective = {
        __proto__:null,
        "'use strict'": true,
        '"use strict"': true
    };
    var isAsmDirective = {
        __proto__:null,
        "'use asm'": true,
        '"use asm"': true
    };
    evaluation.Directive = Directive;
    function Directive(node) {
        if (isStrictDirective[node.value]) {
            getContext().strict = true;
        } else if (isAsmDirective[node.value]) {
            getContext().asm = true;
        }
        return NormalCompletion(empty);
    }

    var nodeWithList = {
        "Program": "body",
        "FunctionDeclaration": "body",
        "FunctionExpression": "body",
        "GeneratorDeclaration": "body",
        "GeneratorExpression": "body",
        "SwitchStatement": "cases",
        "SequenceExpression": "sequence",
        "DoWhileStatement": "body",
        "WhileStatement": "body",
        "ForStatement" :"body",
        "ForInStatement": "body",
        "ForOfStatement": "body"
    };

    /* 
     Have to take a pencil an write the stack up,
     to check out which to put onto and what to pop
     off the stack for only one purpose: GENERATOR.
     (The only thing which really needs some memory,
     coz a visitor can´t break and resume a walk)
     */

    function tellExecutionContext(node, index, parent) {
        loc = node.loc || loc;
        var state = getContext().state;
        var rec;

        if (nodeWithList[node.type]) {
            state.push({
                list: true,
                node: node,
                parent: parent,
                index: -1
            });
        } else {
            state.push({
                list:false, node: node, index: index, parent: parent
            });
        }

    }
    function untellExecutionContext() {
        var cx = getContext();
        cx.state.pop();

    }
    evaluation.ScriptBody =
        evaluation.Program = Program;
    function Program(program) {
        "use strict";
        var v;
        var cx = getContext();
        if (program.strict || keepStrict) {
            cx.strict = true;
            if (shellMode) keepStrict = true;
        }
        var status = InstantiateGlobalDeclaration(program, getGlobalEnv(), []);
        if (isAbrupt(status)) return status;
        cx.callee = "ScriptItemList";
        cx.caller = "Script";
        var node;
        var V = undefined;
        var body = program.body;
        // tellExecutionContext(body, 0, null);
        for (var i = 0, j = body.length; i < j; i += 1) {
            if (node = body[i]) {
                // tellExecutionContext(node, i, body);
                v = GetValue(Evaluate(node));
                if (isAbrupt(v)) {
                    return v;
                }
                if (v !== empty) V = v;
            }
        }
        // untellExecutionContext();
        return NormalCompletion(V);
    }

    function tellContext(node) {
        var loc = node.loc;
        var cx = getContext();
        if (loc && loc.start) {
            cx.line = loc.start.line;
            cx.column = loc.start.column;
        }
    }
    ecma.Evaluate = Evaluate;
    function Evaluate(node, a, b, c) {
        var E, R;
        var body, i, j;
        if (!node) return;
        if (typeof node === "string") {
            R = ResolveBinding(node);
            return R;
        }
        if (Array.isArray(node)) {
            if (node.type) R = evaluation[node.type](node, a, b, c);
            else R = evaluation.StatementList(node, a, b, c);
            return R;
        }
        // //debug("Evaluate(" + node.type + ")");
        if (E = evaluation[node.type]) {
            tellContext(node);
            // tellExecutionContext(node, 0);
            R = E(node, a, b, c);
            // untellExecutionContext();
        }
        return R;
    }




    /*
        got to change all function (node)
        to function ()
        which fetch the nodes/results from the codeStack/operandStack
        this can be done top-to-bottom on one day,
        once i am in.
        Then a resume evaluation should be a no-problem and be already for free.
        Plus it makes the lowest call stack possible, with just the ops on the data.

     */
    function putOnStack(node) {
        var i, j;
        var body, declarations, no;
        var stack = getContext().stack;

        switch(node.type) {
            case "Program":
                // // return {type:type,_id_:++nodeId,strict:undefined,body:undefined,loc:undefined,extras:undefined};
                for (i= node.body.length - 1; i >= 0; i--) {
                    stack.push(node.body[i]);
                }
                break;
            case "Identifier":
                stack.push(node);
                break;
                // // return {type:type,_id_:++nodeId,name:undefined,loc:undefined,extras:undefined};
            case "ParenthesizedExpression":
            case "ExpressionStatement":
                stack.push(node.expression);
                stack.push(node);
                break;
                // // return {type:type,_id_:++nodeId,expression:undefined,loc:undefined,extras:undefined};
            case "LexicalDeclaration":
            case "VariableDeclaration":
                stack.push(node);
                break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "GeneratorDeclaration":
            case "GeneratorExpression":
                stack.push(node);
                // // return {type:type,_id_:++nodeId,expression:undefined,generator:undefined,strict:undefined,id:undefined,params:undefined,body:undefined,loc:undefined,extras:undefined};
                break;
            case "ArrowExpression":
                // // return {type:type,_id_:++nodeId,params:undefined,body:undefined,loc:undefined,ebxtras:undefined};
                stack.push(node);
                break;
            case "NumericLiteral":
            case "StringLiteral":
            case "BooleanLiteral":
            case "Literal":
                // // return {type:type,_id_:++nodeId,value:undefined,loc:undefined,extras:undefined}
                stack.push(node);
                break;
            case "TemplateLiteral":
                // // return {type:type,_id_:++nodeId,spans:undefined,loc:undefined,extras:undefined}
                stack.push(node);
                break;
            case "ObjectExpression":
                // // return {type:type,_id_:++nodeId,properties:undefined,loc:undefined,extras:undefined};
                stack.push(node);
                break;
            case "ArrayExpression":
                // // return {type:type,_id_:++nodeId,elements:undefined,loc:undefined,extras:undefined};
                stack.push(node);
                break;
            case "ObjectPattern":
            case "ArrayPattern":
                // // return {type:type,_id_:++nodeId,elements:undefined,loc:undefined,extras:undefined};
            case "WhileStatement":
            case "DoWhileStatement":
                // // return {type:type,_id_:++nodeId,test:undefined, body:undefined,loc:undefined,extras:undefined};
            case "BlockStatement":
                // // return {type:type,_id_:++nodeId,body:undefined,loc:undefined,extras:undefined};
            case "IfStatement":
                // // return {type:type,_id_:++nodeId,test:undefined,consequent:undefined,alternate:undefined,loc:undefined,extras:undefined};
            case "ConditionalExpression":
                // // return {type:type,_id_:++nodeId,test:undefined,consequent:undefined,alternate:undefined,loc:undefined,extras:undefined};
            case "BinaryExpression":
            case "AssignmentExpression":
                // // return {type:type,_id_:++nodeId,operator:undefined,left:undefined,right:undefined,loc:undefined,extras:undefined};
            case "ForInOfStatement":
                // // return {type:type,_id_:++nodeId,left:undefined,right:undefined,body:undefined,loc:undefined,extras:undefined};
            case "ForStatement":
                // // return {type:type,_id_:++nodeId,init:undefined,test:undefined,update:undefined,loc:undefined,extras:undefined};
            case "NewExpression":
                // // return {type:type,_id_:++nodeId, callee:undefined, arguments:undefined, loc:undefined, extras:undefined};
            case "CallExpression":
                // // return {type:type,_id_:++nodeId, callee:undefined, arguments:undefined, loc:undefined, extras:undefined};
            case "RestParameter":
                // // return {type:type,_id_:++nodeId, id:undefined, loc:undefined, extras:undefined};
            case "SpreadExpression":
                // // return {type:type,_id_:++nodeId, id:undefined, loc:undefined, extras:undefined};
            case "BindingPattern":
                // // return {type:type,_id_:++nodeId, id:undefined, target:undefined, loc:undefined, extras:undefined};
            case "ArrayComprehension":
                // // return {type:type,_id_:++nodeId, blocks:undefined, filter:undefined, expression:undefined, loc:undefined, extras:undefined};
            case "GeneratorComprehension":
                // // return {type:type,_id_:++nodeId, loc:undefined, extras:undefined};
            case "SwitchStatement":
                // // return {type:type,_id_:++nodeId, discriminant:undefined, cases:undefined, loc:undefined, extras:undefined};
            case "DefaultCase":
                // // return {type:type,_id_:++nodeId, consequent:undefined, loc:undefined, extras:undefined};
            case "SwitchCase":
                // // return {type:type,_id_:++nodeId, test:undefined, consequent:undefined, loc:undefined, extras:undefined};
            case "TryStatement":
                // // return {type:type,_id_:++nodeId, handler:undefined, guard:undefined, finalizer:undefined, loc:undefined, extras:undefined};
            case "CatchClause":
                // // return {type:type,_id_:++nodeId, block:undefined, loc:undefined, extras:undefined};
            case "Finally":
                // // return {type:type,_id_:++nodeId, block:undefined, loc:undefined, extras:undefined};
            default:
                // // return {type:type,_id_:++nodeId, loc:undefined, extras:undefined};
        }

    }


    function evalLoop() {
        var i, j;
        var body, declarations, no;

        var cx = getContext();
        var stack = cx.stack;
        var pc = cx.pc;
        var operandStack = cx.operandStack;
        var sp = cx.sp;

        var status, result;
        var r0, r1, r2, r3, r4;
        var R, E, V;
        var node;
        do {

            // initial cx.stack = [ Program ];
            node = stack[sp];

            switch (node.type) {
                case "Program":
                    putOnStack(node.body);
                    // hat nun alle nodes platziert.
                    // hier noch die GlobalDeclarationInstantiation
                    var status = InstantiateGlobalDeclaration();
                    cx.strict = !!node.strict;

                    break;
                case "Identifier":
                    R = Identifier();
                    if (isAbrupt(R=ifAbrupt(R))) return R;
                    operandStack[++sp] = R;
                    // should be on operand stack now
                case "ParenthesizedExpression":
                case "ExpressionStatement":
                    stack[++sp]
                    break;
                case "LexicalDeclaration":
                case "VariableDeclaration":
                    break;
                case "VariableDeclarator":
                    break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "GeneratorDeclaration":
                case "GeneratorExpression":
                    break;
                case "ArrowExpression":
                    break;
                case "NumericLiteral":
                case "StringLiteral":
                case "BooleanLiteral":
                case "Literal":
                    operandStack[++sp] = Literal();
                    break;
                case "TemplateLiteral":
                    break;
                case "ObjectExpression":
                    break;
                case "ArrayExpression":
                    break;
                case "ObjectPattern":
                case "ArrayPattern":
                case "WhileStatement":
                case "DoWhileStatement":
                case "BlockStatement":
                case "IfStatement":
                case "ConditionalExpression":
                case "BinaryExpression":
                case "AssignmentExpression":
                case "ForInOfStatement":
                case "ForStatement":
                case "NewExpression":
                case "CallExpression":
                case "RestParameter":
                case "SpreadExpression":
                case "BindingPattern":
                case "ArrayComprehension":
                case "GeneratorComprehension":
                case "SwitchStatement":
                case "DefaultCase":
                case "SwitchCase":
                case "TryStatement":
                case "CatchClause":
                case "Finally":
                default:
                    break;
            }

            // if (!stack.length) NextTask();

            sp = sp - 1;

        } while (sp >= 0);

        cx.sp = sp;
        cx.pc = pc;

        R = operandStack[sp--];
        if (isAbrupt(R=ifAbrupt(R))) return R;
        return NormalCompletion(R);
    }

    /*
        Downwards the EventQueue (setTimeout, Emitter):
        put the handler together with the new TaskQueue
        and use "TimerTasks" for your "setTimeout" Tasks.
        but change to use their task structure, my "task"
        here is different.

     */

    function HandleEventQueue(shellmode, initialized) {
        var task, func, time, result;
        // pendingExceptions = []

        var LoadingTasks = getRealm().LoadingTasks;
        var PromiseTasks = getRealm().PromiseTasks;

        var result = NextTask(undefined, PromiseTasks); // PRomises are resolved here, is right
        // result = NextTask(undefined,LoaderTasks);
        //

        function handler() {
            var eventQueue = getEventQueue();
            if (task = eventQueue.shift()) {
                func = task.func;
                time = Date.now();
                if (time >= (task.time + task.timeout)) {
                    if (IsCallable(func)) result = callInternalSlot(SLOTS.CALL, func, ThisResolution(), []);
                    if (isAbrupt(result)) {
                        try {
                            throw makeNativeException(result.value);
                        } catch (ex) {
                                consoleLog("Exception: happend async and is just a print of the exception´s object");
                                consoleLog(ex.name);
                                consoleLog(ex.message);
                                consoleLog(ex.stack);
                        }
                    }
                } else eventQueue.push(task);
            }
            if (eventQueue.length) setTimeout(handler, 0);
            else {
                if (!shellmode && initialized) endRuntime();
            }
        }
        setTimeout(handler, 0);
    }


    function setScriptLocation (loc) {
        scriptLocation = "(syntax.js)";
        if (typeof window !== "undefined") {
            loc = loc || document.location.href;
            scriptLocation = "("+document.location.href + " @syntax.js)";
        } else if (typeof process !== "undefined") {
            loc = loc || __dirname;
            scriptLocation = "(node.js interpreter)";
        } else {
            scriptLocation = "(worker)";
        }
        realm.scriptLocation = scriptLocation;
    }


    function initializeTheRuntime() {
        initializedTheRuntime = true;
    }
    function endRuntime() {
        initializedTheRuntime = false;
    }


    function execute(source, shellModeBool, resetEnvNowBool) {
        var exprRef, exprValue, text, type, message, stack, error, name, callstack;

        shellMode =  shellModeBool; // prolly just for this legacy execute function

        var node = typeof source === "string" ? parse(source) : source;
        if (!node) throw "example: Call execute(parse(source)) or execute(source)";

        if (!initializedTheRuntime || !shellModeBool || resetEnvNowBool) {
            var realm = CreateRealm();  // it´s our default realm. but i should use realm.eval below then, to uni- and simplify
                                        // and for that the task queues go behind the realm.eval code, wherever i am there

                                        // and this file gets rewritten to use a codestack for nodes
                                        // and to pop left and right from the opstack after evaluate

                                        // i put the node on the stack
                                        // it´s time, i eval left and right and put them onto the stack
                                        // then i call node[node.type] and inside i first fetch two from
                                        // the opstack

                                        // the idea i refine and we are fine with generators, reducing just
                                        // the rest of their stack.

                                        // i should start with the lists, just the lists.
                                        // if they find themself on the stack, they are finished.

            ecma.setCodeRealm(realm);
            keepStrict = false;
            initializeTheRuntime();
            setScriptLocation();
            NormalCompletion(undefined);
        }
        // convert references into values to return values to the user (toValue())
        try {
            exprRef = Evaluate(node);
            if (Type(exprRef) === REFERENCE) exprValue = GetValue(exprRef);
            else exprValue = exprRef;
        } catch (ex) {
            consoleLog("Real JS Exception:");
            consoleLog(ex);
            consoleLog(ex.message);
            consoleLog(ex.stack);
            throw ex;
        }
        // exception handling. really temporarily in this place like this
        if (isAbrupt(exprValue = ifAbrupt(exprValue))) {
            if (exprValue.type === "throw") {
                error = exprValue.value;
                if (Type(error) === OBJECT) {
                    throw makeNativeException(error);
                } else {
                    error = new Error(error);
                    error.stack = "{eddies placeholder for stackframe of non object throwers}";
                }
                if (error) throw error;
            }
        }

        /*
         my self-defined event queue shall become realm.TimerTasks, mainly
         for SetTimeout.
         Now i should consider reworking this part and intrinsics/settimeout.js
         to use getRealm().TimerTasks instead of realm.eventQueue and schedule
         in the MicroTask Format supplied with ES6 Promises.
         */

        var eventQueue = getEventQueue();
        var pt = getTasks(getRealm(), "PromiseTasks");

        if (!shellModeBool && initializedTheRuntime && !eventQueue.length && (!pt || !pt.length)) endRuntime();
        else if (eventQueue.length || (pt&& pt.length)) setTimeout(function () {HandleEventQueue(shellModeBool, initializedTheRuntime);}, 0);

        return exprValue;
    }


    /*
     * experiment execution block (uncompleted concepts for async/eventual/transformed return values)
     */
    function ExecuteAsync (source) {
        return makePromise(function (resolve, reject) {
            initializeTheRuntime();
            var result = Evaluate(parse(source));
            if (isAbrupt(result)) {
                if (result.type === "return") {
                    resolve(result.value);
                } else {
                    reject(result.value);
                }
            } else {
                resolve(result.value);
            }
            endRuntime();
        });

    }
    function ExecuteAsyncTransform (source) {
        return makePromise(function (resolve, reject) {
            initializeTheRuntime();
            var result = Evaluate(parse(source));
            if (isAbrupt(result)) {
                if (result.type === "return") {
                    resolve(TransformObjectToJSObject(GetValue(result.value)));
                } else {
                    reject(TransformObjectToJSObject(GetValue(result.value)));
                }
            } else {
                resolve(TransformObjectToJSObject(GetValue(result.value)));
            }
            endRuntime();
        });
    }
    function DeepStaticJSSnapshotOfObject(O) {
        var keys = OwnPropertyKeysAsList(O);
        var o = {};
        keys.forEach(function (key) {

        });
    }
    function TransformObjectToJSObject(O) {
        /*
         incomplete transformer/static proxy
         */
        var o = {};
        var keys = OwnPropertyKeysAsList(O);
        keys.forEach(function (key) {

            var desc = GetOwnProperty(O, key);
            var dd;
            if (!(dd=IsDataDescriptor(desc))) {
                var get = desc.get;
                var set = desc.set;
                var newGetter, newSetter;
                newGetter = function () {
                    var result = callInternalSlot(SLOTS.CALL, get, O, []);
                    if (isAbrupt(result = ifAbrupt(result))) throw result;
                    return TransformObjectToJSObject(result);
                };
                newSetter = function (v) {
                    var result = callInternalSlot(SLOTS.CALL, set, O, [v]);
                    if (isAbrupt(result = ifAbrupt(result))) throw result;
                    return v;
                };
                Object.defineProperty(o, key, {
                    get: newGetter,
                    set: newSetter,
                    enumerable: desc.enumerable,
                    configurable: desc.configurable
                });
            } else {
                var value = desc.value;
                var newValue;
                if (Type(value) === OBJECT) {
                    if (IsCallable(value)) {
                        newValue = function () {
                            var c = callInternalSlot(SLOTS.CALL, value, value, arguments);
                            c = unwrap(c);
                            if (Type(c) === OBJECT) return TransformObjectToJSObject(c);
                            return c;
                        };
                    } else {
                        newValue = TransformObjectToJSObject(value);
                    }
                } else if (Type(value) === SYMBOL) {
                    newValue = {
                        type: "symbol",
                        description: value.Description
                    };
                } else newValue = value;

                Object.defineProperty(o, key, {
                    value: newValue,
                    writable: desc.writable,
                    enumerable: desc.enumerable,
                    configurable: desc.configurable
                });
            }
        });
        return o;
    }
    
    
    
    
    
    execute.evaluation = evaluation;
    execute.setCodeRealm = setCodeRealm;

    // the big letters look ugly.
    // i will replace globally for camelCase the days
    // (only the specification names will be the same,
    // but even there i think about lowering the first char,
    // because i read, how confusing it is. i´m learning from
    // my first project.)
    execute.Evaluate = Evaluate;
    execute.ExecuteAsync = ExecuteAsync;
    execute.ExecuteAsyncTransform = ExecuteAsyncTransform;
    execute.TransformObjectToJSObject = TransformObjectToJSObject;
    execute.DeepStaticJSSnapshotOfObject = DeepStaticJSSnapshotOfObject;
    //    execute.makeRuntime = makeRuntime;
    return execute;

//    }
//    return makeRuntime();
});



    // experimental typed memory and compiler (development)
    //--#include "lib/heap/heap.js"; // too high level (would be too slow)
    
/**
 * asm-typechecker
 *
 * The purpose of this module is to be able analyse the javascript
 * and to provide function to analyse the heap to obtain validation results
 *
 * This file will mostly implement the asm.js Specification in sense of
 * AST analysis, and later, when more is existing bytecode analysis.
 *
 * The functions here should be easy to apply on the ast to obtain true or
 * false or the resulting type of the relevant check.
 * Whenever needed it should memoize and generate static informations.
 *
 */
define("asm-typechecker", function (require, exports){
    "use strict";

    /**
     * The environments are needed again
     */
    var globalEnvironment = Object.create(null);
    var localEnvironment = Object.create(null);
    var blockEnvironment = Object.create(null);

    /**
     * these types are disallowed from escaping
     * @type {number}
     */
    var VOID = 1;	    // return;
    var INTISH = 2;	    //
    var DOUBLISH = 3;	//
    var INT = 4;	    //
    var UNSIGNED = 5;	// -127 >>> 0 === 4294967169
    /**
     * those types may escape the asm.js module
     * @type {number}
     */
    var DOUBLE = 6;	// +number === DOUBLE
    var SIGNED = 7;	// -number === SIGNED
    var FIXNUM = 8;	//
    var EXTERN = 9;	//
    /**
     * What is it, what i have to to?
     *
     * - Parameter Validator
     *   this one checks the functions arguments
     *   in the function body. is run together with the
     *   rest, but i will separate it within this code
     *   x = +x; // double
     *   x = x|0; // int
     *
     * - Return Type Validator
     *   return +x; // double
     *   return x|0; int
     *
     *
     *
     * - Statement and Expression Validator
     *
     *
     */

    var currentFunction;
    var currentFunctionStack = [];
    var statics = require("slower-static-semantics");
    var VarDeclaredNames = statics.VarDeclaredNames;
    var LexicallyDeclaredNames = statics.LexicallyDeclaredNames;
    var VarScopedDeclarations = statics.VarScopedDeclarations;
    var LexicallyScopedDeclarations = statics.LexicallyScopedDeclarations;
    var BoundNames = statics.BoundNames;

    /**
     * getTypeOfParameter can look at
     * AssignmentExpressions
     *
     * x = +x
     * x = x|0
     *
     * @param node
     * @returns {boolean}
     */

    function getTypeOfParameter(node) {
        if (isAssignmentExpressionAssign(node) &&
            isLeftAndRightSameIdentifier(node)) {
                if (isDouble(node.right)) return DOUBLE;
                if (isInt(node.right)) return INT;
            }
    }

    function isLeftAndRightSameIdentifier(node) {
        var left = node.left;
        if (!isIdentifier(left)) return false;
        var idLeft = node.left.name;
        //console.log("idLeft "+idLeft);
        var right = node.right;
        if (isBinaryExpression(right)) {
            if (!isIdentifier(right.left)) return false;
            var idRight = right.left.name;
            //console.log("idRight bin "+idRight)
            return idLeft === idRight;
        }
        else if (isUnaryExpression(right)) {
            if (!isIdentifier(right.argument)) return false;
            idRight = right.argument.name;
            //console.log("idRight unary "+idRight);
            return idLeft === idRight;
        }
        return false;
    }
    function isAssignmentExpression(node) {
        return node.type === "AssignmentExpression";
    }
    function isAssignmentExpressionAssign(node) {
        return node.type === "AssignmentExpression" && node.operator === "=";
    }
    function isUnaryExpression(node) {
        return node.type === "UnaryExpression";
    }
    function isBinaryExpression(node) {
        return node.type === "BinaryExpression";
    }
    function isIdentifier(node) {
        return node.type === "Identifier";
    }

    function isInt(node) {
        // x = x | 0 is int
        if (node.type === "AssignmentExpression") return isInt(node.right);
        return  (node.type === "BinaryExpression") && (node.operator === "|") && (node.left.type === "Identifier") && (node.right.value === "0");

    }
    function isDouble(node) {
        // x = +x; is double
        if (node.type === "AssignmentExpression") return isDouble(node.right);
        return (node.type === "UnaryExpression") && (node.operator === "+") && (node.argument.type === "Identifier");
    }

    function isSignedId(node) {
        // -x
        return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Identifier";
    }
    function isSignedNumeric(node) {
        // -x
        return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "NumericLiteral";
    }

    function isVariableDeclarator(node) {
        return node.type === "VariableDeclarator";
    }

    function isNumber (node) {
        return node.type === "NumericLiteral";
    }

    function isReturnStatement(node) {
        return node.type === "ReturnStatement";
    }

    function isVariableDeclaration (node) {
        return node.type === "VariableDeclaration";
    }


    /**
     * ReturnStatement Analysis
     * Return the type of the return statement
     *
     * return +e:Expression
     * return e:Expression|0
     * return n:-NumericLiteral
     * return;
     *
     * @param node
     */
    function getTypeOfReturnStatement(node) {
        if (isReturnStatement(node)) {
            var argument = node.argument;
            if (!argument) return VOID;
            switch (argument.type) {
                case "UnaryExpression":
                    if (argument.prefix) {
                        if (argument.operator === "-" && argument.type === "NumericLiteral") return SIGNED;
                        if (argument.operator === "+") return DOUBLE;
                    }
                    break;
                case "BinaryExpression":
                    if (node.operator === "|" && node.value === "0") return INT;
                    break;
            }
        }
    }


    /**
     * Validate the VariableDeclarations
     * @param node
     * @constructor
     */
    function VariableDeclaration(node) {
        var declarations;
        if (isVariableDeclaration(node)) {
            for (var i = 0, j = declarations.length; i < j; i++) {
                var decl = declarations[i];

            }

        }
    }

    function getTypeOfVariableDeclaration(node) {
        if (isVariableDeclarator(node)) {
            if (node.init) return getTypeOfInitializer(node);
        }
    }

    function getTypeOfInitializer(node) {
        var initializer = decl.init;
        if (isInt(initializer)) return INT;
        if (isDouble(initializer)) return DOUBLE;
        if (isNumber(initalizer)) return DOUBLE;
    }

    function isValidInitializer(node) {

    }

    /**
     * Validate the FunctionDeclarations
     * @param node
     * @constructor
     */
    function FunctionDeclaration(node) {
        currentFunctionStack.push(currentFunction);
        currentFunction = {
            node: node,
            boundNamesParam: BoundNames(node.params),
            varScopedDecls: VarScopedDeclarations(node),
            varDeclaredNames: VarDeclaredNames(node),
            lexScopedDecls: LexicallyScopedDeclarations(node),
            lexDeclaredNames: LexicallyDeclaredNames(node)
        };
        /*
                go for the the body

         */

        currentFunction = currentFunctionStack.pop();
    }

    /**
     * Iterate through the parameter list
     * and memoize the BoundNames
     * (maybe just call BoundNames for)
     *
     *
     * @param node
     * @constructor
     */
    function FormalParameters(node) {
        var names = currentFunction.boundNamesParams;
        var body = node.body;
        var i = 0;
        var expr = body[0];
        do {
            var type = getTypeOfParameter(expr);
            if (type != DOUBLE && type != INT) {
                throw new TypeError("error validating parameter types");
            }
        } while ((expr = body[++i]) && (expr.type === "AssignmentExpression" || expr.type === "VariableDeclaration"));
        // walks as long as there are assignments under each.
        // but
    }


    function isFunctionDeclaration(node) {
        return node.type === "FunctionDeclaration";
    }

    function Module (node) {
        if (isFunctionDeclaration(node)) {
            var params = node.params;
            if (node.params.length === 3) {
                var stdlib = node.params[0];
                var foreign = node.params[1];
                var heap = node.params[2];
            }
        }
    }


    function validate(node) {
        var f = validator[node.type];
        if (f) return f.call(validator, node);
    }

    var valueTypes = Object.create(null);
    // may not escape
    valueTypes.VOID = VOID;
    valueTypes.INTISH = INTISH;
    valueTypes.DOUBLISH = DOUBLISH;
    valueTypes.INT = INT;
    valueTypes.UNSIGNED = UNSIGNED;
    // may escape code
    valueTypes.DOUBLE = DOUBLE;
    valueTypes.FIXNUM = FIXNUM;
    valueTypes.SIGNED = SIGNED;
    valueTypes.EXTERN = EXTERN;


    var validator = Object.create(null);
    // contains the functions like parser, tokenizer, evaluation
    validator.FunctionDeclaration = FunctionDeclaration;
    validator.VariableDeclaration = VariableDeclaration;

    function validateAST(ast, validate) {
        var result;
        switch (ast.type) {
            case "Program":
                var body = node.body;
                var len = node.body.length;
                for (var i = 0; i  < len; i++) {
                    if (!(result = validate(body[i]))) return result;
                }
            case "ExpressionStatement":
                if (!(result = validate(node.expression))) return result;
                break;
            case "AssignmentExpression":
                if (!(result = validate(node))) return result;
                break;
            case "BinaryExpression":
                if (!(result = validate(node))) return result;
                break;
            default:
                throw new SyntaxError("can not validate " + node.type);
        }
        return result;
    }
    exports.getTypeOfParameter = getTypeOfParameter;
    exports.getTypeOfReturnStatement  = getTypeOfReturnStatement;
    exports.getTypeOfVariableDeclaration = getTypeOfVariableDeclaration;

    exports.isLeftAndRightSameIdentifier = isLeftAndRightSameIdentifier;
    exports.validateAST = validateAST;
    exports.validate = validate;
    exports.validator = validator;
    exports.valueTypes = valueTypes;



});
/**
 * this compiler deconstructs the ast into INT Code.
 * I hope to refactor it into BYTECODE.
 * (much) later it should be valid numeric code to be run inside an asm js module.
 * the STACKTOP is count in BYTES.
 * the pointers are stored as STACKTOP >> 2 (means times 4) for INTs
 *
 * I notice that BINEXPR, ASSIGNEXPR, CALLEXPR,
 * which take just two arguments can loose their heading code
 * and just store ptr to left, bytecode for load result into r1, ptr to right, bytecode to load result into r2, bytecode for operation of r1, r2
 * currently i emit another header int
 *  (the instruction set can be refactored into regular assembly, i just got behind)
 *
 * i see, the "node.type" gets lost when creating bytecode.
 * repeating patterns just make some loads/register transfers necessary
 * which can be done with the same code
 *
 * i switched from registers back to stack machine and i am
 * unsure which way to go, registers anyway make a pushreg and popreg
 * necessary, and the operandstack has the same problem. otherwise
 * sometimes i don´t need to save the registers ;)
 * i don´t know exactly, what the outcome will be, but i am sure, that
 * overworking the code will result in a typical bytecode with load,
 * store, add, branch, ifeq, iflt, ifgt or what their names are and i
 * think i´ll soon get it to design these codes.
 *
 */

define("asm-compiler", function (require, exports) {

    "use strict";
    var format = require("i18n").format;

    var DEFAULT_SIZE = 2*1024*1024; // 2 Meg of RAM (string, id, num) should be big enough to run this program
    var POOL, pp, poolDupeMap;
    var MEMORY, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAPU32, HEAP32, HEAPF32, HEAPF64;
    var STACKBASE, STACKSIZE, STACKTOP;
    /**
     * first bytecodes
     * currently intcodes
     *
     * the compiler and the interpreter will go through a few refactorings
     * i see instructions/annotations which are not needed anymore and could be replaced
     */
    var PRG = 0x05;
    var SLIST = 0x06;
    var STR = 0x10;     // A Uint16 encoded with length first (about 8 bytes longer than the string)
    var NUM = 0x11;       // A Float64 with alignment (about 12 bytes)
    var NUL = 0x12;
    var UNDEF = 0x13;
    var STRCONST = 0x15;  // load string from constant pool (index next nr)
    var NUMCONST = 0x16;  // load number from constant pool
    var IDCONST = 0x17;  // load identifername from constant pool (index is next int)
    var TRUEBOOL = 0x20;       // BooleanLiteral "true"  (know the code, choose register)
    var FALSEBOOL = 0x21;      // BooleanLiteral "false" (know the code, choose register)
    var EXPRSTMT = 0x33;
    var PARENEXPR = 0x34;
    var SEQEXPR = 0x35;
    var UNARYEXPR = 0x36;
    var UNARYOP = 0x37;
    var POSTFIXOP = 0x38;
    var VARDECL = 0x40;
    var IFEXPR = 0x61;
    var IFOP = 0x62;
    var WHILESTMT = 0x63;
    var WHILEBODY = 0x64;
    var DOWHILESTMT = 0x65;
    var DOWHILECOND = 0x66;
    var BLOCKSTMT = 0x67;
    
    var ASSIGNEXPR  = 0xA0;
    var ASSIGNMENTOPERATOR = 0xA1;
    var BINEXPR = 0xB0;
    var LOAD1   = 0xB1;
    var LOAD2   = 0xB2;
    var BINOP   = 0xB3;
    var CALLEXPR = 0xC0;
    var CALL = 0xC1;
    var NEWEXPR = 0xC2;
    var CONSTRUCT = 0xC3;
    var FUNCDECL = 0xC4;
    var ARGLIST = 0xC6;

    var ARRAYEXPR = 0xD1;
    var ARRAYINIT = 0xD2;
    var OBJECTEXPR = 0xD4;
    var PROPDEF = 0xD5;
    var OBJECTINIT = 0xD6;
    var RET = 0xD0;
    var DEBUGGER = 0xFA;

    var ERROR = 0xFE;
    var HALT = 0xFF;
    var EMPTY = -0x01;  // negative can not point into something

    var PUSH = 0xE0;
    var PUSH2 = 0xE1;
    var PUSH3 = 0xE2;

    var ADD = 0x70; // +
    var SUB = 0x71; // -
    var MUL = 0x72; // *
    var DIV = 0x73; // /
    var MOD = 0x74; // %
    var AND = 0x75; // &
    var OR  = 0x76; // |
    var NOT = 0x77; // !
    var L_OR = 0x78; // ||
    var L_AND = 0x79; // &&
    var GT = 0x7A; // >
    var LT = 0x7B  // <
    var GT_EQ = 0x7C; // >=
    var LT_EQ = 0x7D; // <=
    var EQ =    0x80;   // ==
    var STRICT_EQ = 0x81; // ===
    var NOT_EQ = 0x82;  // !=
    var STRICT_NOT_EQ = 0x83; // !==
    var SHL = 0x84;     // <<
    var SHR  = 0x85;    // >> 
    var SSHR = 0x86;    // >>>

    var A_ADD = 0xE3; // +
    var A_SUB = 0xE4; // -
    var A_MUL = 0xE5; // *
    var A_DIV = 0xE6; // /
    var A_MOD = 0xE7; // %
    var A_SHR = 0x87;   // <<=
    var A_SHL = 0x88;   // >>=
    var A_SSHR = 0x89;  // >>>=
    
    var REST = 0x90; // rest and spread "..." ? own instruction is cool, or? if i don´t find a common replacement
    var SPREAD = 0x91;
    var ASSIGN = 0xA2;  // =

    var IFLT = 0x93;   // if (??? < ???)
    var IFGT = 0x94;   // >
    var IFCMP = 0x95;  // if ()
    var IFNOTCMP = 0x96;   // if(!)
    



    var tables = require("tables");
    var propDefKinds = tables.propDefKinds;
    var propDefCodes = tables.propDefCodes;
    var codeForOperator = tables.codeForOperator;
    var operatorForCode = tables.operatorForCode;
    var unaryOperatorFromString = tables.unaryOperatorFromString;

    /**
     * initialize the compiler for a new compilation
     * after compilation use exports.get() to get the data
     *
     * @param stackSize
     */
    function init(stackSize, poolSize) {
        POOL = Array(poolSize||10000);
        pp = -1;
        poolDupeMap = Object.create(null); // dupe check for identifiers, etc.
        MEMORY = new ArrayBuffer(stackSize||1024*1024);
        HEAP8 = new Int8Array(MEMORY);
        HEAPU8 = new Uint8Array(MEMORY);
        HEAP16 = new Int16Array(MEMORY);
        HEAPU16 = new Uint16Array(MEMORY);
        HEAP32 = new Int32Array(MEMORY);
        HEAPU32 = new Uint32Array(MEMORY);
        HEAPF32 = new Float32Array(MEMORY);
        HEAPF64 = new Float64Array(MEMORY);
        STACKBASE = 0;
        STACKSIZE = stackSize;
        STACKTOP = 0;
    }
    /**
     * get returns the compiled data, the heap, the constant pool, the stacksize and stacktop
     * @returns {{POOL: *, HEAP32: *, STACKSIZE: *, STACKTOP: *}}
     *
     */
    function get() {
        return {
            POOL: POOL,
            pp: pp,
            poolDupeMap: poolDupeMap,
            MEMORY: MEMORY,
            HEAP8: HEAP8,
            HEAPU8: HEAPU8,
            HEAP16: HEAP16,
            HEAPU16: HEAPU16,
            HEAPU32: HEAPU32,
            HEAP32: HEAP32,
            HEAPF32: HEAPF32,
            HEAPF64: HEAPF64,
            STACKBASE: STACKBASE,
            STACKSIZE: STACKSIZE,
            STACKTOP: STACKTOP
        };
    }
    /**
     * add a value to the constant pool
     * the index of the value in the array is returned
     * i don´t check for dupes, so two stringliterals with
     * the same value get added twice
     *
     * This is something external, the integer for the poolIndex
     * can be passed around, the rest must happen outside of the
     * fast interpreter block (that will still save us some ms)
     *
     * @param value
     * @returns {number}
     */
    function addToConstantPool(value) {
        var poolIndex;
        if (poolIndex=poolDupeMap[value]) return poolIndex;
        POOL[++pp] = value;
        return pp;
    }
    /**
     * @param node
     * @returns {*}
     */
    function identifier (node) {
        var poolIndex = addToConstantPool(node.name);
        var ptr = STACKTOP >> 2;
        HEAP32[ptr] = IDCONST;
        HEAP32[ptr+1] = poolIndex;
        STACKTOP += 8;
        //console.log("compiled identifier to " + ptr);
        return ptr;
    }
    /**
     * @param node
     * @returns {*}
     */
    function numericLiteralPool (node) {
        var poolIndex = addToConstantPool(node.value);
        var ptr = STACKTOP >> 2;
        HEAP32[ptr] = NUMCONST;
        HEAP32[ptr+1] = poolIndex;
        STACKTOP += 8;
        //console.log("compiled numericLiteral to " + ptr);
        return ptr;
    }

    /**
     * this stores a number as float directly where it appears
     * the Pool version pushes the value into an array and is not
     * what i would prefer
     *
     * @param node
     * @returns {*}
     */
    function numericLiteral(node) {
        var value = node.computed;
        if (value === undefined) value = +node.value;
        var align;
        align = STACKTOP % 8;
        if (align === 0) STACKTOP += 4;
        var ptr = STACKTOP >> 2;
        STACKTOP+=12;
        HEAP32[ptr] = NUM;
        HEAPF64[(ptr+1)>>1] = value;
        //console.log("compiled numlit to " + ptr);
        return ptr;
    }

    function stringLiteral(node) {
        var str = node.computed;
        if (str === undefined) str = str.slice(1, str.length-2);
        var ptr = STACKTOP >> 2;
        // 1. encode into code points, that i can find pairs.
        var codePoints = [];
        for (var i = 0, j = str.length; i < j; i++) {
            // perform codeunit check
            var cu = str[i].charCodeAt(0);
            // if (between 0x800 && ... i forgot it ten times)
            codePoints.push(cu);
        }
        // and then write them into the heap
        var len = codePoints.length;
        // because str.length && codePoints.length could differ
        STACKTOP += (8 + Math.ceil(len>>1));
        HEAP32[ptr] = STR;
        HEAP32[ptr+1] = len;
        var ptr2 = (ptr+2)<<1;
        for (var i = 0; i < len; i++) HEAPU16[ptr2+i] = codePoints[i];
        //console.log("compiled str to " + ptr);
        return ptr;
    }

    /**
     * stringLiteral
     * 1. obtain ptr from STACKTOP;
     * 2. add node.value to the constant pool and get poolIndex
     * 3. write poolIndex into the HEAP
     * 4. increase STACKTOP
     * @param node
     */
    function stringLiteralPool (node) {
        addToConstantPool(node.computed);
        var poolIndex = pp;
        var ptr = STACKTOP >> 2;
        HEAP32[ptr] = STRCONST;
        HEAP32[ptr+1] = poolIndex;
        STACKTOP += 8;
        //console.log("compiled stringLiteral to " + ptr);
        return ptr;
    }
    /**
     * @param node
     * @returns {*}
     */
    function booleanLiteral(node) {
        var ptr = STACKTOP >> 2;
        if (node.value === "true") HEAP32[ptr] = TRUEBOOL;
        else HEAP32[ptr] = FALSEBOOL;
        STACKTOP += 4;
        //console.log("compiled boolean to " + ptr);
        return ptr;
    }
    /**
     * I really compile the node.expression
     * into one slot.
     * @param node
     * @returns {number}
     */

    /*


        best is to read a little x86 assembly and jvm bytecode next
        to get a better instruction set together. i don´t want to take
        it, it should become developed out of the existing. but it´s better
        to take some real world bytecode names, than redefining nodenames
        so i better learn a bit more about
        (and i am glad that i am later able to write assembly and jvm bytecode, ehe)

     */


    function expressionStatement(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 8;
        HEAP32[ptr] = EXPRSTMT;
        HEAP32[ptr+1] = compile(node.expression);
        //console.log("compiled expr stmt to " + ptr);
        return ptr;
    }

    function parenthesizedExpression(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 8;
        HEAP32[ptr] = PARENEXPR;
        HEAP32[ptr+1] = compile(node.expression);
        //console.log("compiled paren expr to " + ptr);
        return ptr;
    }

    /**
     * @param node
     * @returns {*}
     */
    function sequenceExpression(node) {
        var ptr = STACKTOP >> 2;
        var len = node.sequence.length
        HEAP32[ptr] = SEQEXPR;
        HEAP32[ptr+1] = len|0;
        STACKTOP += 8 + (len << 2);
        for (var i = 0; i < len; i++) HEAP32[ptr+2+i] = compile(node.sequence[i]);
        //console.log("compiled seq expr stmt to " + ptr);
        return ptr;
    }

    /**
     * @param node
     */
    function assignmentExpression1(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 20;
        HEAP32[ptr] = ASSIGNEXPR;
        HEAP32[ptr+1] = compile(node.left);
        HEAP32[ptr+2] = compile(node.right);
        HEAP32[ptr+3] = ASSIGNMENTOPERATOR;
        HEAP32[ptr+4] = codeForOperator[node.operator];
        //console.log("compiled assign expr to " + ptr);
        return ptr;
    }

    function assignmentExpression(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 16;
        HEAP32[ptr] = PUSH3;
        HEAP32[ptr+1] = compile(node.right);
        HEAP32[ptr+2] = compile(node.left);
        var code;
        switch (node.operator) {
            case "=": code = ASSIGN; break;
            case "+=": code = A_ADD; break;
            case "-=": code = A_SUB; break;
            case "*=": code = A_MUL; break;
            case "/=": code = A_DIV; break;
            case "%=": code = A_MOD; break;
            case "<<=": code = A_SHL; break;
            case ">>=": code = A_SHR; break;
            case ">>>=": code = A_SSHR; break;
        }
        HEAP32[ptr+3] = code;

        return ptr;
    }

    function unaryExpression(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 12;
        if (node.prefix)
            HEAP32[ptr] = UNARYEXPR;
        HEAP32[ptr+1] = compile(node.argument);
        if (node.prefix) HEAP32[ptr+2] = UNARYOP;
        else HEAP32[ptr+2] = POSTFIXOP;
        HEAP32[ptr+2] = unaryOperatorFromString[node.operator];
        //console.log("compiled unary expr to " + ptr);
        return ptr;
    }
    /**
     *
     */

    function binaryExpression1(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 20;
        HEAP32[ptr] = BINEXPR;
        HEAP32[ptr+1] = compile(node.right);
        HEAP32[ptr+2] = compile(node.left);
            HEAP32[ptr+3] = BINOP;
                HEAP32[ptr+4] = codeForOperator[node.operator];
                //console.log("compiled binary expr to " + ptr);
                return ptr;
        }


    function binaryExpression(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 16;
        HEAP32[ptr] = PUSH3;
        HEAP32[ptr+1] = compile(node.right);
        HEAP32[ptr+2] = compile(node.left);
        var code;
        switch (node.operator) {
            case "==": code = EQ; break;
            case "===": code = STRICT_EQ; break;
            case "!=": code = NOT_EQ; break;
            case "!==": code = STRICT_NOT_EQ; break;
            case "+": code = ADD; break;
            case "-": code = SUB; break;
            case "*": code = MUL; break;
            case "/": code = DIV; break;
            case "%": code = MOD; break;
            case "<<": code = SHL; break;
            case ">>": code = SHR; break;
            case "|": code = OR; break;
            case "&": code = AND; break;
            case "&&": code = L_AND; break;
            case "||": code = L_OR; break;
            case "<": code = LT; break;
            case ">": code = GT; break;
            case ">=": code = GT_EQ; break;
            case "<=": code = LT_EQ; break;
        }
        HEAP32[ptr+3] = code; // push3 loads the stack with the next 3 positions
        return ptr;
    }
    /**
     *
     * @param node
     * @returns {*}
     */

    function callExpression(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 16;
        HEAP32[ptr] = PUSH3;
        HEAP32[ptr+1] = argumentList(node.arguments);
        HEAP32[ptr+2] = compile(node.callee);
        HEAP32[ptr+3] = CALL;
        //console.log("compiled call expr to " + ptr);
        return ptr;
    }
    /**
     *
     * @param node
     */
    function newExpression(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 16;
        HEAP32[ptr] = NEWEXPR;
        HEAP32[ptr+1] = compile(node.callee);
        HEAP32[ptr+2] = argumentList(node.arguments);
        HEAP32[ptr+3] = CONSTRUCT;
        //console.log("compiled new expr to " + ptr);
        return ptr;
    }

    /*
    function argumentList(list) {
        var len = list.length;
        var ptr = STACKTOP >> 2;
        HEAP32[ptr] = ARGLIST;
        HEAP32[ptr+1] = len|0;
        STACKTOP += 8 + (len << 2);
        for (var i = 0; i < len; i++) {
            HEAP32[ptr+i] = compile(list[i]);
        }
        //console.log("compiled arguments List with length of "+len+ " to "+ ptr)
        return ptr;
    }
    */

    function argumentList(list) {
        var poolIndex = ++pp;
        POOL[pp] = list;
        var ptr = STACKTOP >> 2;
        STACKTOP += 8;
        HEAP32[ptr] = ARGLIST;
        HEAP32[ptr+1] = poolIndex;
        return ptr;
    }


    function formalParameters(list) {
        var poolIndex = ++pp;
        POOL[pp] = list;
        var ptr = STACKTOP >> 2;
        STACKTOP += 4;
        HEAP32[ptr] = poolIndex;
        return ptr;
    }

    function functionDeclaration(node) {
        POOL[++pp] = node;
        var poolIndex = pp;
        var ptr = STACKTOP;
        STACKTOP += 8;
        HEAP32[ptr] = FUNCDECL;
        HEAP32[ptr+1] = poolIndex;
        //console.log("compiled fdecl to " + ptr);
        return ptr;
    }

    function variableDeclaration(node) {
        POOL[++pp] = node;
        var poolIndex = pp;
        var ptr = STACKTOP;
        STACKTOP += 8;
        HEAP32[ptr] = VARDECL;
        HEAP32[ptr+1] = poolIndex;
        //console.log("compiled var decl to " + ptr);
        return ptr;
    }

    function propertyDefinition(node) {
        var ptr = STACKTOP >> 2;
        POOL[++pp] = node.key;
        var keyIndex = pp;
        STACKTOP += 16;
        HEAP32[ptr] = PROPDEF;
        HEAP32[ptr+1] = propDefKinds[node.kind];
        HEAP32[ptr+2] = keyIndex;
        HEAP32[ptr+3] = compile(node.value);
        //console.log("compiled prop def to " + ptr);
        return ptr;
    }

    function objectExpression(node) {
        var ptr = STACKTOP >> 2;
        var len = node.elements.length;
        STACKTOP += 8 + (len<<2);
        HEAP32[ptr] = OBJECTEXPR;
        HEAP32[ptr+1] = len;
        for (var i = 0; i < len; i++) HEAP32[ptr+1+i] = compile(node.properties[i]);
        //console.log("compiled object expr to " + ptr);
        return ptr;
    }

    function arrayExpression(node) {
        var ptr = STACKTOP >> 2;
        var len = node.elements.length;
        STACKTOP += 8 + (len<<2);
        HEAP32[ptr] = ARRAYEXPR;
        HEAP32[ptr+1] = len;
        for (var i = 0; i < len; i++) HEAP32[ptr+1+i] = compile(node.elements[i]);
        //console.log("compiled array expr to " + ptr);
        return ptr;
    }

    function elision(ast) {
        var ptr = STACKTOP >> 2;
        var width = node.width;
        STACKTOP+=8;
        HEAP32[ptr] = ELISION;
        HEAP32[ptr+1] = width;
        //console.log("compiled elision to " + ptr);
        return ptr;
    }

    function returnStatement(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 8;
        HEAP32[ptr] = RET;
        if (node.argument)
            HEAP32[ptr+1] = compile(node.argument);
        else HEAP32[ptr+1] = EMPTY;
        //console.log("compiled return to " + ptr);
        return ptr;
    }

    function ifStatement(node) {
        var ptr = STACKTOP >> 2;
        STACKTOP += 20;
        HEAP32[ptr] = IFEXPR;
        HEAP32[ptr+1] = compile(node.test);
        HEAP32[ptr+2] = IFOP;
        HEAP32[ptr+3] = compile(node.consequent);
        HEAP32[ptr+4] = compile(node.alternate);
        //console.log("compiled new expr to " + ptr);
        return ptr;
    }

    /**
     * the block
     * has a code
     * a length
     * and slots with ptrs to each stmt
     * @param node
     * @returns {*}
     */

    function blockStatement(node) {
        var len = node.body.length;
        var body = node.body;
        var ptr = STACKTOP >> 2;
        STACKTOP += 8 + (len << 2);
        HEAP32[ptr] = BLOCKSTMT;
        HEAP32[ptr+1] = len|0;
        for (var i = 0, j = len; i < j; i++) HEAP32[ptr+2+i] = compile(body[i]);
        //console.log("compiled block to " + ptr);
        return ptr;
    }

    function whileStatement(node) {
        var len = node.body.length;
        var body = node.body;
        var ptr = STACKTOP >> 2;
        STACKTOP += 20+(len<<2);
        HEAP32[ptr] = WHILESTMT;
        HEAP32[ptr+1] = compile(node.test);
        HEAP32[ptr+2] = WHILEBODY;
        HEAP32[ptr+3] = len;
        for (var i = 0, j = len; i < j; i++) HEAP32[ptr+4+i] = compile(body[i]);
        HEAP32[ptr+4+len] = ptr;
        //console.log("compiled while to " + ptr);
        return ptr;
    }

    function doWhileStatement(node) {
        var len = node.body.length;
        var body = node.body;
        var ptr = STACKTOP >> 2;
        STACKTOP += 20+(len<<2);

        HEAP32[ptr] = DOWHILESTMT;
        HEAP32[ptr+1] = len;
        for (var i = 0, j = len; i < j; i++) HEAP32[ptr+2+i] = compile(body[i]);
        HEAP32[ptr+2+len] = compile(node.test);

        var ptr2 = ptr+2+len;
        HEAP32[ptr2] = DOWHILECOND;
        HEAP32[ptr2+1] = ptr;
        //console.log("compiled doWhile to " + ptr);
        return ptr;
    }


    /**
     *
     * @param node
     * @returns {*}
     */
    function program(node) {
        var body = node.body;
        var strict = !!node.strict;
        var len = body.length;
        var ptr = STACKTOP >> 2; // /4
        HEAP32[ptr] = PRG;          // "Program"
        HEAP32[ptr+1] = strict|0;   // node.strict
        HEAP32[ptr+2] = len|0;        // body.length
        STACKTOP += 12;             //
        STACKTOP += (len << 2);   // *4
        for (var i = 0, j = len; i < j; i++) {
            HEAP32[ptr+3+i] = compile(body[i]);// fill array with starting offsets
        }
        //console.log("compiled prg expr to " + ptr);
        return ptr;
    }

    /**
     *
     * @param ast
     * @returns {number}
     */


    function forStatement (node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function forInOfStatement (node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }

    function switchStatement(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function switchCase(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function defaultCase(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function tryStatement(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function catchClause(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function finally_(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function objectPattern(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function arrayPattern(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function moduleDeclaration(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }
    function importStatement(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }

    function exportStatement(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }

    function throwStatement(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }

    function breakStatement(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }

    function continueStatement(node) {
        var ptr = STACKTOP >> 2;
        return ptr;
    }

    function debuggerStatement(node) {
        var ptr = STACKTOP >> 2;
        HEAP32[ptr] = DEBUGGER;
        return ptr;
    }


    function compile(ast) {
        if (!ast) return -1;
        switch (ast.type) {
            case "StringLiteral":           return stringLiteral(ast);
            case "Identifier":              return identifier(ast);
            case "NumericLiteral":          return numericLiteral(ast);
            case "Program":                 return program(ast);
            case "BooleanLiteral":          return booleanLiteral(ast);
            case "ExpressionStatement":     return expressionStatement(ast);
            case "AssignmentExpression":    return assignmentExpression(ast);
            case "BinaryExpression":        return binaryExpression(ast);
            case "CallExpression":          return callExpression(ast);
            case "NewExpression":           return newExpression(ast);
            case "ReturnStatement":         return returnStatement(ast);
            case "ParenthesizedExpression": return parenthesizedExpression(ast);
            case "SequenceExpression":      return sequenceExpression(ast);
            case "UnaryExpression":         return unaryExpression(ast);
            case "IfStatement":             return ifStatement(ast);
            case "BlockStatement":          return blockStatement(ast);
            case "WhileStatement":          return whileStatement(ast);
            case "DoWhileStatement":        return doWhileStatement(ast);
            case "FunctionDeclaration":     return functionDeclaration(ast);
            case "VariableDeclaration":     return variableDeclaration(ast);
            case "ObjectExpression":        return objectExpression(ast);
            case "PropertyDefinition":      return propertyDefinition(ast);
            case "ArrayExpression":         return arrayExpression(ast);
            case "Elision":                 return elision(ast);
            case "SwitchStatement":         return switchStatement(ast);
            case "SwitchCase":              return switchCase(ast);
            case "DefaultCase":             return defaultCase(ast);
            case "TryStatement":            return tryStatement(ast);
            case "CatchClause":             return catchClause(ast);
            case "Finally":                 return finally_(ast);
            case "ForStatement":            return forStatement(ast);
            case "ForInStatement":
            case "ForOfStatement":          return forInOfStatement(ast);
            case "ModuleDeclaration":       return moduleDeclaration(ast);
            case "ImportStatement":         return importStatement(ast);
            case "ExportStatement":         return exportStatement(ast);
            case "ThrowStatement":          return throwStatement(ast);
            case "BreakStatement":          return breakStatement(ast);
            case "ContinueStatement":       return continueStatement(ast);
            case "DebuggerStatement":       return debuggerStatement(ast);
            default:
                throw new TypeError(format("NO_COMPILER_FOR_S", ast && ast.type));
        }
    }
    /**
     * spent thirty seconds for showing how to use the compiler
     * @param ast
     * @returns {{POOL: *, HEAP32: *, STACKSIZE: *, STACKTOP: *}}
     */
    function compileUnit(ast) {
        init(DEFAULT_SIZE); // invent a good guess and a resize for the emergency case
        compile(ast);
        return get();
    }
    /**
     * the steps are to call init, compile and get
     * and to unify it i add the method compileUnit
     * @type {null}
     */
    exports.init = init;
    exports.compile = compile;
    exports.get = get;
    exports.compileUnit = compileUnit;
});


/**
 *
 *  there is a difference between
 *  operand stack and a push of the result onto
 *
 *  or a r0 for result
 *  and a copy to r1 or r2 with and extra instruction
 *
 *  the same for the node.type headers, they can be factored out
 *
 *
 *
 */

define("vm", function (require, exports) {


    var realm, strict, tailCall;

    var compiler = require("asm-compiler");

    var tables = require("tables");
    var codeForOperator = tables.codeForOperator;
    var operatorForCode = tables.operatorForCode;
    var unaryOperatorFromCode = tables.unaryOperatorFromCode;
    var propDefCodes = tables.propDefCodes;
    var detector = require("detector");
    var hasConsole = detector.hasConsole;

    /**
     * intl functions to translate messages from the beginning on
     * @type {Function|format}
     */

    var format = require("i18n").format;
    var formatStr = require("i18n").formatStr;
    var trans = require("i18n").trans;

    /**
     * this is just the bytecode memory
     */
    var POOL;
    var pp;
    var poolDupeMap;
    var MEMORY;
    var HEAP8;
    var HEAPU8;
    var HEAP16;
    var HEAPU16;
    var HEAP32;
    var HEAPU32;
    var HEAPF32;
    var HEAPF64;
    var STACKBASE;
    var STACKTOP;
    var STACKSIZE;


    /**
     * call frames (execution context)
     * @type {Array}
     */
    var frames =  new Array(1000);
    var fp = -1;
    var frame;

    /**
     * global operandStack
     * @type {Array}
     */

    var operands = new Array(1000);
    var sp = -1;


    /**
     * global registers
     */

    var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
    var reg = Array(10);
    var regs = [[],[],[],[],[],[],[],[],[],[],[]];  // if you have no operand stack, you need to save the regs.
    // here i have to deal with javascript objects
    // for a while.

    // hmm, maybe, i should next try to rewrite the object on the heap
    // or just point outside to the pool, where the object will not be
    // gc´ed. Btw. it could be watched if it needs deletion there, i think
    // it was seen and forgotten. Delete from pool if it needs collection.

    // well, ObjectCreate() shall no longer return an object ordinary object
    // but a memory location with, e.g. first a const pool index, where the new
    // object exists, so i can smuggle the HEAP32 into the running system on the
    // AST. nobody will care for the ms. It´s anyways the slowest es6 available ;-)

    function pushReg(nr) {
        regs[nr].push(reg[nr]);
    }

    function popReg(nr) {
        reg[nr] = regs[nr].pop();
    }

    /**
     * @type {number}
     */

    var PRG = 0x05;
    var SLIST = 0x06;
    var STR = 0x10;     // A Uint16 encoded with length first (about 8 bytes longer than the string)
    var NUM = 0x11;       // A Float64 with alignment (about 12 bytes)
    var NUL = 0x12;
    var UNDEF = 0x13;
    var STRCONST = 0x15;  // load string from constant pool (index next nr)
    var NUMCONST = 0x16;  // load number from constant pool
    var IDCONST = 0x17;  // load identifername from constant pool (index is next int)
    var TRUEBOOL = 0x20;       // BooleanLiteral "true"  (know the code, choose register)
    var FALSEBOOL = 0x21;      // BooleanLiteral "false" (know the code, choose register)
    var EXPRSTMT = 0x33;
    var PARENEXPR = 0x34;
    var SEQEXPR = 0x35;
    var UNARYEXPR = 0x36;
    var UNARYOP = 0x37;
    var POSTFIXOP = 0x38;
    var VARDECL = 0x40;
    var IFEXPR = 0x61;
    var IFOP = 0x62;
    var WHILESTMT = 0x63;
    var WHILEBODY = 0x64;
    var DOWHILESTMT = 0x65;
    var DOWHILECOND = 0x66;
    var BLOCKSTMT = 0x67;

    var ASSIGNEXPR  = 0xA0;
    var ASSIGNMENTOPERATOR = 0xA1;
    var BINEXPR = 0xB0;
    var LOAD1   = 0xB1;
    var LOAD2   = 0xB2;
    var BINOP   = 0xB3;
    var CALLEXPR = 0xC0;
    var CALL = 0xC1;
    var NEWEXPR = 0xC2;
    var CONSTRUCT = 0xC3;
    var FUNCDECL = 0xC4;
    var ARGLIST = 0xC6;
    var ARRAYEXPR = 0xD1;
    var ARRAYINIT = 0xD2;
    var OBJECTEXPR = 0xD4;
    var PROPDEF = 0xD5;
    var OBJECTINIT = 0xD6;
    var RET = 0xD0;

    var DEBUGGER = 0xFA;
    var ERROR = 0xFE;
    var HALT = 0xFF;
    var EMPTY = -0x01;  // negative can not point into something


    var PUSH = 0xE0;
    var PUSH2 = 0xE1;
    var PUSH3 = 0xE2;

    var ADD = 0x70; // +
    var SUB = 0x71; // -
    var MUL = 0x72; // *
    var DIV = 0x73; // /
    var MOD = 0x74; // %
    var AND = 0x75; // &
    var OR  = 0x76; // |
    var NOT = 0x77; // !
    var L_OR = 0x78; // ||
    var L_AND = 0x79; // &&
    var GT = 0x7A; // >
    var LT = 0x7B  // <
    var GT_EQ = 0x7C; // >=
    var LT_EQ = 0x7D; // <=
    var EQ =    0x80;   // ==
    var STRICT_EQ = 0x81; // ===
    var NOT_EQ = 0x82;  // !=
    var STRICT_NOT_EQ = 0x83; // !==
    var SHL = 0x84;     // <<
    var SHR  = 0x85;    // >>
    var SSHR = 0x86;    // >>>

    var A_ADD = 0xE3; // +
    var A_SUB = 0xE4; // -
    var A_MUL = 0xE5; // *
    var A_DIV = 0xE6; // /
    var A_MOD = 0xE7; // %
    var A_SHR = 0x87;   // <<=
    var A_SHL = 0x88;   // >>=
    var A_SSHR = 0x89;  // >>>=

    var REST = 0x90; // rest and spread "..." ? own instruction is cool, or? if i don´t find a common replacement
    var SPREAD = 0x91;
    var ASSIGN = 0xA2;  // =

    var IFLT = 0x93;   // if (??? < ???)
    var IFGT = 0x94;   // >
    var IFCMP = 0x95;  // if ()
    var IFNOTCMP = 0x96;   // if(!)

    /**
     * i knew from the beginning on, later i will replace them
     * currently they will slow down and help a little within
     * the code until it becomes replacable
     * @type {exports}
     */

    var ecma = require("api");
    var parse = require("parser");
    var CodeRealm = ecma.CodeRealm;
    var CreateRealm = ecma.CreateRealm;
    var parseGoal = parse.parseGoal;
    var newTypeError = ecma.newTypeError;
    var newSyntaxError = ecma.newSyntaxError;
    var ifAbrupt = ecma.ifAbrupt;
    var isAbrupt = ecma.isAbrupt;
    var getRealm = ecma.getRealm;
    var getLexEnv = ecma.getLexEnv;
    var getContext = ecma.getContext;
    var GetIdentifierReference = ecma.GetIdentifierReference;
    var NormalCompletion = ecma.NormalCompletion;
    var applyBinOp = ecma.applyBinOp;
    var applyAssignmentBinOp = ecma.applyAssignmentBinOp;
    var EvaluateCall = EvaluateCall;
    var GetValue = ecma.GetValue;
    var PutValue = ecma.PutValue;
    var ExecutionContext = ecma.ExecutionContext;

    function getFromPool(index) {
        var $0 = POOL[index];
        operands[++sp] = $0;
    }

    /**
     * stack - contains the ip to the next instruction
     * should grow each statement list, and shrink each instruction
     * the program should halt (or run nextTask) if the stack is empty.
     *
     * This will be replaced by smarter calculations of offsets
     *
     */

    var stackBuffer, stack, pc;


    var states = [];    // save
    var MAINBODY = 2;
    var FUNCTIONCALL = 4;
    var GENERATOR = 8;
    var METHOD = 16;
    var CLASS = 32;
    var ARGLIST = 64;
    var ASSIGNMENT = 128;
    var OBJECTLITERAL = 256;
    var ARRAYLITERAL = 512;


    function main(pc) {
        "use strict";
        // local registers

        var $0,$1,$2,$3,$4,$5,$6,$7,$8,$9,$A,$B,$C,$D,$E,$F;

        //  var state = 0;

        do {
            var ip = stack[pc];
            var code = HEAP32[ip];
            switch (code) {
                case PUSH:
                    stack[pc++] = HEAP32[ip+1];
                    break;
                case PUSH2:
                    stack[pc++] = ip+2;
                    stack[pc++] = HEAP32[ip+1];
                    break;
                case PUSH3:
                    stack[pc++] = ip+3;
                    stack[pc++] = HEAP32[ip+2];
                    stack[pc++] = HEAP32[ip+1];
                    break;
                case PRG:
                    strict = HEAP32[ip + 1];
                    $1 = ip + 3;                    // first
                    $3 = HEAP32[ip + 2];            // len
                    $2 = $1 + $3 - 1;               // last
                    for (; $2 >= $1; $2--) stack[pc++] = HEAP32[$2];
                    break;

                case STR:

                    $3 = (ip+2) << 1;
                    $2 = HEAP32[ip+1];
                    $1 = HEAPU16.subarray($3, $3+$2);
                    $0 = String.fromCharCode.apply(undefined, $1);
                    operands[++sp] = $0;
                    break;
                case STRCONST:
                    $1 = HEAP32[ip + 1];
                    $0 = "" + POOL[$1];
                    operands[++sp] = $0;
                    break;
                case NUMCONST:
                    $1 = HEAP32[ip + 1];
                    $0 = +POOL[$1];
                    operands[++sp] = $0;
                    break;
                case IDCONST:
                    $1 = HEAP32[ip + 1];
                    $0 = GetIdentifierReference(getLexEnv(), POOL[$1], strict);
                    operands[++sp] = $0; // uses pool outside of the block
                    break;
                case TRUEBOOL:
                    operands[++sp] = true;  // JVM uses 0 and 1 integers for boolean
                    break;
                case FALSEBOOL:
                    operands[++sp] = false;
                    break;
                case NUM:
                    $0 = HEAPF64[(ip+1)>>1];
                    operands[++sp] = $0;
                    break;

                case ADD:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $4 + $2;
                    break;
                case SUB:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 - $4;
                    break;
                case MUL:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 * $4;
                    break;
                case DIV:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 / $4;
                    break;
                case MOD:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 % $4;
                    break;
                case AND:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 & $4;
                    break;
                case OR :
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 | $4;
                    break;
                case NOT:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($3=ifAbrupt($2))) {
                        operands[++sp] = $3;
                        return;
                    }
                    operands[++sp] = !$3;
                    break;
                case L_OR:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 || $4;
                    break;
                case L_AND:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 && $4;
                    break;
                case GT:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 > $4;
                    break;
                case LT:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 < $4;
                    break;
                case GT_EQ:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 >= $4;
                    break;
                case LT_EQ:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $1 + $2;
                    break;
                case EQ:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 == $4;
                    break;
                case STRICT_EQ:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 === $4;
                    break;
                case NOT_EQ:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 != $4;
                    break;
                case STRICT_NOT_EQ:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 !== $4;
                    break;
                case SHL:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 << $4;
                    break;
                case SHR:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $2 >> $4;
                    break;
                case SSHR:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    operands[++sp] = $1 >>> $2;
                    break;
                case A_SHR:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    // mit Assignment, heisst hier PutValue durchfuehren.
                    $5 = $2 >> $4;

                    $6 = PutValue($1, $5);
                    if (isAbrupt($6)) {
                        operands[++sp] = $6;
                        return;
                    }
                    operands[++sp] = $5;
                    break;
                case A_SHL:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    $5 = $2 << $4;
                    $6 = PutValue($1, $5);
                    if (isAbrupt($6)) {
                        operands[++sp] = $6;
                        return;
                    }
                    operands[++sp] = $5;
                    break;
                case A_SSHR:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    $5 = $2 >>> $4;

                    $6 = PutValue($1, $5);
                    if (isAbrupt($6)) {
                        operands[++sp] = $6;
                        return;
                    }
                    operands[++sp] = $5;
                    break;
                case ASSIGN:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    $5 = $4;
                    $6 = PutValue($1, $5);
                    if (isAbrupt($6)) {
                        operands[++sp] = $6;
                        return;
                    }
                    operands[++sp] = $5;
                    break;
                case A_ADD:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    $5 = $2 + $4;
                    $6 = PutValue($1, $5);
                    if (isAbrupt($6)) {
                        operands[++sp] = $6;
                        return;
                    }
                    operands[++sp] = $5;
                    break;
                case A_SUB:
                    $1 = operands[sp--];
                    $2 = GetValue($1);
                    if (isAbrupt($2=ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    $3 = operands[sp--];
                    $4 = GetValue($3);
                    if (isAbrupt($4=ifAbrupt($4))) {
                        operands[++sp] = $4;
                        return;
                    }
                    $5 = $2 - $4;
                    $6 = PutValue($1, $5);
                    if (isAbrupt($6)) {
                        operands[++sp] = $6;
                        return;
                    }
                    operands[++sp] = $5;
                    break;
                case IFLT:
                    $1 = operands[sp--];
                    $2 = operands[sp--];

                    break;
                case IFGT:
                    break;
                case IFCMP:
                    break;
                case IFNOTCMP:
                    break;
                case BLOCKSTMT:
                case SEQEXPR:
                    $1 = ip + 2;
                    $3 = HEAP32[ip + 1];
                    $2 = $1 + $3 - 1;
                    for (; $2 >= $1; $2--) stack[pc++] = HEAP32[$2];
                    break;
                case IFEXPR:
                    stack[pc++] = ip+2; // IFOP (compares r0 to true)
                    stack[pc++] = HEAP32[ip+1]; // eval test
                    break;
                case IFOP:
                    $0 = operands[sp--];
                    if (!!$0) stack[pc++] = HEAP32[ip+1];
                    else stack[pc++] = HEAP32[ip+2];
                    break;
                case EXPRSTMT:
                case PARENEXPR:
                    stack[pc++] = HEAP32[ip+1];
                    break;
                case BINEXPR:
                case ASSIGNEXPR:
                case NEWEXPR:
                case CALLEXPR:
                    stack[pc++] = ip+3;         // call
                    stack[pc++] = HEAP32[ip+2]; // ^args
                    stack[pc++] = HEAP32[ip+1]; // callee
                    break;
                case ARGLIST:
                    $1 = HEAP32[ptr+1]
                    operands[++sp] = POOL[$1];
                    break;
                case CALL:
                    // tailCall = HEAP32[ptr+1];
                    $1 = operands[sp--]; // callee
                    if (isAbrupt($1 = ifAbrupt($1))) {
                        operands[++sp] = $1;
                        return;
                    }
                    $2 = operands[sp--]; // args;
                    if (isAbrupt($2 = ifAbrupt($2))) {
                        operands[++sp] = $2;
                        return;
                    }
                    operands[++sp] = EvaluateCall($1, $2, tailCall);
                    break;

                case CONSTRUCT:
                    $2 = operands[sp--];
                    $1 = operands[sp--];
                    if (isAbrupt($1 = ifAbrupt($1))) $0 = $1;
                    else if (isAbrupt($2 = ifAbrupt($2))) $0 = $2;
                    else $0 = OrdinaryConstruct($1, $2);
                    operands[++sp] = $0;
                    break;

                case UNARYEXPR:
                    stack[pc++] = ip+2;         // prefix/postifx
                    stack[pc++] = HEAP32[ip+1]; // .arg
                    break;
                case UNARYOP:
                    $1 = HEAP32[ip+1]; // op
                    var $2 = operands[sp--];
                    $3 = GetValue($3);
                    if (isAbrupt($2 = ifAbrupt($2))) $0 = $2;
                    else $0 = applyUnaryOp(unaryOperatorFromCode[$1], true, $3);
                    operands[++sp] = $0;
                    break;
                case POSTFIXOP:
                    $1 = HEAP32[ip+1]; // op
                    $2 = operands[sp--];
                    $3 = GetValue($2)
                    if (isAbrupt(r2 = ifAbrupt(r2))) $0 = $2;
                    else $0 = applyUnaryOp(unaryOperatorFromCode[$1], false, $3);
                    operands[++sp] = $0;
                    break;

                case WHILESTMT:
                    stack[pc++] = ip+2;         // 2. goto whilebody
                    stack[pc++] = HEAP32[ip+1]; // 1. condition
                    break;
                case WHILEBODY:
                    $0 = !!operands[sp--]; // may not be in here. operands is DYNAMIC TYPED.

                    if ($0) {
                        $1 = ip + 2;            // first
                        $3 = HEAP32[ip + 1];    // len
                        $2 = $1 + $3 - 1;       // last
                        stack[pc++] = $2+1;     // wexpr
                        for (; $2 >= $1; $2--) stack[pc++] = HEAP32[$2];
                    }
                    break;
                case DOWHILESTMT:
                    $1 = ip + 2;            // first
                    $3 = HEAP32[ip + 1];    // len
                    $2 = $1 + $3 - 1;       // last
                    stack[pc++] = $2+1;     // dowhilebody
                    for (; $2 >= $1; $2--) stack[pc++] = HEAP32[$2];
                    break;
                case DOWHILECOND:
                    $0 = !!operands[sp--]; // this may not happen in here
                    if ($0) {
                        stack[pc++] = HEAP32[ip+1];
                    }
                    break;


                case ARRAYEXPR:
                case ARRAYINIT:


                case OBJECTEXPR:
                    break;
                case PROPDEF:
                    break;
                case OBJECTINIT:
                    break;
                case FUNCDECL:
                    break;
                case VARDECL:
                    break;

                case DEBUGGER:
                    ecma.debuggerOutput();
                    break;


                case HALT:
                    return;

                case ERROR:
                    operands[++sp] = newTypeError(format("UNKNOWN_ERROR"));
                    return;

                default:
                    operands[++sp] = newTypeError(format("UNKNOWN_INSTRUCTION_S", code));
                    return;
            }
            pc = pc - 1;
        } while (pc >= 0);
    }

    /**
     *
     * @param realm
     * @param src
     * @returns {*}
     * @constructor
     */

    function set(unit) {
        POOL = unit.POOL;
        pp = unit.pp;
        poolDupeMap = unit.poolDupeMap;
        MEMORY = unit.MEMORY;
        HEAP8 = unit.HEAP8;
        HEAPU8 = unit.HEAPU8;
        HEAP16 = unit.HEAP16;
        HEAPU16 = unit.HEAPU16;
        HEAPU32 = unit.HEAPU32;
        HEAP32 = unit.HEAP32;
        HEAPF32 = unit.HEAPF32;
        HEAPF64 = unit.HEAPF64;
        STACKBASE = unit.STACKBASE;
        STACKTOP = unit.STACKTOP;
        STACKSIZE = unit.STACKSIZE;
    }

    function init() {   // callstack up
        stackBuffer = new ArrayBuffer(4096 * 16);
        stack = new Int32Array(stackBuffer);
        ++fp;
        frame = frames[fp] = ExecutionContext(frames[fp-1]);
        frame.stackBuffer = stackBuffer;
        frame.stack = stack;
        frame.pc = pc;
    }

    function restore() {    // callstack down
        frame = frames[--fp];
        if (frame) {
            stack = frame.stack;
            stackBuffer = frame.stackBuffer;
            pc = frame.pc;
        }
    }


    function CompileAndRun(realm, src) {
        var ast;
        try {ast = parse(src)} catch (ex) {return newSyntaxError(ex.message)}
        var unit = compiler.compileUnit(ast);
        set(unit);
        init();
        pc = 0;
        stack[pc] = STACKBASE; // ip to first bytecode at HEAP32[stack[0]]
        main(pc);
        var $0 = operands[sp--];
        if (isAbrupt($0=ifAbrupt($0))) return $0;
        return NormalCompletion($0);
    }
    exports.CompileAndRun = CompileAndRun;

});	// is not asm. but renamable.

    // syntax highlighter (the original application of syntax.js)
    // will be rewritten soon, 
    // maybe with jquery for max effect with same simplicity


// *******************************************************************************************************************************
// Highlight (UI Independent Function translating JS into a string of spans)
// *******************************************************************************************************************************

define("highlight", function (require, exports) {

    "use strict";
    var tables = require("tables");
    var tokenize = require("tokenizer").tokenizeIntoArrayWithWhiteSpaces;

    var HighlighterClassNames = {
        __proto__: null,
        "Identifier": "syntaxjs-identifier",
        "NumericLiteral": "syntaxjs-number",
        "BooleanLiteral": "syntaxjs-boolean",
        "NullLiteral": "syntaxjs-null",
        "Keyword": "syntaxjs-keyword",
        "StringLiteral": "syntaxjs-string",
        "MultiLineComment": "syntaxjs-comment",
        "LineComment": "syntaxjs-comment",
        "FutureReservedWord": "syntaxjs-keyword",
        "RegularExpressionLiteral": "syntaxjs-regexp",
        "Punctuator": "syntaxjs-punctuator",
        "TemplateLiteral": "syntaxjs-template"
    };
    highlight.HighlighterClassNames = HighlighterClassNames;

    function stringifyTokens(array) {
        //        return array.join("");
        var string = "";
        for (var i = 0, j = array.length; i < j; i++) {
    	    string += array[i].value;
        }
        return string;
    }
    
    var parse;
    function highlight(text, options, rec) {
        var highlighted = [];
        var tokens, word, m, n, type;
        var wordcount;
        var cln;
        var el;
        var excp;
        var oid, rid;
        options = options || {};


        if (typeof text === "string" && typeof importScripts === "function") {
            el = null;
            rec = null;

        } else if (text === null && rec instanceof HTMLElement) {
            text = rec.innerText || rec.textContent || text.innerHTML;
            el = rec;
            rec = Object.create(null);
            rec.element = el;

        } else if (text === null && typeof rec === "object") {
            el = rec.element;
            text = rec.input || (el.innerText || el.textContent || el.innerHTML);
        }

        if (Array.isArray(text)) tokens = text;
        else {

            try {
                tokens = tokenize(text);
            } catch (ex) {
                excp = "\n<br>syntax.js exception: " + ex.name + "<br>\n" + ex.message + "\n<br>" + ("" + ex.stack).split("\n").join("<br>\n");
                if (el) el.innerHTML += excp;
                text += excp;
                return text;
            }

        }

        if (rec) {
            if (!rec.originalText) rec.originalText = text;
            rec.input = text;
            rec.tokens = tokens;
        }

	var val, val2;
        for (m = 0, n = tokens.length; m < n; m++) {
            type = tokens[m].type;
            word = tokens[m].value;
            //    oid = tokens[m]._oid_;

    	    switch(type) {
    	    case "RegularExpressionLiteral":
    		word = ("/"+word[0]+"/"+word[1]);
    		break;
	    case "TemplateLiteral":
		var val = word;
		
		word = "`";
		word += val[0];
		if (val.length > 1) {
		    for (var k = 1, l = val.length; k < l; k+=2) {
			word += "${" + val[k] + "}";
			val2 = val[k+1];
			if (val2 != undefined) word += val2;
		    }
		}
		word += "`";
    		break;
    	    }


            if (cln = HighlighterClassNames[type]) {
        	word = "<span class='" + cln + "'" + ">" + word + "</span>";
    	    }
            
            /*(oid?("data-syntaxjs-oid='"+oid+"'"):"")*/

            highlighted.push({
                type: type,
                value: word
            });
        }

        text = stringifyTokens(highlighted);

        if (rec) {
            rec.highlightedTokens = highlighted;
            rec.highlightedText = text;
        }

        if (el) el.innerHTML = text;
        return text;
    }

    exports.highlight = highlight;
    return exports;

});

define("annotations.de_DE", function (require, exports) {



    var classAnnotations= {
        "syntaxjs-comment": "Kommentar",
        "syntaxjs-string": "Ein Zeichenkette, String genannt",
        "syntaxjs-regexp": "Regulaerer Ausdruck",
        "syntaxjs-template": "TemplateStrings sind neu in ES6",
        "syntaxjs-number": "Der Number Type ist ein 64 Bit Floating Point mit 11 Bit Exponent und 53 Bit Mantisse. Das MSB steht für das Vorzeichen.",
        "syntaxjs-null": "Das NullLiteral ist der NULL-Pointer im JavaScript. Sein Boolean Wert ist false.",
        "syntaxjs-boolean": "Booleans stehen fuer 0 und 1 und koennen falsch oder wahr, false oder true sein. Damit kann man logische Verknuepfungen aufstellen.",
        "syntaxjs-identifier": "Identifier sind Bezeichner. Der Parser liest Labels, die mit einem Doppelpunkt enden als Identifier ein. Identifier sind in der Regel die Namen von Variablen, oder von Objekteigenschaften. Sie werden aufgeloest (sie zeigen auf einen Speicherbereich) und geben einen Datentypen zurueck. In JavaScript entweder einen Primitive Type wie true, false, null oder undefined, oder einen Reference Type wie Object. Identifier identifizieren Objekte oder Variablen."
    };

    var buttonNames = {
        __proto__: null,
        "eval": "Eval (Browser)",
        "original": "OriginalText",
        "linecount": "Zeilennummern",
        "editor": "Add/Hide Editor (Alpha)",
        "wordcount": "Wordcount",
        "minify": "Minifier",
        "token": "Tokens",
        "highlight": "Highlighted",
        "ast": "Abstract Syntax Tree",
        "value": "Evaluate(AST)",
        "infos": "Informationen",
        "source": "ToSource(AST)",
        "beauty": "Beautyfier",
        "shell": "shell input el"
    };

    var annotations = Object.create(null);
    annotations["&"] = "Bitweise UND Verknuepfung. Hier werden die Bits der Operanden (als int 1,2,4,8,16,...) einzeln verknuepft.";
    annotations["|"] = "Bitweise ODER Verknuepfung. Hier werden die Bits der Operanden  (als int 1,2,4,8,16,...) einzeln verknuepft.";
    annotations["<"] = "Kleiner als. Ist Links < Rechts ergibt true oder false";
    annotations[">"] = "Groesser als. Ist Links > Rechts ergibt true, ist Links groesser als Rechts, ansonsten false";
    annotations[">="] = "Groesser-Gleich. Ist Links groesser oder gleich Rechts ergibt der Ausdruck Links >= Rechts true, sonst false.";
    annotations["<="] = "Kleiner-Gleich. Ist Links kleiner oder gleich Rechts ergibt der Ausdruck Links &lt;= Rechts true, sonst false.";
    annotations["<<"] = "Left-Shift. Entspricht einer Multiplikation der linken Seite mit 2, so oft, wie rechts vom Operator steht. 1 << 3 === 1*2*2*2. 4 << 3 === 4*2*2*2. Links ueberlaufende Bits werden abgetrennt.";
    annotations[">>"] = "Right-Shift. Entspricht einer Division der linken Seite durch 2, so oft, wie rechts vom Operator steht. 10 >> 1 === 5. 1 >> 1 = 0. Rechts ueberlaufende Bits werden abgetrennt.";
    annotations["%"] = "Rest. Die Modulus Operation gibt den Rest. 15 % 8 ergibt 7. 2 % 1 ergibt 0. Mit n % 2 === 0 kann man testen, ob n gerade oder ungerade ist. Anders als in einigen anderen Sprachen gibt es hier ein Fliesskommaergebnis und nicht nur eine Integerzahl.";
    annotations[";"] = "Das Semikolon gibt das Ende eines Statements an. Oder kann als einzelnes EmptyStatement solo stehen.";
    annotations["..."] = "...rest steht fuer den RestParameter, der alle nicht definierten Parameter aufnimmt, die nach dem letzten definierten kommen. Und ...spread, die SpreadExpression, das Gegenstueck zu ...rest, ist aehnlich .apply, nur besser, und breitet einen Array abc=[1,2,3] bei f(...abc) auf f(1,2,3) aus und arbeitet auch bei Kontruktoren, was apply nicht kann, dass man ihnen mit ES6 dynamische Parameter zuweisen kann. Workaround fuer Parameter: options-Objekt statt benannte Parameter nehmen und nur einen new f({opt:true,opt2:false}) uebergeben.";
    annotations["undefined"] = "undefiniert, noch kein Wert zugewiesen oder letzter Wert geloescht";
    annotations["this"] = "this ist ein spezielles Wort, was auf das aktuelle, in dem man sich befindende, Objekt anzeigt. this kann mit call und apply explizit uebergeben werden. 'use strict' setzt this in globalen Funktionen auf undefined.";
    annotations["super"] = "super ist ein spezielles Wort, was in Klassen verfuegbar ist, und direkt auf das Objekt, von dem extended wird, zeigt und dessen Methoden ruft. Ruft man in einer Klassenmethode super, wird versucht, die gleiche Funktion beim Vater zu rufen.";
    annotations["void"] = "Der void UnaryOperator macht gar nichts und ergibt undefined. Er ist mitunter mal nuetzlich.";
    annotations["typeof"] = "Der typeof UnaryOperator findet raus, was der dahinterstehende Identifier oder das folgende Literal fuer ein Typ ist. typeof .77 === \"number\" oder typeof x === \"object\".";
    annotations["delete"] = "delete loescht eine Objekteigenschaft oder Variable und gibt im Erfolgsfall true zur&uuml;ck und im Versagensfall false.";
    annotations["const"] = "const gehoert zu den LexicalDeclarations und deklariert eine Read-Only Variable. Die kann man nur einmal setzen und nicht mehr ueberschreiben.";
    annotations["let"] = "let ist ab ES6 das neue var. Es ist Block-Scoped (blockweit sichtbar), wie man es von anderen Programmiersprachen kennt. let ist eine LexicalDeclaration.";
    annotations["=>"] = "Der => Pfeil nach einer (x,y) => {} oder einem Identifier wie bei x => x*x, leitet eine Arrow Function ein. Ohne Block {} haben sie ein implizites return (letzter Wert) und ein lexikalisches this, dass man kein var that benoetigt. Ab ES6";
    annotations["__proto__"] = "__proto__ ist ein ganz frueher von Mozilla eingefuehrter, heute praktisch allgegenwaertiger, Link, der zum Prototype fuehrt. Wenn man ihn setzt, setzt man den Prototype des Objekts, dem man ihn setzt, zur Laufzeit. Man kann unter den Header praktisch andere Koerper schrauben, wenn man dazu Daten im Constructor traegt. Das ist aber nur eine kewle Idee. In ES6 soll __proto__ womoeglich Standard werden."; // ergibt [Object object] statt der Annotation in einem {} Objekt
    annotations["constructor"] = "Sorgt dafuer, dass instanceof true ist. Ist der offizielle Link vom Prototype zurueck zur Constructor Funktion. Superclass.prototype.constructor() ist praktisch, um zu extenden. Hat ein F.prototype eine constructor Property, wird diese bei new F gerufen. Sie sorgt dafuer, dass instanceof true ist. new F ist sowas wie (aber nur sowas wie) F.protoype.constructor.apply({}, arguments); wobei das neue {} zurueckgegeben wird...";
    annotations["{}"] = "Ist meist ein Objektliteral. var obj = {}; f.bind({}, g); Kann aber auch ein leerer, vergessener Statementblock sein. if (0) {} else {}.";
    annotations["[]"] = "In JavaScript gibt es zwei eckige Klammern nur als ArrayLiteral [1,2,3,4]. Eine Angabe wie var array[] gibt es _nicht_ in JavaScript. [] steht immer fuer sich und fuer einen leeren Array. Mit . kann man direkt Funktionen rufen, wie var array = [].push(\"a\") was klueger var array = [\"a\"] bedeutet.";
    annotations["!"] = "UnaryOperator !. Negiert die Aussage, bedeutet dass !true == false und !false == true, die Formel !!zwerg wandelt in Boolean(zwerg) um";
    annotations["+"] = "BinaryOperator/UnaryOperator Bedeutetet Addition. Sobald einer der beiden aber ein String ist, Konkatenation (1+2==3, aber 1+'2'=='12'). Wird ebenfalls zur Stringkonkatenation ganzer_string = string1 + string2 benutzt. Als UnaryOperator ist es ein positives Vorzeichen UND es versucht die Variable dahinter in eine Number zu konvertieren.";
    annotations["+="] = "AssignmentOperator. Addieren und zuweisen. left += right ist das Gleiche wie left = left + right;";
    annotations["-="] = "AssignmentOperator. Subtrahieren und zuweisen. left -= right ist das Gleiche wie left = left - right;";
    annotations["*="] = "AssignmentOperator. Multiplizieren und zuweisen. left *= right ist das Gleiche wie left = left * right;";
    annotations["/="] = "AssignmentOperator. Dividieren und Zuweisen. left /= right ist das Gleiche wie left = left / right;";
    annotations["%="] = "AssignmentOperator. Rest nehmen und Zuweisen. left %= right ist das Gleiche wie left = left % right;";
    annotations["|="] = "Bitweises OR und Zuweisung. wenn a = 10 (0b1010) und b = 20 (0b10100), dann setzt a |= b die Variable a auf 30.";
    annotations["&="] = "Bitweises UND und Zuweisung. Wenn a = 10 (0b1010) und b = 20 (0b10100) dann ist a &= b === 0 (0b0)";
    annotations["^="] = "Bitweises XOR und Zuweisung. Ist a = 10 (0b1010) und b = 20 (0b10100), dann ist nach a ^= b das a = 30 (0b11110) und nach nochmal a^=b wieder 10, da XOR sein eigenes Invers ist.";
    annotations["^"] = "XOR. Wenn man a = 10 (0b1010) mit b = 20 (0b10100) XORt erhaelt man 30 (0b11110) und XORt man b ^ a, erhaelt man auch 30. Weist man das der einen Variable gleich zu und XORt nochmal mit der anderen, erhaelt man den Originalwert zurueck.";
    annotations["="] = "Ein = dient der Zuweisung von der rechten Seite (right-hand-side) zur linken Seite (left-hand-side). Mit = kann man keine Vergleiche anstellen.<br>= ist ein AssignmentOperator, wie &uuml;brigens auch +=, %=, *=, -=, <<=, etc.";
    annotations["=="] = "Ein doppeltes == dient einem Vergleich. Wenn die Typen nicht gleich sind, wird versucht, die rechte Seite zum Typen der linken zu konvertieren. (1 == \"1\"; dank type coercion)";
    annotations["==="] = "Ein dreifaches === ist ein strikter Vergleich. Hier muss auch der Typ uebereinstimmen (1 !== \"1\"; da strict und eine Number 1 kein String \"1\" ist) Bei Objekten und Arrays wird ihre Reference (Adresse) verglichen. Will man die Felder alle pruefen, muss man das selbst schreiben, siehe deepEqual Funktionsvorschlag im assert-Modul in node.js oder CommonJS deepEqual in Unit/Test/10 ";
    annotations["!="] = "Ein einfaches not-equal, mit type coercion (Rechte Seite dem Typ der Linken anpassen). Hier ist 0 == '0' und '1' != '2'";
    annotations["!=="] = "Ein strict-not-equal. Keine Umwandlung des Typs der rechten Seite zum Typ der linken Seite. Der Typ muss gleich sein. Hier muess 5 === 5 sein und nicht 5 === '5' (was Number 5 !== String '5' waere, was mit == wiederum gleich waere)";
    annotations["!!"] = "!! (Bangbang) wandelt eine Variable in ihren Booleanwert um. Aus !![1] (ein Array mit einer 1 als Index Element 0) wird zum Beispiel true und aus !!undefined und !!null wird jeweils false";
    annotations[":"] = "Ein Doppelpunkt steht in einem Objekt { a: 1, b: 2 } zwischen Propertyname und Wert.<br>\nBeim conditional Operator ?: (ConditionalExpression) steht er zwischen der linken (true) und rechten (false) Seite nach dem ?.<br>\nBei LabeledStatenebts steht er nach dem Identifier fuer das Label -> loop: while(1) { break loop; }";
    annotations[","] = "Mit dem Komma-Operator kann man 1.) Befehle nacheinander als ein Statement ausf&uuml;hren. Das letzte Ergebnis bleibt stehen. Bei einem if braucht man beispielsweise keine geschweiften Klammern nach der Kondition oder fuer den else-Teil, nimmt man Kommas. 2.) Das Komma trennt Eigenschaften im Objekt, trennt 3.) Elemente im Array. -- Der Komma Operator -- Ein Komma trennt im Array [a,b,c] die Elemente  voneinander. Im Objekt die Properties { a: 1, b: c }. Ein Komma kann zum trennen von Befehlen genommen werden, a(),b(),c(). Ergebnis ist der letzte Aufruf.";
    annotations[";"] = "Das Semikolon ist der Befehlstrenner. Ein Zeilenumbruch kann eine automatische Semikoloneinf&uuml;gung ausl&ouml;sen.";
    annotations["("] = "Oeffnende runde Klammer. Wenn etwas in runden Klammern steht wird es zuerst berechnet, alles in der Klammer zusammen ist eine Expression,  und das Ergebnis tritt an deren Stelle.\n Beispiel: ((cx = vx()) == 12) vergleicht cx == 12, nachdem das Resultat von vx() der cx zugewiesen wurde.<br>Ausserdem: Runde Klammern leiten Funktionsargumente ein function f (a, b, c), oder gruppieren die Argumente bei Invokationen f(a,b,c).<br>\nUnd um die Kondition des IfStatements, ForStatements, WhileStatements, SwitchStatements sind runde Klammern Pflicht.";
    annotations[")"] = "Schliessende runde Klammer. Wenn etwas in runden Klammern steht wird es zuerst berechnet, alles in der Klammer zusammen ist eine Expression,  und das Ergebnis tritt an deren Stelle.\n Beispiel: ((cx = vx()) == 12) vergleicht cx == 12,  nachdem das Resultat von vx() der cx zugewiesen wurde.<br>Ausserdem: Runde Klammern leiten Funktionsargumente ein function f (a, b, c), oder gruppieren die Argumente bei Invokationen f(a,b,c).<br>\nUnd um die Kondition des IfStatements, ForStatements, WhileStatements, SwitchStatements sind runde Klammern Pflicht. ";
    annotations["{"] = "Oeffnende geschweifte Klammern klammern Statements als BlockStatement ein. (if (x) {Statements} else {Statements}. FunctionBodies function f() {body} ebenso wie Objekte { a: 1, b:2 } ein.<br>\n Neu ist in EcmaScript 6 das Destructuring. let {first, last} = {first:'Vorname', last:'Nachname'} erzeugt die Variablen first und last mit den Inhalten der Objektproperties.";
    annotations["}"] = "Schliessende geschweifte Klammern klammern Statements (if (x) {/*{Statementblock}*/} else {/*{Statementblock}*/}, FunctionBodies function f() { /*body*/ } ebenso wie Objekte { a: 1, b:2 } ein.<br>\n Neu ist in EcmaScript 6 das Destructuring. let {first, last} = {first:'Vorname', last:'Nachname'} erzeugt die Variablen first und last mit den Inhalten der Objektproperties.";
    annotations["["] = "&Ouml;ffnende eckige Klammer. Eckige Klammern sind f&uuml;r [1,3,4] Arrays, ab ES6 Comprehensions [v for (v of [0,1,2,3])if (v > 1)] === [2,3],<br>\nobject[key] Subscript Operationen. Und sie umschliessen in ES6 [symbol]definierte Properties in Klassen und Objektliteralen.";
    annotations["]"] = "Schliessende eckige Klammer. Eckige Klammern sind f&uuml;r [1,3,4] Arrays, ab ES6 Comprehensions [v for (v of [0,1,2,3]) if (v > 1)] === [2,3],<br>\nobject[key] Subscript Operationen. Und sie umschliessen in ES6 [symbol]definierte Properties in Klassen und Objektliteralen. Klammern muessen immer in der richtigen Reihenfolge geschachtelt sein.";
    annotations["!!"] = "Zwei Ausrufezeichen wandeln den Ausdruck dahinter in einen Booleanwert um. Den kann man in einer logischen Verknuepfung auswerten, anstelle ein Objekt oder anderes Ergebnis, was der Ausdruck sonst ist, zwischen die Elemente der logischen Verknuefung (normal nur wahr und falsch) zu pappen..";
    annotations["||"] = "Der Default Operator || wertet, wenn der Ausdruck links falsch ist, den Ausdruck rechts aus.<br>Man kann damit logische Verknuepfungen und Regeln aufbauen. Mit variable = variable || 'defaultvalue' wird variable ein Wert zugewiesen, wenn ihrer undefined, null, false oder '' ist. Wurde variable gar nicht erst deklariert (mit var, let oder Parametern), gibt es einen ReferenceError: Undefinierte Variable.";
    annotations["&&"] = "Der Guard Operator && wertet den rechten Ausdruck nur aus, wenn der linke Ausdruck wahr ist.<br>Man kann damit logische Verknuepfungen und Regeln erstellen. Oder mit if (obj && obj.p) z.B. erstmal pruefen, ob eine Variable vorhanden ist. Ist sie (obj) es nicht, wird gar nicht auf den Folgewert (obj.p) zugegriffen und false anstelle des Ausdrucks gesetzt. Bei if (a && b) muessen beide wahr sein um in den if Block zu gelangen.";
    annotations["var"] = "Mit var deklariert man eine Variable. Sie wird intern nach oben gehoben und ist in der gesamten Funktion zu sehen. Zuerst mit undefined. Dann aber der Zeile, wo sie mit = einen Wert bekommt, gibt sie den Wert aus. Ab ES6 wird es let geben, womit man die Variable auf den Block beschraenkt. Sowie const, womit man nur lesbare Konstanten initialisieren kann. Eine const Variable kann man nur einmalig einen Wert zuweisen. var kann man jederzeit setzen. Ein var gilt fuer ihre Funktion und alle darin geschriebenen Funktionen. Ein Sonderfall ist noch die Funktion eval, die unter Umstaenden auch auf ihre Variablen zugreifen kann.";
    annotations["instanceof"] = "Ein binaerer Operator, object instanceof function. Prueft ob ein Objekt eine Instanz eines bestimmten Constructors ist. Hat dessen Prototype die Funktion als Constructor, ist instanceof auf jeden Fall true. Kann in JavaScript getrost vernachlaessigt werden und mit Duck-Typing (hasOwnProperty) und Einschaetzen des Objekts koennen Aufgaben besser geloest werden.";
    annotations["function"] = "Funktionen sind normale Objekte. Rufbare Objekte (engl. Callable). Man kann ihnen Properties zuweisen. Sie haben auch welche, wie ihren .name. Und Methoden wie .bind oder .call und .apply. In JavaScript sind functions first-class. Sie koennen als Statement gerufen werden, oder in Expressions. Sie koennen als Parameter uebergeben werden. Einfach einem Objekt, Array, einer Funktion mit . oder  [subscript] zuweisen. Mit () hinter dem Namen, kann man functions rufen. Wenn man sie einer Variable zuweist, wenn man sie schreibt, braucht sie keinen Namen. Das ist eine FunctionExpression. Eine FunctionDeclaration ist function gefolgt von einem Namen, Argumenten, dem FunctionBody Block und keinem Semikolon. Expresions haben ein Semikolon wie ein normaler Ausdruck hat.";
    annotations["arguments"] = "Das Arguments Objekt enthaelt alle Parameter, die beim Aufruf einer Funktion uebergeben wurden und ist nur innerhalb dieser gerufenen Funktion sichtbar. Ab ES6 gibt es ...rest RestParameter, die das arbeiten leichter machen.";
    annotations["JSRuntime"] = "JSRuntime ist die SpiderMonkey Laufzeitstruktur. Wird mit JSRuntime *rt = JS_CreateRuntime(bytes); gestartet. Mit der rt kann man dann den JSContext(rt, heapsize) erzeugen.";

   return {
      annotations: annotations,
      buttonNames: buttonNames,
      classAnnotations: classAnnotations,
   };

});
//--#include "lib/highlighter/annotations.en_US.js";
/*



 The Highlighter

 The Reason for the tokenizer to be separate

 It was running for a long time on my homepage for fun

 Later i continued this weak highlighter with the draft

 Now i have much bad code mixed with seriously engineered code.



 My Tip:

 Kick this highlighter.

 bad:    It has just tokens.

 so:    Get the parse tree.
 (And with a token list)


 plus:    Get the AST information by
 getting a node id and setting
 it on the span element.

 and:    Evaluate in an own realm per
 PRE Element.
 Btw. HTML Designer prolly and
 rather use -pre with code inside-,
 i should change this, too.



 Kick it for the following reason:

 make the tokenizer a part of the parser

 (just a few changes, to get
 rid of "next" working on an array
 and an expensiver "righthand" function
 doing a lookahead scan to the
 right, then letting last lookat(1) fall
 back to 0 by assignment
 and get the next token.)


 */




if (typeof window != "undefined") {





    define("highlight-gui", function (require, exports) {
        "use strict";
        

        /*
            maybe i should go soon with jquery.
         */
        /*
            that means ie + mobile + effects for free.
            and future for the code.
         */
        
        
        var tables = require("tables");
        var tokenize = require("tokenizer").tokenizeIntoArrayWithWhiteSpaces;
        var parse = require("parser");
        var Evaluate = require("runtime");
        var highlight = require("highlight").highlight;

        var lang = "de_DE";

        var hlIntl = require("annotations."+lang);

        var Builtins = tables.Builtins;
        var Punctuators = tables.Punctuators;
        var WhiteSpaces = tables.WhiteSpaces;
        var TypeOfToken = tables.TypeOfToken;
        var Keywords = tables.Keywords;

        var ClassNames = {
            __proto__: null,
            /* Elements */
            "wrapper": "syntaxjs-container",
            "buttons": "syntaxjs-button-container",
            "mainview": "syntaxjs-view",
            "token": "syntaxjs-tokens-button",
            "editorview": "syntaxjs-editor",
            "info": "syntaxjs-fileinformations",
            "console": "syntaxjs-eval-console",
            /* Buttons */
            "eval": "syntaxjs-native-eval-button",
            "original": "syntaxjs-originaltext-button",
            "linecount": "syntaxjs-lineno-button",
            "line": "syntaxjs-lineno",
            "editor": "syntaxjs-editor-button",
            "wordcount": "syntaxjs-wordcount-button",
            "wordcount-list": "syntaxjs-wordcountlist",
            "wordcount-panel": "syntaxjs-wordcount-panel",
            "wordcount-table": "syntaxjs-wordcount-table",
            "minify": "syntaxjs-minify-button",
            "tokens": "syntaxjs-tokens-button",
            "highlight": "syntaxjs-highlight-button",
            "ast": "syntaxjs-ast-button",
            "value": "syntaxjs-eval-button",
            "source": "syntaxjs-generator-button",
            "ss": "ss",
            "beauty": "syntaxjs-beautyfier-button",
            "shell-input": "syntaxjs-shell-input",
            "shell": "syntaxjs-shell-button",
            "language": "syntaxjs-language-button"

        };

        var DataAttributes = {
            "id": "data-syntaxjs",
            "highlight": "data-syntaxjs-highlight",
            "controls": "data-syntaxjs-controls",
            "language": "data-syntaxjs-language",
            "shell": "data-syntaxjs-shell"
        };
        var Duties = {
            "true": true,
            "yes": true,
            "y": true,
            "yo": true,
            "yep": true,
            "1": true

        };
        var OffDuties = {
            "false": true,
            "off": true,
            "no": true,
            "nay": true,
            "nope": true,
            "none": true,
            "0": true
        };

        /* the above should move into an external package, too, to become highly configurable. */

        /* and then i should rewrite the highlighter with a library to let it become attractive */

        var buttonNames;
        var annotationDiv;
        var classAnnotations;

        var annotations = Object.create(null);


        classAnnotations = hlIntl.classAnnotations;
        buttonNames = hlIntl.buttonNames
        annotations = hlIntl.annotations;


        var development_version = "<br><sub>ohne Gew&auml;hr</sub>";
        var clas = /syntaxjs-/;
        annotationDiv = document.createElement("div");
        annotationDiv.className = "syntaxjs-annotation";


        var ClassTests = {};        
        for (var k in ClassNames) {
            ClassTests[k] = true;
        }
        var NoOvers = {};
        NoOvers[ClassNames["info"]] = true;

        function addEventListener(element, type, func, capture) {
            if (typeof element.attachEvent === "function" && typeof element.addEventListener !== "function") {
                if (type == "DOMContentLoaded") type = "load";
                return element.attachEvent("on" + type, func);
            } else return element.addEventListener(type, func, capture);
        }
        function createRecord(element, options) {
            var rec = Object.create(null);
            if (element) {
                rec.element = element;
                rec.input = element.textContent;
                rec.options = options;
            }
            return rec;
        }
        function setRecord(rec, data) {
            if (typeof data == "object") assign(rec, data);
            return null;
        }
        function assign(obj, obj2) {
            for (var k in obj2)
                if (Object.hasOwnProperty.call(obj2, k))
                    obj[k] = obj2[k];
            return obj;
        }
        function setAnnotation(newAnnotation) {
            annotations = newAnnotation;
        }
        function getAnnotation() {
            return annotations;
        }
        function make_console_element(rec) {
            var element = rec.element;
            var consoleElement = document.createElement("div");
            consoleElement.className = ClassNames["console"];
            consoleElement.innerHTML = "<br>\n";
            element.parentNode.insertBefore(consoleElement, element.nextSibling);
            rec.consoleElement = consoleElement;
            return consoleElement;
        }
        function make_button(rec, cname, bname, clickhndlr, nopushbool) {
            var button = document.createElement("button");
            button.className = ClassNames[cname];
            button.innerHTML = buttonNames[bname];
            addEventListener(button, "click", clickhndlr);
            if (nopushbool) return button;
            return pushButton(rec, button)
        }
        /* append all buttons to the container element */
        function appendButtons(rec, element) {
            var buttons = rec.buttons;
            element = element || rec.wrapper;
            if (!rec || !element || !buttons) return; // fails silent
            var buttonContainer = rec.buttonContainer = document.createElement("div");
            buttonContainer.className = ClassNames["buttons"];
            for (var i = 0, j = buttons.length; i < j; i++) {
                if (buttons[i]) buttonContainer.appendChild(buttons[i]);
            }
            element.appendChild(buttonContainer);
        }
        /* remove all the buttons from the container */
        function removeButtons(rec, element) {
            var buttons = rec.buttons;
            element = element || rec.wrapper;
            if (!rec || !element || !buttons) return;
            for (var i = 0, j = buttons.length; i < j; i++) {
                if (buttons[i].parentNode) buttons[i].parentNode.removeChild(buttons[i]);
            }
        }
        // This function stores the buttons under each id.
        function pushButton(rec, button) {
            if (!rec.buttons) rec.buttons = [];
            rec.buttons.push(button);
            return button;
        }
        // CreateFeaturing Elements
        var registered_annotation = false;
        var globalControlsAttribute = document.documentElement.getAttribute(DataAttributes["controls"]);
        var globalControls = globalControlsAttribute !== undefined ? Duties[globalControlsAttribute] : false;
        function highlightElements(options) {

            var elements;
            var element, rec, hl, ctrl;
            var controls;
            var annotate;
            var att1, att2;
            var opts;
            var name;

            if (options === undefined) {
                options = defaultOptions();
            }
            if (!registered_annotation) {
                registered_annotation = true;
                addEventListener(window, "mouseover", annotateCode, false);
                addEventListener(window, "touchmove", annotateCode, false);
                addEventListener(window, "mouseout", annotateCode, false);
                addEventListener(window, "touchcancel", annotateCode, false);
            }

            for (var tag in options) {

                if (Object.hasOwnProperty.call(options, tag)) {

                    if (typeof tag === "string") {

                        if (elements = document.querySelectorAll(tag)) {

                            opts = options[tag];

                            if (opts) {
                                controls =  opts.controls !== undefined ? opts.controls : false;
                                annotate =  opts.annotate !== undefined ? opts.annotate : true;
                            } else {
                                controls = false;
                            }

                            for (var a = 0, b = elements.length; a < b; a++) {

                                if (element = elements[a]) {

                                    name = element.tagName;
                                    att1 = element.getAttribute(DataAttributes["highlight"]);
                                    att2 = element.getAttribute(DataAttributes["controls"]);

                                    hl = true;

                                    if (OffDuties[att1]) hl = false;
                                    else if (Duties[att1]) hl = true;

                                    ctrl = globalControls;

                                    if (Duties[att2]) ctrl = true;
                                    else if (OffDuties[att2]) ctrl = false;

                                    rec = createRecord(element, opts);
                                    if (controls && ctrl) createFeaturingElements(rec);

                                    if (hl) highlight(null, null, rec);
                                    rec = null;
                                }
                            }
                        }
                    }
                }
            }
        }
        // live Editor -
        // the first bug i got to was when replacing innerHTML with the highlighted text
        function createFeaturingElements(rec) {
            setTimeout(function () {
                createWrapper(rec);
                createNativeEvalButton(rec);
                createOriginalTextButton(rec);
                createShowLinesButton(rec);
                createEditorButton(rec);
                createWordCountButton(rec);
                createMinifyingButton(rec);
                createShowTokensButton(rec);
                createHighlightButton(rec);
                createShellButton(rec);
                createAstButton(rec);
                createEvaluateButton(rec);
                createFileInformations(rec);
                appendButtons(rec);
            },0);
            return rec;
        }
        //
        // CreateWrapper wraps the original pre with some elements,
        // to contain the buttons, console, second view, (maybe tabs soon)  and more
        //
        function createWrapper(rec) {
            var element = rec.element;
            var wrapper = rec.wrapper = document.createElement("div");
            var view = rec.view = document.createElement("div");
            wrapper.className = ClassNames["wrapper"];
            view.className = ClassNames["mainview"];
            if (element) {
                if (element.parentNode) element.parentNode.replaceChild(wrapper, element);
                wrapper.appendChild(view);
                view.appendChild(element);
            }
            return wrapper;
        }
        function createEditorButton(rec) {

            var element = rec.element;
            var wrapper = rec.wrapper;
            var view = rec.view;
            var editor, pre;
            var alledit;
            var timeout;
            var cursor, x, y, rect;
            var sel, newsel;
            var range, newrange;

            function createEditor() {
                /* Disabled highlighting until i fix the cursor */
                rec.editor = editor = document.createElement("pre");
                editor.className = ClassNames["editorview"];
                editor.contentEditable = "true";
                editor.innerHTML = rec.highlightedText || rec.input;
                // editor.innerHTML = highlight(null, null, rec);
                editor.hidden = false;
                if (editor.scrollIntoView) editor.scrollIntoView();

                function update() {
                    var text = "" + (editor.textContent || editor.innerText);
                    var ast;
                    rec.input = text;
                    rec.tokens = tokenize(text);
                    rec.ast = parse(rec.tokens);
                    ast = rec.astText = highlight(JSON.stringify(rec.ast, null, 4));
                    /* editor.innerHTML = highlight(text, null, rec); */
                    element.innerHTML = ast;
                    if (editor.scrollIntoView) editor.scrollIntoView();
                    /*
                     this was from mozilla
                     newsel  = window.getSelection();
                     newrange = newsel.getRangeAt(0);
                     newrange.setStart(range.startContainer, range.startOffset);
                     newrange.setEnd(range.endContainer, range.endOffset);*/
                    // cursor.moveToPoint(e.pageX, e.pageY);
                }
                addEventListener(editor, "keyup", function (e) {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                    }
                    // sel = window.getSelection() || document.selection;
                    // range = sel.getRangeAt(0);
                    // if (e.char == "\t") e.preventDefault();
                    timeout = setTimeout(update, 250);
                }, false);
                view.insertBefore(editor, element);
                element.innerHTML = highlight(JSON.stringify(rec.ast || parse(rec.tokens), null, 4));
            }
            return make_button(rec, "editor", "editor", function (e) {
                if (!editor) createEditor();
                else editor.hidden = !editor.hidden;
            });
        }
        // FileInformations are "Filesize: __ bytes, __ LOC, Format: (unimpl.)" on the bottom
        // special: the span with the infos is added to the buttons array which contains all other widgets (buttons)
        function createFileInformations(rec) {
            /* Mache was hover-touch-ables raus, was hochpopt wenn ich beruehre */
            var span = document.createElement("span");
            span.className = ClassNames["info"];
            var html = "Filesize: " + (rec.input || "").length + " bytes, ";
            html += (rec.input || "").split("\n").length + " LOC, ";
            span.innerHTML = html;
            rec.buttons.push(span);
        }
        // This buttons lets you return to the highlighted text
        function createHighlightButton(rec) {
            var element = rec.element;
            return make_button(rec, "highlight", "highlight", function (e) {
                if (!rec.highlightedText) {
                    rec.highlightedText = highlight(element.textContent);
                }
                element.innerHTML = rec.highlightedText;
                if (element.scrollIntoView) element.scrollIntoView();
            });
        }
        // This button uses the nativejs eval function coz i havent coded a AST.Evaluate() yet.
        function createNativeEvalButton(rec) {
            var element = rec.element;
            return make_button(rec, "eval", "eval", function (e) {
                var consoleElement = rec.consoleElement;
                if (!consoleElement) consoleElement = make_console_element(rec);
                var code = rec.input;
                var value;
                try {
                    value = eval(code);
                } catch (ex) {
                    value = "" + ex.message + "<br>\n" + ("" + ex.stack).split("\n").join("<br>\n");
                } finally {
                    consoleElement.innerHTML += value += "<br>\n";
                }
            });
        }
        // Finally i call Evaluate (i am proud not to be as stupid as my CV is)
        function createEvaluateButton(rec) {

            var element = rec.element;
            var consoleElement;
            return make_button(rec, "value", "value", function (e) {
                consoleElement = rec.consoleElement;
                if (!consoleElement) {
                    consoleElement = make_console_element(rec);
                }
                var code = rec.input;
                var value;
                try {
                    value = Evaluate(code);
                } catch (ex) {
                    value = "" + ex.message + "<br>\n" + ("" + ex.stack).split("\n").join("<br>\n");
                } finally {
                    consoleElement.innerHTML += (value + "<br>\n");
                }
            });
        }
        //
        // count_word adds 1 to the existing wordcount_obj[word] or creates a new entry [word] set to 1 on the wordcount_obj.
        //
        function count_word(word, wordcount_obj) {
            wordcount_obj[word] = typeof wordcount_obj[word] === "number" ? wordcount_obj[word] + 1 : 1;
        }
        /// Array.prototype.sort(sort_alpha) sortiert Worte.
        function sort_alpha(w1, w2) {
            var i, b1, b2;
            i = -1;
            do {
                i += 1;
                b1 = w1[i];
                b2 = w2[i];
                if (b1 < b2) return false;
                else if (b1 > b2) return true;
            } while (b1 === b2);
        }
        //
        // The wordcount buttons shows a label with some informations about the tokens (counters)
        // Has to be improved with cooler statistics.
        //
        function total(v) {
            return "<p>Total: <b>" + v + "</b></p>\n";
        }
        function ol() {
            return "<ol class=" + ClassNames["wordcount-list"] + ">";
        }
        function li(s, p) {
            return "<li>" + s + "x " + p + "\n";
        }
        function createWordCountButton(rec) {

            var flag = false;
            var panel = document.createElement("div");
            panel.className = ClassNames["wordcount-panel"];
            var calculated = false;
            var wordcount;

            var HighlighterWordCounterLabel = {
                "LineComment": "//comments",
                "MultiLineComment": "/*comments*/",
                "RegularExpressionLiteral": "/regex/",
                "StringLiteral": "'strings'",
                "TemplateLiteral": "`templates`"
            };

            function calculate() {

                wordcount = rec.wordcount = Object.create(null);
                var tokens = rec.tokens;
                var token, word, type;
                for (var i = 0, j = tokens.length; i < j; i++) {
                    word = tokens[i].value;
                    type = tokens[i].type;
                    count_word(HighlighterWordCounterLabel[type] || word, wordcount);
                }

                var html = "";
                // Aufgabe ol(array, verifier): gibt html liste aus
                var builtinlist = ol();
                var keywordlist = ol();
                var operatorlist = ol();
                var identifierlist = ol();
                var len = 0,
                    keywordc = 0,
                    operatorc = 0,
                    builtinc = 0,
                    identifierc = 0;
                Object.keys(wordcount).sort(sort_alpha).forEach(function (p) {
                    // for (p in wordcount) {
                    if (!WhiteSpaces[p]) { // hey, that is a create null so skip : && Object.hasOwnProperty.call(wordcount, p)) {
                        ++len;
                        if (Keywords[p]) {
                            keywordlist += li(wordcount[p], p);
                            ++keywordc;
                        } else if (Punctuators[p]) {
                            ++operatorc;
                            operatorlist += li(wordcount[p], p);
                        } else if (Builtins[p]) {
                            ++builtinc;
                            builtinlist += li(wordcount[p], p);
                        } else {
                            ++identifierc;
                            identifierlist += li(wordcount[p], p);
                        }
                    }
                    // }
                });
                // Aufgabe: supplant(template, data) Funktion um das zum Template zu machen
                builtinlist += "</ol>\n";
                keywordlist += "</ol>\n";
                operatorlist += "</ol>\n";
                identifierlist += "</ol>\n";
                html = "<table class='" + ClassNames["wordcount-table"] + "'>";
                html += "<thead><tr><th>builtins<th>keywords<th>operators<th>eigene identifier</tr></thead>";
                html += "<tbody><tr>";
                html += "<td>" + builtinlist;
                html += total(builtinc);
                html += "<td>" + keywordlist;
                html += total(keywordc);
                html += "<td>" + operatorlist;
                html += total(operatorc);
                html += "<td>" + identifierlist;
                html += total(identifierc);
                html += "</tbody>";
                html += "</table>";
                html += panel.innerHTML = html;
                calculated = true;
            }
            addEventListener(panel, "click", function (e) {
                flag = false;
                panel.parentNode.removeChild(panel);
            }, false);
            return make_button(rec, "wordcount", "wordcount", function (e) {
                e = e || event;
                var diviation;
                e.target || (e.target = e.srcElement);
                if (!flag) {
                    if (!calculated) calculate();

                    panel.style.position = "absolute";
                    panel.style.zIndex = "10000";
                    panel.style.top = (e.target.offsetTop - (2 * panel.clientHeight)) + "px";
                    diviation = e.target.offsetLeft + panel.clientWidth - e.target.offsetParent.clientWidth;
                    panel.style.left = (e.target.offsetLeft - (panel.clientWidth / 3) - (diviation > 0 ? diviation : 0)) + "px";
                    e.target.offsetParent.appendChild(panel);
                } else {
                    e.target.offsetParent.removeChild(panel);
                }
                flag = !flag;
            });
        }
        // fillnum(9, 3) returns "009" (fill "9" with 0s to a width of 3)
        function fillnum(n, w) {
            var s = "";
            var l = ("" + n).length;
            for (var i = 0; i < (w - l); i++) {
                s += " ";
            }
            s += n;
            return s;
        }
        //
        // This adds a line count by splitting the text into lines and adding a span in front of each
        //
        function createShowLinesButton(rec) {

            var element = rec.element;
            var oldtext, newtext, flag = false;
            var i, j;
            return make_button(rec, "linecount", "linecount", function (e) {
                if (!flag) {
                    oldtext = "" + element.innerHTML;
                    newtext = oldtext.split("\n");
                    for (i = 0, j = newtext.length; i < j; i++) {
                        newtext[i] = "<span class=" + ClassNames["line"] + " data-syntaxjs-line='" + (i + 1) + "'>" + fillnum(i + 1, ("" + j).length) + "</span>" + newtext[i];
                    }
                    newtext = newtext.join("\n");
                    element.innerHTML = newtext;
                } else {
                    element.innerHTML = oldtext;
                }
                flag = !flag;
                if (element.scrollIntoView) element.scrollIntoView();
            });
        }
        //
        // This is a minifier, which bases on the Tokens-Array
        //
        function minify(text) {
            var tokens;
            if (typeof text === "string") {
                tokens = tokenize(text);
            } else if (Array.isArray(text)) {
                tokens = text;
            } else throw new Error("Expected text or tokens");
            var el, peek;
            for (var i = 0, j = tokens.length; i < j; i++) {
                el = tokens[i];
                if (i < j - 1) peek = tokens[i + 1];
                else peek = "";
                if (!(/\s/.test(el.value[0]) || /Comment/.test(el.type))) text += el;
                if (/Keyword/.test(el.type) && !/Punctuator/.test(peek.type)) text += " ";
            }
            return text;
        }
        //
        // This function minifies the highlighted spans by testing for the classname
        //
        function minifySpans(rec) {

            var tokens = rec.highlightedTokens;
            var text = "";
            var el, peek;
            for (var i = 0, j = tokens.length; i < j; i++) {
                el = tokens[i];
                if (i < j - 1) peek = tokens[i + 1];
                else peek = "";
                if (!/\s/.test(el.value[0]) && !/Comment/.test(el.type)) text += el.value;
                if (/Keyword/.test(el.type) && !/Punctuator/.test(peek.type)) text += " ";
            }
            return text;
        }
        //
        // The minifier Button
        //
        function createMinifyingButton(rec) {
            var element = rec.element;
            var oldtext, newtext, flag = false;
            return make_button(rec, "minify", "minify", function (e) {
                if (!rec.minifiedText) {
                    rec.minifiedText = minifySpans(rec);
                }
                element.innerHTML = rec.minifiedText;
                if (element.scrollIntoView) element.scrollIntoView();
            });
        }
        //
        // Show original content of the Element
        //
        function createOriginalTextButton(rec) {
            var element = rec.element;
            return make_button(rec, "original", "original",
                function (e) {
                    element.innerHTML = rec.originalText;
                    if (element.scrollIntoView) element.scrollIntoView();
                });
        }
        // ununused
        function createToSourceButton(rec) {
            var source;
            var element = rec.element;
            return make_button(rec, "source", "source", function (e) {
                if (!source) {
                    try {
                        source = JSON.stringify(require("js-codegen")(rec.ast), null, 4);
                    } catch (ex) {
                        source = JSON.stringify(ex, null, 4);
                    }
                }
                element.innerHTML = source;
                if (element.scrollIntoView) element.scrollIntoView();
            });
        }
        //
        // Pressing this button displays the AST
        //
        function createAstButton(rec) {
            var ast;
            var element = rec.element;
            var oldtext, newtext, flag = false;
            return make_button(rec, "ast", "ast", function (e) {
                // if (!rec.astText || rec.editor) {
                try {
                    rec.ast = parse(rec.tokens || tokenize(rec.input));
                    // rec.ast = parse(rec.input, true);
                } catch (ex) {
                    rec.ast = ex;
                }
                rec.astText = highlight(JSON.stringify(rec.ast, null, 4));
                //  }

                element.style.maxHeight = window.height;
                element.style.overflow = "auto";

                element.innerHTML = rec.astText;
                //      element.appendChild(sourceButton);
                if (element.scrollIntoView) element.scrollIntoView();
            });
        }
        //
        // This Buttons shows the Tokens-Array
        // filterWhiteSpace used before displaying
        //
        function filterWhiteSpace(tokens) {
            return tokens.filter(function (token) {
                return token.type !== "WhiteSpace";
            });
        }
        function createShowTokensButton(rec) {
            var element = rec.element;
            var newtext;
            return make_button(rec, "token", "token", function (e) {
                newtext = rec.tokensText = highlight(JSON.stringify(filterWhiteSpace(rec.tokens), null, 4));
                element.innerHTML = newtext;
            });
        }
        function createBeautyfierButton(rec) {
            var element = rec.element;
            return make_button(rec, "beauty", "beauty", function (e) {
                element.innerHTML = highlight(beautify(rec.tokens));
            });
        }
        function createShellButton(rec) {
            var element = rec.element;
            var wrapper = rec.wrapper;
            var view = rec.view;
            var input;
            var code;
            var consoleElement;
            var val;
            var realm = rec.realm;

            function enter(e) {
                if (e.keyCode === 13) {
                    code = input.value;
                    if (code === ".clear") {
                        consoleElement.innerHTML = "-cleared console-<br>\n";
                    } else if (code === ".quit") {
                        consoleElement += "Quitting the Shell...";
                        input.parentNode.removeChild(input);
                        input = null;
                        realm = null;
                    } else {
                        if (!realm) {
                            realm = syntaxjs.createRealm();
                        }
                        try {
                            val = realm.eval(code);
                        } catch (ex) {
                            val = ex.message + "<br>\n" + ("" + ex.stack).split("\n").join("<br>n");
                        } finally {
                            consoleElement.innerHTML += val + "<br>\n";
                            input.value = "";
                        }
                    }
                }
            }

            return make_button(rec, "shell", "shell", function (e) {
                consoleElement = rec.consoleElement;
                if (!consoleElement) consoleElement = make_console_element(rec);
                if (!input) {
                    input = document.createElement("input");
                    input.type = "text";
                    input.className = ClassNames["shell-input"];
                    consoleElement.parentNode.insertBefore(input, consoleElement);
                    addEventListener(input, "keyup", enter);
                }

                var code = rec.ast || rec.tokens;
                try {
                    val = syntaxjs.eval(code, true, true);
                } catch (ex) {
                    val = ex.message + "<br>\n" + ("" + ex.stack).split("\n").join("<br>n");
                } finally {
                    consoleElement.innerHTML += "re-initialized code<br><br>\n" + val + "<br>\n";
                    if (consoleElement.scrollToBottom) consoleElement.scrollToBottom();
                    input.value = "";
                }

            });
        }
        /* War das 1. Feature */
        function annotateCode(e) {
            var key, str, html, target, className;
            e = e || window.event; // wack browser programmer i am
            target = e.target || e.srcElement;
            className = target.className;

            if (target.tagName === "SPAN" && clas.test(className) && !NoOvers[className]) {
                if (e.type === "mouseout" && annotationDiv.parentNode) annotationDiv.parentNode.removeChild(annotationDiv);
                if (e.type === "mouseover") {
                    key = target.innerText || target.textContent || target.innerHTML;
                    html = "";
                    // 1. Zeile key ist ein
                    if (str = TypeOfToken[key]) { // mal ausprobieren.
                        html += key + " ist ein " + str + "<br>\n";
                        /* ungeeignet genauer
                         if (str = PunctToExprName[key]) {
                         html += str + "<br>\n";
                         }
                         */
                    }
                    // 2. Zeile annotation
                    if ((str = annotations[key])) html += str;
                    else {
                        if (str = classAnnotations[className]) html += str + "<br>\n";
                        else html += key + " wird demn&auml;chst hier n&auml;her erl&auml;utert.<br>\n";
                    }
                    /*
                     var nodeid;
                     if (oid=target.getAttribute("data-syntaxjs-oid")) {
                     html += "<br>Newsflash: dieses Token hat eine spezielle Id, die es ermoeglicht in den anderen Syntaxtree zu navigieren.<br>";
                     }
                     */
                    annotationDiv.innerHTML = html;
                    annotationDiv.innerHTML += development_version;
                    annotationDiv.style.position = "absolute";
                    annotationDiv.style.top = (target.offsetTop + (4 * target.offsetHeight)) + "px";
                    annotationDiv.style.left = target.offsetLeft + "px";
                    target.offsetParent.appendChild(annotationDiv);
                }
            }
        }


        function setLanguage(lang) {
            var pack = require("annotations."+lang);
            classAnnotations = pack.classAnnotations;
            annotations = pack.annotations;
            buttonNames = pack.buttonNames;
        }

        function selectLanguage(e) {
            var list = document.createElement("ol");
            var languages = require("i18n").languages;
            for (var key in languages) {
                var node = document.createElement("li");
                li.className = ClassNames["language-li"];
                li.setAttribute("data-syntaxjs-value", key);
                li.onclick = function (e) {
                    setLanguage(lang);
                };
                li.innerHTML = key;
                list.appendChild(li);
            }
            e.target.appendChild(list);
            list.onclick = function() {
                list.parentNode.removeChild(list);
            }
        }

        function addLanguageButton(parentSelector) {
            var parent = document.querySelector(parentSelector);
            if (parent) {
                var button = document.createElement("button");
                button.className = ClassNames["language"];
                button.innerHTML = buttonNames["language"];
                button.onclick = selectLanguage;
                parent.appendChild(button);
            } else {
                throw new TypeError("syntaxjs.highlighter.addLanguageButton() can not select element to add language button");
            }
        }


        
        /*
         Startet den Highlighter *****
         */
        
        function defaultOptions() {
            var options = Object.create(null);
            options["PRE"] = {
                controls: false,
                syntaxerrors: true
            };
            options["CODE"] = {
                controls: false,
                annotate: true
            };
            return options;
        }
        
        function startHighlighterOnLoad() {
            var config;
            var script = document.querySelector("script[data-syntaxjs-config]");
            if (script) config = script.getAttribute("data-syntaxjs-config");
            if (config) config = JSON.parse(config);
            else config = defaultOptions();
            var onload = function (e) {
                setTimeout(highlightElements.bind(null,config), 0);
            };
            addEventListener(window, "DOMContentLoaded", onload, false);
        }
        /* -------------------------------- */
        exports.startHighlighterOnLoad = startHighlighterOnLoad;
        exports.highlightElements = highlightElements;
        exports.addLanguageButton = addLanguageButton;
        return exports;

    });

}


    // evaluation in web workers should save some of the ux
    
/*
 *
 *  syntax.js web worker module
 *
 *  if it´s loaded, it provides a message handler for the worker thread
 *  the file lib/app.js calls syntaxjs.subscribeWorker which registers a
 *  predefined message handler.
 *  You can program your own handlers and call syntax.js in
 *  But this defines some builtin commands
 *
 *  postMessage({ command: "highlight", text: sourceText });
 *  returns a text replaced with span elements (a highlighted text)
 *  you can pass [text1,text2,text3] and get each one back highlighted
 *
 *  postMessage({ command: "value", text: sourceText });
 *  returns what the toValue Function would return on evaluating sourceText
 *  postMessage({ command: "value-keepalive", text: sourceText })
 *  returns the toValue of sourceText but keeps the Environment alive
 *
 *  This "keepalive" will be replaced with the creation of realms.
 */


define("syntaxjs-worker", function (require, exports, module) {
    "use strict";

    /*

    issue: doesnt use createrealm() right now but the old interface
     */

    if (typeof importScripts === "function") {
        var highlight = require("highlight");
        var interprete = require("runtime");
        var messageHandler = function message_handler(e) {
            var html;
            var text = e.data.text;
            var command = e.data.command;
            var keepalive = false;
            switch (command) {
                case "highlight":
                    if (Array.isArray(text)) {
                        html = [];
                        for (var i = 0, j = text.length; i < j; i++) {
                            html.push(highlight(text[i]));
                        }
                    } else {
                        html = highlight(text);
                    }
                    self.postMessage(html);
                    break;

                case "value-keepalive":
                    keepalive = true;
                case "value":
                    if (Array.isArray(text)) {
                        var result = [];
                        for (var i = 0, j = text.length; i < j; i++) {
                            result.push(interprete(text[i], keepalive));
                        }
                    } else {
                        result = interprete(text, keepalive);
                    }
                    self.postMessage(result);
                    break;
                default:
                    break;
            }
        };
        var subscribeWorker = function subscribeWorker() {
            var message_handler = exports.messageHandler;
            self.addEventListener("message", messageHandler, false);
        };
        exports.messageHandler = messageHandler;
        exports.subscribeWorker = subscribeWorker;
    }
    return exports;
});



    // the commandline shell is my favorite playtoy
    

define("syntaxjs-shell", function (require, exports) {
    
    var fs, readline, rl, prefix, evaluate, startup, evaluateFile, prompt, haveClosedAllParens, shell;
    
    var defaultPrefix = "es6> ";
    var multilinePrefix = "...> ";
    var inputBuffer = "";

    if (typeof process !== "undefined" && typeof module !== "undefined") {

        prefix = defaultPrefix;

        startup = function startup() {
            console.time("Uptime");
            fs = module.require("fs");
            readline = module.require("readline");
            rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
        };

        evaluate = function evaluate(code, continuation) {
                var val;
                try {
                    val = syntaxjs.eval(code, true);
                } catch (ex) {
                    val = ex.message + "\n" + ("" + ex.stack).split("\n").join("\r\n");
                } finally {
                    console.log(val);
                    if (continuation) setTimeout(continuation, 0);
                }
        };

        evaluateFile = function evaluateFile(file, continuation) {
            var code;
            console.log("-evaluating " + file + "-");
            try {
                code = fs.readFileSync(file, "utf8");
            } catch (err) {
                code = undefined;
                console.log(file + " not readable!");
                console.dir(err);
            }
            if (code) evaluate(code, continuation);
        };

        //
        // this is some additional hack to emulate multiline input
        //
 
        var savedInput ="";
        var isOpenParen = {
            __proto__:null,
            "(":true,
            "{":true,
            "[":true
        };
        var isCloseParen = {
            __proto__:null,
            ")": true,
            "}": true,
            "]": true
        };
        var isRightParen = {
            __proto__: null,
            "(":")",
            "[":"]",
            "{":"}"
        };
        
        haveClosedAllParens = function (code) {
            var parens = [];
            for (var i = 0, j = code.length; i < j; i++) {
                var ch = code[i];
                if (isOpenParen[ch]) {
                    parens.push(ch);
                } else if (isCloseParen[ch]) {
                    if (!parens.length) throw new SyntaxError("syntax.js shell: nesting error. stack is empty but you closed with a "+ch);
                    var p = parens.pop();
                    if (!(isRightParen[p] === ch)) {
                        throw new SyntaxError("syntax.js shell: nesting error. closing parens do not match open parens on the stack.");
                    }
                }
            }
            return parens.length === 0;
        };
        
        //
        // prompt is now called again, and the savedInput is prepending the new inputted code.
        //

        prompt = function prompt() {
            
            rl.question(prefix, function (code) {
                if (code == "") return setTimeout(prompt);

                if (code === ".break") {
                    savedInput = "";
                    prefix = defaultPrefix;
                    setTimeout(prompt);
                    return;
                }
                if (savedInput === "" && code[0] === ".") {
                    if (/^(\.print)/.test(code)) {
                        code = code.substr(7);
                        try {
                    	    console.log(JSON.stringify(syntaxjs.parse(code), null, 4));
                        } catch (ex) {
                    	    console.log(ex.message);
                    	    console.log(ex.stack);
                        }
                        setTimeout(prompt);
                        return;
                    } else if (/^(\.tokenize)/.test(code)) {
                        code = code.substr(8);
                        console.log(JSON.stringify(syntaxjs.tokenize(code), null, 4));
                        setTimeout(prompt);
                        return;
                    } else if (code === ".quit") {
                        console.log("Quitting the shell");
                        process.exit();
                        return;
                    } else if (/^(\.load\s)/.test(code)) {
                        var file = code.split(/\s/)[1]; // substr(6);
                        evaluateFile(file, prompt);
                        return;
                    } else if (/.help/.test(code)) {
                        console.log("shell.js> available commands:");
                        console.log(".print <expression> (print the abstract syntax tree of expression)");
                        console.log(".load <file> (return file from disc as a string)");
                        console.log(".quit (quit the shell with process.exit instead of ctrl-c)");
                        setTimeout(prompt);
                        return;
                    } 

                }
                if (savedInput) code = savedInput + code;
                
                try {
                    var valid = haveClosedAllParens(code);
                } catch (ex) {
            	    console.log(ex.message);
            	    console.log(ex.stack);
            	    setTimeout(prompt);
            	    return;
                }
                if (valid) {        
                    prefix = defaultPrefix;
                    savedInput = "";
                    evaluate(code, prompt);
                    return;
                } else {
                    prefix = multilinePrefix;
                    savedInput = code;  
                    setTimeout(prompt);
                    return;
                }
            });
        };

        shell = function main() {
            var file;
            startup();
            if (process.argv[2]) file = process.argv[2];
            if (!file) setTimeout(prompt);
            else evaluateFile(file, prompt);
            process.on("exit", function () {
                console.log("\nHave a nice day.");
                console.timeEnd("Uptime");
            });
        };

    } else shell = function () {};
    return shell;
});




    // assembling and autostart of shell or browser highlighter

// #######################################################################################################################
// the closure around this is new in _main_.js, the main template
// #######################################################################################################################

// define("syntaxjs", function () {

    function pdmacro(v) {
        return {
            configurable: false,
            enumerable: true,
            value: v,
            writable: false
        };
    }

    var VERSION = "0.0.1";
    var syntaxjs_public_api_readonly = {
    // essential functions
        version: pdmacro(VERSION),
        define: pdmacro(define),
        require: pdmacro(require),
        Promise: pdmacro(makePromise),
        tokenizeIntoArrayWithWhiteSpaces: pdmacro(require("tokenizer").tokenizeIntoArrayWithWhiteSpaces),
        tokenizeIntoArray: pdmacro(require("tokenizer").tokenizeIntoArray),
	    tokenize: pdmacro(require("tokenizer")),// <-- needs exports fixed
        parse: pdmacro(require("parser")),// <-- needs exports fixed
        parseGoal: pdmacro(require("parser").parseGoal),
        eval: pdmacro(require("runtime")),// <-- needs exports fixed
        createRealm: pdmacro(require("api").createPublicCodeRealm),
        toJsLang: pdmacro(require("js-codegen")),// <-- needs exports fixed

    // or is it a bridge? pattern mania continues

        makeAdapter: pdmacro(require("filesystem").makeAdapter),

    // experimental functions

        readFile: pdmacro(require("filesystem").readFile),	
        readFileSync: pdmacro(require("filesystem").readFileSync),

  // put into filesystem.js please
        evalFile: pdmacro(function (name, callback, errback) {
            var syntaxjs = this;
            return this.readFile(name, function (code) {
                return callback(syntaxjs.eval(code));
            }, function (err) {
                return errback(err);
            });
        }),
        evalFileSync: pdmacro(function (name) {
            return this.eval(this.readFileSync(name));
        }),

        evalStaticXform: pdmacro(require("runtime").ExecuteAsyncStaticXform),
        evalAsync: pdmacro(require("runtime").ExecuteAsync),
        evalAsyncXform: pdmacro(require("runtime").ExecuteAsyncTransform)
        // arraycompile: pdmacro(require("arraycompiler").compile)
    };
    
    var syntaxjs_highlighter_api = {
        highlight: pdmacro(require("highlight"))
    };
    
    // 1. The following block sets a property on syntaxjs
    // telling, which "system" has been detected (currently, only poorly "browser, node, worker" are supported, doesn´t work in spidermonkey or nashorn)
    // 2. the public properties are defined with defineProperties.
    // in the browser block the highlighter app is added 
    
    if (typeof window == "undefined" && typeof self !== "undefined" && typeof importScripts !== "undefined") {
    // worker export
        syntaxjs.system = "worker";
        syntaxjs_public_api_readonly.subscribeWorker = pdmacro(require("syntaxjs-worker").subscribeWorker);

    } else if (typeof window !== "undefined") {
    // browser export
        syntaxjs.system = "browser";
        syntaxjs_public_api_readonly.subscribeWorker = pdmacro(require("syntaxjs-worker").subscribeWorker);
        syntaxjs_highlighter_api.highlightElements = pdmacro(require("highlight-gui").highlightElements);
        syntaxjs_highlighter_api.startHighlighterOnLoad = pdmacro(require("highlight-gui").startHighlighterOnLoad);

    } else if (typeof process !== "undefined") {
    // node js export

        if (typeof exports !== "undefined") exports.syntaxjs = syntaxjs;
        syntaxjs.system = "node";
        syntaxjs_public_api_readonly.nodeShell = pdmacro(require("syntaxjs-shell"));// <-- needs exports fixed
        Object.defineProperties(exports, syntaxjs_public_api_readonly);
        Object.defineProperties(exports, syntaxjs_highlighter_api);

    } else if (typeof load == "function" && typeof print == "function") {
        if (typeof version === "function")  syntaxjs.system = "spidermonkey";
        if (typeof Java === "object")       syntaxjs.system = "nashorn";
        if (typeof exports !== "undefined") exports.syntaxjs = syntaxjs;
    }

    // ASSIGN properties to a SYNTAXJS object (all platforms)
    Object.defineProperties(syntaxjs, syntaxjs_public_api_readonly);
    Object.defineProperties(syntaxjs, syntaxjs_highlighter_api);

    var i18n = require("i18n");
    i18n.addLang("de_DE");// requires("languages.de_DE") and add exports to require("i18n").languages["de_DE"];
    i18n.addLang("en_US");// requires("languages.en_US") and add exports to require("i18n").languages["en_US"];
    i18n.setLang("en_US");// sets i18n.languages.lang to i18n.languages.en_US; (lang is the default key)

// });
/*
* automatic start (included at the end of the main script)
*/
if (syntaxjs.system === "node") {
    if (!module.parent) syntaxjs.nodeShell();
} else if (syntaxjs.system === "browser") {
    syntaxjs.startHighlighterOnLoad();
} else if (syntaxjs.system === "worker") {
    syntaxjs.subscribeWorker();
} else if (syntaxjs.system === "spidermonkey") {
    print("syntax.js was successfully loaded but all console/node deps may not be removed yet");
} else if (syntaxjs.system === "nashorn") {
    print("support for java coming");
}



    return syntaxjs;

}());