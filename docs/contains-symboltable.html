<!doctype html>
<meta charset=utf8>
<body>

<h1>Symboltable + Contains</h1>
<h2>Static Semantics</h2>

<p>How to check for Identifiers in constant time? How to check contains in constant time?</p>

<p><s>This is a blueprint of a combined datastructure carrying the facilities for both. Plus an additional feature.
	You can ask for VarDeclaredNames and LexicallyDeclaredNames and generate them from the symbol table.</s></p>

    <p>(isnt complete he says)</p>

		<p>Later it will replace the static semantics in syntax.js (terrible name for a software).</p>

<pre>

    function StaticSemantics() {
        "use strict";

        // Parameter
        var ps = Object.create(ParameterStack.prototype);
        ps.stacks = Object.create(null);
        ps.stacks["Default"] = [];
        ps.stacks["GeneratorParameter"] = [];
        ps.stacks["In"] = [];
        ps.stacks["Return"] = [];
        ps.stacks["Yield"] = [];
      
        // Contains
        var container = Object.create(null);
        var containers = [container];

        // SymbolTable
        var LexEnv = Object.create(null);
        var VarEnv = LexEnv;
        var varEnvs = [VarEnv];
        var lexEnvs = [LexEnv];        
        
        // faster lexNames than the recursive slow-static-semantic function or to complicated with all the arrays?
        /*
        var lexNames;
        var lexDecls;
        var varNames;
        var varDecls;
        // stacks
        var LexNames = [];
        var LexDecls = [];
        var VarNames = [];
        var VarDecls = [];
        */
        // Contains

        function newContainer() {
            containers.push(container);
            container = Object.create(null);
        }

        function popContainer() {
            container = containers.pop();
        }

        function put(production, value) {
            container[production] = value === undefined ? true : value; 
        }

        function contains(production) {
            if (container)
            if (Object.hasOwnProperty.call(container, production)) return container[production] || true;
            else return false;
        }

        // Parameter 

        function getParameter(name) {
            var stack = ps.stacks[name];
            return stack[stack.length-1];
        }
        
        
        function newParameter(name, value) {
            var stack = ps.stacks[name];
            stack.push(value);
            return value;
        }
        
        function popParameter(name) {
            var stack = ps.stacks[name];
            return stack.pop();
        }

        // Variable Environment

        function newVarEnv() {
            varEnvs.push(VarEnv);
            VarEnv = Object.create(LexEnv);
        /*
            VarEnv.varNames = [];
            VarEnv.varDecls = [];
        */
            lexEnvs.push(LexEnv);
            LexEnv = Object.create(LexEnv);
        /*
            LexNames.push(lexNames);
            lexNames = [];
            LexDecls.push(lexDecls);
            lexDecls = []; 
        */
            return VarEnv;
        }

        function newLexEnv() {
            lexEnvs.push(LexEnv);
            LexEnv = Object.create(LexEnv);
        /*
            LexNames.push(lexNames);
            lexNames = [];
            LexDecls.push(lexDecls);
            lexDecls = [];
        */
            return LexEnv;
        }

        function popEnvs() {
            container = containers.pop();

            if (LexEnv === VarEnv) {
                VarEnv = varEnvs.pop();
            }
            LexEnv = lexEnvs.pop();
            return LexEnv;
        }

        function addLexBinding(name, param) {
            SyntaxAssert(!hasLexBinding(name), name + "is a duplicate identifier in lexical scope!");
            LexEnv[name] = param === undefined ? true : param;
        }


        function addVarBinding(name, param) {
            SyntaxAssert(!hasVarBinding(name) || !inStrictMode, name + "is a duplicate identifier in variable scope!");
            VarEnv[name] = param === undefined ? true : param;
        }

        function hasVarBinding(name) { 
            return Object.hasOwnProperty.call(VarEnv, name);

        }

        function hasLexBinding(name) { 
            return Object.hasOwnProperty.call(LexEnv, name);
        }

        function addVarDecl(decl) {
            varDecls.push(decl);
        }
        function varDecls() {
            return varDecls;
        }
        function addLexDecl(decl) {
            lexDecls.push(decl);
        }
        function lexDecls() {
            return lexDecls;
        }

        function lexNames() {
            var boundNames = [];
            for (var v in LexEnv) {
                if (Object.hasOwnProperty.call(LexEnv, v)) boundNames.push(v);
            }
            return boundNames;
        }

        function varNames() {
            var boundNames = [];
            for (var v in VarEnv) if (Object.hasOwnProperty.call(VarEnv, v)) boundNames.push(v);
            return boundNames;
        }

        return {
            // parameters
            getParameter: getParameter,
            newParameter: newParameter,
            popParameter: popParameter,
            // contains
            newContainer: newContainer,
            popContainer: popContainer,
            put: put,
            contains: contains,
            // lexNames, varNAmes
            newVarEnv: newVarEnv, // var +& lex
            newLexEnv: newLexEnv, // lex
            popEnvs: popEnvs,
            addLexBinding: addLexBinding,
            addVarBinding: addVarBinding,
            hasVarBinding: hasVarBinding,
            hasLexBinding: hasLexBinding,
        /*
            addVarDecl: addVarDecl,
            addLexDecl: addLexDecl,
            varDecls: varDecls,
            lexDecls: lexDecls,
        */
            lexNames: lexNames,
            varNames: varNames,
            //
            constructor: StaticSemantics,
            toString: function () { return "[object EcmaScript StaticSemantics]"}
        };

        // Needs to be renamed

    }

</pre>

<p>lexDecls and varDecls and -names arenÂ´t enabled yet. 


<p>Here is how the thing works.</p>

<pre>
var staticSemantics = StaticSemantics();



</pre>


<pre>
	function FunctionDeclaration () {
		contains.newContainer(); // add a new contains bucket, add e.g. the node.type and check for "YieldExpression".
		contains.newVarEnv(); // creates a new varEnv which is also a base lexEnv;
		var node = { type: "FunctionDeclaration"};
		// ...
		EarlyErrors(node); // that would throw the early error
		contains.popEnvs(); // remove the scope
		contains.popContainer();	// after early error
	}


	EarlyErrors.FunctionDeclaration = function (node) {
		Assert(!contains.contains("ReturnStatement"), "Return Statements are forbidden");
	}

	function EarlyErrors(node) {
		var handler = EarlyErrors[node.type];
		if (handler) handler(node);
		// man koennte try-catch nehmen und controllen.
	}
</pre>

</body>
