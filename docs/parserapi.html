<h2>Parser-API</h2>


<h2>For-In/Of Statements</h2>

<pre>
    for (let x of [1,2,3]) 
    
    {
	type: "ForDeclaration"
	kind: "let"
	id: { type: "Identifier", name: "x" }
    }
    
    for (let [k,v] of [1,2,3]) 
    
    {
	type: "ForDeclaration",
	kind: "let",
	id: { type: "ArrayPattern", elements: [ { type: "Identifier", name: "k"}, {type:"Identifier", name: "v" } ] }
    }
</pre>


<h2>Spread Expression</h2>


<pre>

    f(...expr)

    {
	type: "SpreadExpression"
	argument: { type: "Identifier", name: "expr" }
    }    
    

    {
	type: "SpreadExpression"
	argument: AssignmentExpression
    }

</pre>
    


<h2>Rest Parameter</h2>

<pre>

    function f(...rest) {}
    {
	type: "RestParameter"
	id: "rest"
    }    
    

    {
	type: "RestParameter"
	id: string
    }

</pre>
    
    
<h2>Default Parameters (*)</h2>

<p>(*) There is a .defaults and .rest property on FunctionDeclaration nodes,
which is currently not supported by myself, because i do not know how to use 
the former.</p>

<p>The parameters</p>
<pre>
    f(a = 3) { }
</pre>

<p>Be replaced with this node</p>

<pre>    
    { 
	type: "DefaultParameter", 
	id: "a", 
	init: { 
	    type: "NumericLiteral", 
	    value: "3" 
	} 
    }
</pre>

<p>Which can be seen as</p>

<pre>    
    {
	type: "DefaultParameter"
	id: string
	init: AssignmentExpression
    }
</pre>


<h2>BindingPatterns</h2>

<pre>

    let { name: alias } = { name: "Edward" }
    
    type: "VariableDeclarator
    declarations: [
	{ 
	    type: "BindingElement", 
	    id: "name", 
	    as: "alias" 
	}
    ]
        
    {
	type: "BindingElement"
	id: Identifier
	as: Identifier
    }
    
</pre>


<h2>ObjectExpressions/ Computed Properties</h2>

<pre>
    let symbol = Symbol();
    let obj = {
	[symbol]: "computed property"
    }
</pre>

<p>new in  properties[]</p>

<pre>    
    {
	type: "PropertyDefinition",	// new with name
	kind: "computed",		// new
	key: AssignmentExpression,
	value: AssignmentExpression
    }
    
</pre>


<h2>Method Definitions</h2>

<pre>

    {
	type: "MethodDefinition",
	strict: bool
	generator: bool
	computed: bool 		// [s] computed property
	kind: get|set		// 
	params:	FormalParameters
	body: FunctionBody
	static: bool
    }

</pre>


<h2>Template Literals</h2>

<p>New Tokens (no!!!!)</p>

<pre>
<strike>
    {
	type: "TemplateHead",
	value: "`abcd ${`"
    }

    {
	type: "TemplateMiddle",
	value: "} abcd ${`
    }
    
    {
	type: "TemplateTail",
	value: "} abcd`"
    }
</strike>
</pre>

<p>This is the token</p>

<p>No ` or ${ or } are captured to make it very easy and fast to become processed</p>

<pre>
    {
	type: "TemplateLiteral"
	value: [ "ich", "bin", toll" ] // result of `ich ${ bin } toll`;
	//a NoSubstitutionTemplate is of value.length 1
    }
</pre>



<p>New Node</p>

<pre>
    { 
	type: "TemplateLiteral",
	spans: []
    }
</pre>



<h2>Modules</h2>

<pre>
	{
	    type: "ModuleDeclaration",
	    id: "m",
	    strict: true,
	    body: []
	    
	    // Loader Requirements
	    
	    moduleRequests: [],	    
	    knownExports: [],
	    unknownExports: [],
	    knownImports: [],
	    unknownImports []
	    // .requests, .imports, .exports? enuff?
	}
</pre>
<p>i forgot what the imports and NamedImports Nodes i defined are and don´t 
know what´s left later</p>

<pre>
	{
		type: "ImportStatement"
		imports: [		
		    {
			// ..
		    }
		]
	}
</pre>
<p>The export statement (i forgot what i parsed into exports)</p>

<pre>
	
	{
		type: "ExportStatement"
		exports: [
		
		    {
			// ..
		    }
		]
	}

</pre>


<h2>Regular Expression</h2>

<p>Token</p>

<pre>
 {
    type: "RegularExpressionLiteral",
    value: [ expr, flags ] // expr is without leading / and trailing / 
 }
</pre>